<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />
    <title>Apple Pay - Product Page</title>
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.6.2/dist/css/bootstrap.min.css" />
    <script src="https://cdn.jsdelivr.net/npm/jquery@3.5.1/dist/jquery.slim.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@4.6.2/dist/js/bootstrap.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@4.6.2/dist/js/bootstrap.bundle.min.js"></script>
    <style>
        /**
        * Swiper 10.0.4
        * Most modern mobile touch slider and framework with hardware accelerated transitions
        * https://swiperjs.com
        *
        * Copyright 2014-2023 Vladimir Kharlampidi
        *
        * Released under the MIT License
        *
        * Released on: July 8, 2023
        */

        /* FONT_START */
        @font-face {
            font-family: "swiper-icons";
            src: url("data:application/font-woff;charset=utf-8;base64, d09GRgABAAAAAAZgABAAAAAADAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABGRlRNAAAGRAAAABoAAAAci6qHkUdERUYAAAWgAAAAIwAAACQAYABXR1BPUwAABhQAAAAuAAAANuAY7+xHU1VCAAAFxAAAAFAAAABm2fPczU9TLzIAAAHcAAAASgAAAGBP9V5RY21hcAAAAkQAAACIAAABYt6F0cBjdnQgAAACzAAAAAQAAAAEABEBRGdhc3AAAAWYAAAACAAAAAj//wADZ2x5ZgAAAywAAADMAAAD2MHtryVoZWFkAAABbAAAADAAAAA2E2+eoWhoZWEAAAGcAAAAHwAAACQC9gDzaG10eAAAAigAAAAZAAAArgJkABFsb2NhAAAC0AAAAFoAAABaFQAUGG1heHAAAAG8AAAAHwAAACAAcABAbmFtZQAAA/gAAAE5AAACXvFdBwlwb3N0AAAFNAAAAGIAAACE5s74hXjaY2BkYGAAYpf5Hu/j+W2+MnAzMYDAzaX6QjD6/4//Bxj5GA8AuRwMYGkAPywL13jaY2BkYGA88P8Agx4j+/8fQDYfA1AEBWgDAIB2BOoAeNpjYGRgYNBh4GdgYgABEMnIABJzYNADCQAACWgAsQB42mNgYfzCOIGBlYGB0YcxjYGBwR1Kf2WQZGhhYGBiYGVmgAFGBiQQkOaawtDAoMBQxXjg/wEGPcYDDA4wNUA2CCgwsAAAO4EL6gAAeNpj2M0gyAACqxgGNWBkZ2D4/wMA+xkDdgAAAHjaY2BgYGaAYBkGRgYQiAHyGMF8FgYHIM3DwMHABGQrMOgyWDLEM1T9/w8UBfEMgLzE////P/5//f/V/xv+r4eaAAeMbAxwIUYmIMHEgKYAYjUcsDAwsLKxc3BycfPw8jEQA/gZBASFhEVExcQlJKWkZWTl5BUUlZRVVNXUNTQZBgMAAMR+E+gAEQFEAAAAKgAqACoANAA+AEgAUgBcAGYAcAB6AIQAjgCYAKIArAC2AMAAygDUAN4A6ADyAPwBBgEQARoBJAEuATgBQgFMAVYBYAFqAXQBfgGIAZIBnAGmAbIBzgHsAAB42u2NMQ6CUAyGW568x9AneYYgm4MJbhKFaExIOAVX8ApewSt4Bic4AfeAid3VOBixDxfPYEza5O+Xfi04YADggiUIULCuEJK8VhO4bSvpdnktHI5QCYtdi2sl8ZnXaHlqUrNKzdKcT8cjlq+rwZSvIVczNiezsfnP/uznmfPFBNODM2K7MTQ45YEAZqGP81AmGGcF3iPqOop0r1SPTaTbVkfUe4HXj97wYE+yNwWYxwWu4v1ugWHgo3S1XdZEVqWM7ET0cfnLGxWfkgR42o2PvWrDMBSFj/IHLaF0zKjRgdiVMwScNRAoWUoH78Y2icB/yIY09An6AH2Bdu/UB+yxopYshQiEvnvu0dURgDt8QeC8PDw7Fpji3fEA4z/PEJ6YOB5hKh4dj3EvXhxPqH/SKUY3rJ7srZ4FZnh1PMAtPhwP6fl2PMJMPDgeQ4rY8YT6Gzao0eAEA409DuggmTnFnOcSCiEiLMgxCiTI6Cq5DZUd3Qmp10vO0LaLTd2cjN4fOumlc7lUYbSQcZFkutRG7g6JKZKy0RmdLY680CDnEJ+UMkpFFe1RN7nxdVpXrC4aTtnaurOnYercZg2YVmLN/d/gczfEimrE/fs/bOuq29Zmn8tloORaXgZgGa78yO9/cnXm2BpaGvq25Dv9S4E9+5SIc9PqupJKhYFSSl47+Qcr1mYNAAAAeNptw0cKwkAAAMDZJA8Q7OUJvkLsPfZ6zFVERPy8qHh2YER+3i/BP83vIBLLySsoKimrqKqpa2hp6+jq6RsYGhmbmJqZSy0sraxtbO3sHRydnEMU4uR6yx7JJXveP7WrDycAAAAAAAH//wACeNpjYGRgYOABYhkgZgJCZgZNBkYGLQZtIJsFLMYAAAw3ALgAeNolizEKgDAQBCchRbC2sFER0YD6qVQiBCv/H9ezGI6Z5XBAw8CBK/m5iQQVauVbXLnOrMZv2oLdKFa8Pjuru2hJzGabmOSLzNMzvutpB3N42mNgZGBg4GKQYzBhYMxJLMlj4GBgAYow/P/PAJJhLM6sSoWKfWCAAwDAjgbRAAB42mNgYGBkAIIbCZo5IPrmUn0hGA0AO8EFTQAA");
            font-weight: 400;
            font-style: normal;
        }

        /* FONT_END */
        :root {
            --swiper-theme-color: #007aff;
            /*
            --swiper-preloader-color: var(--swiper-theme-color);
            --swiper-wrapper-transition-timing-function: initial;
            */
        }

        :host {
            position: relative;
            display: block;
            margin-left: auto;
            margin-right: auto;
            z-index: 1;
        }

        .swiper {
            margin-left: auto;
            margin-right: auto;
            position: relative;
            overflow: hidden;
            overflow: clip;
            list-style: none;
            padding: 0;
            /* Fix of Webkit flickering */
            z-index: 1;
            display: block;
        }

        .swiper-vertical>.swiper-wrapper {
            flex-direction: column;
        }

        .swiper-wrapper {
            position: relative;
            width: 100%;
            height: 100%;
            z-index: 1;
            display: flex;
            transition-property: transform;
            transition-timing-function: var(--swiper-wrapper-transition-timing-function,
                    initial);
            box-sizing: content-box;
        }

        .swiper-android .swiper-slide,
        .swiper-ios .swiper-slide,
        .swiper-wrapper {
            transform: translate3d(0px, 0, 0);
        }

        .swiper-horizontal {
            touch-action: pan-y;
        }

        .swiper-vertical {
            touch-action: pan-x;
        }

        .swiper-slide {
            flex-shrink: 0;
            width: 100%;
            height: 100%;
            position: relative;
            transition-property: transform;
            display: block;
        }

        .swiper-slide-invisible-blank {
            visibility: hidden;
        }

        /* Auto Height */
        .swiper-autoheight,
        .swiper-autoheight .swiper-slide {
            height: auto;
        }

        .swiper-autoheight .swiper-wrapper {
            align-items: flex-start;
            transition-property: transform, height;
        }

        .swiper-backface-hidden .swiper-slide {
            transform: translateZ(0);
            -webkit-backface-visibility: hidden;
            backface-visibility: hidden;
        }

        /* 3D Effects */
        .swiper-3d.swiper-css-mode .swiper-wrapper {
            perspective: 1200px;
        }

        .swiper-3d .swiper-wrapper {
            transform-style: preserve-3d;
        }

        .swiper-3d {
            perspective: 1200px;
        }

        .swiper-3d .swiper-slide,
        .swiper-3d .swiper-cube-shadow {
            transform-style: preserve-3d;
        }

        /* CSS Mode */
        .swiper-css-mode>.swiper-wrapper {
            overflow: auto;
            scrollbar-width: none;
            /* For Firefox */
            -ms-overflow-style: none;
            /* For Internet Explorer and Edge */
        }

        .swiper-css-mode>.swiper-wrapper::-webkit-scrollbar {
            display: none;
        }

        .swiper-css-mode>.swiper-wrapper>.swiper-slide {
            scroll-snap-align: start start;
        }

        .swiper-css-mode.swiper-horizontal>.swiper-wrapper {
            scroll-snap-type: x mandatory;
        }

        .swiper-css-mode.swiper-vertical>.swiper-wrapper {
            scroll-snap-type: y mandatory;
        }

        .swiper-css-mode.swiper-free-mode>.swiper-wrapper {
            scroll-snap-type: none;
        }

        .swiper-css-mode.swiper-free-mode>.swiper-wrapper>.swiper-slide {
            scroll-snap-align: none;
        }

        .swiper-css-mode.swiper-centered>.swiper-wrapper::before {
            content: "";
            flex-shrink: 0;
            order: 9999;
        }

        .swiper-css-mode.swiper-centered>.swiper-wrapper>.swiper-slide {
            scroll-snap-align: center center;
            scroll-snap-stop: always;
        }

        .swiper-css-mode.swiper-centered.swiper-horizontal>.swiper-wrapper>.swiper-slide:first-child {
            margin-inline-start: var(--swiper-centered-offset-before);
        }

        .swiper-css-mode.swiper-centered.swiper-horizontal>.swiper-wrapper::before {
            height: 100%;
            min-height: 1px;
            width: var(--swiper-centered-offset-after);
        }

        .swiper-css-mode.swiper-centered.swiper-vertical>.swiper-wrapper>.swiper-slide:first-child {
            margin-block-start: var(--swiper-centered-offset-before);
        }

        .swiper-css-mode.swiper-centered.swiper-vertical>.swiper-wrapper::before {
            width: 100%;
            min-width: 1px;
            height: var(--swiper-centered-offset-after);
        }

        /* Slide styles start */
        /* 3D Shadows */
        .swiper-3d .swiper-slide-shadow,
        .swiper-3d .swiper-slide-shadow-left,
        .swiper-3d .swiper-slide-shadow-right,
        .swiper-3d .swiper-slide-shadow-top,
        .swiper-3d .swiper-slide-shadow-bottom,
        .swiper-3d .swiper-slide-shadow,
        .swiper-3d .swiper-slide-shadow-left,
        .swiper-3d .swiper-slide-shadow-right,
        .swiper-3d .swiper-slide-shadow-top,
        .swiper-3d .swiper-slide-shadow-bottom {
            position: absolute;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 10;
        }

        .swiper-3d .swiper-slide-shadow {
            background: rgba(0, 0, 0, 0.15);
        }

        .swiper-3d .swiper-slide-shadow-left {
            background-image: linear-gradient(to left,
                    rgba(0, 0, 0, 0.5),
                    rgba(0, 0, 0, 0));
        }

        .swiper-3d .swiper-slide-shadow-right {
            background-image: linear-gradient(to right,
                    rgba(0, 0, 0, 0.5),
                    rgba(0, 0, 0, 0));
        }

        .swiper-3d .swiper-slide-shadow-top {
            background-image: linear-gradient(to top,
                    rgba(0, 0, 0, 0.5),
                    rgba(0, 0, 0, 0));
        }

        .swiper-3d .swiper-slide-shadow-bottom {
            background-image: linear-gradient(to bottom,
                    rgba(0, 0, 0, 0.5),
                    rgba(0, 0, 0, 0));
        }

        .swiper-lazy-preloader {
            width: 42px;
            height: 42px;
            position: absolute;
            left: 50%;
            top: 50%;
            margin-left: -21px;
            margin-top: -21px;
            z-index: 10;
            transform-origin: 50%;
            box-sizing: border-box;
            border: 4px solid var(--swiper-preloader-color, var(--swiper-theme-color));
            border-radius: 50%;
            border-top-color: transparent;
        }

        .swiper:not(.swiper-watch-progress) .swiper-lazy-preloader,
        .swiper-watch-progress .swiper-slide-visible .swiper-lazy-preloader {
            animation: swiper-preloader-spin 1s infinite linear;
        }

        .swiper-lazy-preloader-white {
            --swiper-preloader-color: #fff;
        }

        .swiper-lazy-preloader-black {
            --swiper-preloader-color: #000;
        }

        @keyframes swiper-preloader-spin {
            0% {
                transform: rotate(0deg);
            }

            100% {
                transform: rotate(360deg);
            }
        }

        /* Slide styles end */
        .swiper-virtual .swiper-slide {
            -webkit-backface-visibility: hidden;
            transform: translateZ(0);
        }

        .swiper-virtual.swiper-css-mode .swiper-wrapper::after {
            content: "";
            position: absolute;
            left: 0;
            top: 0;
            pointer-events: none;
        }

        .swiper-virtual.swiper-css-mode.swiper-horizontal .swiper-wrapper::after {
            height: 1px;
            width: var(--swiper-virtual-size);
        }

        .swiper-virtual.swiper-css-mode.swiper-vertical .swiper-wrapper::after {
            width: 1px;
            height: var(--swiper-virtual-size);
        }

        :root {
            --swiper-navigation-size: 44px;
            /*
            --swiper-navigation-top-offset: 50%;
            --swiper-navigation-sides-offset: 10px;
            --swiper-navigation-color: var(--swiper-theme-color);
            */
        }

        .swiper-button-prev,
        .swiper-button-next {
            position: absolute;
            top: var(--swiper-navigation-top-offset, 90%);
            width: calc(var(--swiper-navigation-size) / 44 * 27);
            height: var(--swiper-navigation-size);
            margin-left: 15px;
            margin-right: 15px;
            margin-top: calc(0px - (var(--swiper-navigation-size) / 2));
            z-index: 100;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            color: var(--swiper-navigation-color, var(--swiper-theme-color));
        }

        .swiper-button-prev.swiper-button-disabled,
        .swiper-button-next.swiper-button-disabled {
            opacity: 0.35;
            cursor: auto;
            pointer-events: none;
        }

        .swiper-button-prev.swiper-button-hidden,
        .swiper-button-next.swiper-button-hidden {
            opacity: 0;
            cursor: auto;
            pointer-events: none;
        }

        .swiper-navigation-disabled .swiper-button-prev,
        .swiper-navigation-disabled .swiper-button-next {
            display: none !important;
        }

        .swiper-button-prev svg,
        .swiper-button-next svg {
            width: 100%;
            height: 100%;
            object-fit: contain;
            transform-origin: center;
        }

        .swiper-rtl .swiper-button-prev svg,
        .swiper-rtl .swiper-button-next svg {
            transform: rotate(180deg);
        }

        .swiper-button-prev,
        .swiper-rtl .swiper-button-next {
            left: var(--swiper-navigation-sides-offset, 10px);
            right: auto;
        }

        .swiper-button-next,
        .swiper-rtl .swiper-button-prev {
            right: var(--swiper-navigation-sides-offset, 10px);
            left: auto;
        }

        .swiper-button-lock {
            display: none;
        }

        /* Navigation font start */
        .swiper-button-prev:after,
        .swiper-button-next:after {
            font-family: swiper-icons;
            font-size: var(--swiper-navigation-size);
            text-transform: none !important;
            letter-spacing: 0;
            font-variant: initial;
            line-height: 1;
        }

        .swiper-button-prev:after,
        .swiper-rtl .swiper-button-next:after {
            /* content: 'prev'; */
            content: "";
        }

        .swiper-button-next,
        .swiper-rtl .swiper-button-prev {
            right: var(--swiper-navigation-sides-offset, 10px);
            left: auto;
        }

        .swiper-button-next:after,
        .swiper-rtl .swiper-button-prev:after {
            /* content: 'next'; */
            content: "";
        }

        /* Navigation font end */
        :root {
            /*
            --swiper-pagination-color: var(--swiper-theme-color);
            --swiper-pagination-left: auto;
            --swiper-pagination-right: 8px;
            --swiper-pagination-bottom: 8px;
            --swiper-pagination-top: auto;
            --swiper-pagination-fraction-color: inherit;
            --swiper-pagination-progressbar-bg-color: rgba(0,0,0,0.25);
            --swiper-pagination-progressbar-size: 4px;
            --swiper-pagination-bullet-size: 8px;
            --swiper-pagination-bullet-width: 8px;
            --swiper-pagination-bullet-height: 8px;
            --swiper-pagination-bullet-border-radius: 50%;
            --swiper-pagination-bullet-inactive-color: #000;
            --swiper-pagination-bullet-inactive-opacity: 0.2;
            --swiper-pagination-bullet-opacity: 1;
            --swiper-pagination-bullet-horizontal-gap: 4px;
            --swiper-pagination-bullet-vertical-gap: 6px;
            */
        }

        .swiper-pagination {
            position: absolute;
            text-align: center;
            transition: 300ms opacity;
            transform: translate3d(0, 0, 0);
            z-index: 10;
        }

        .swiper-pagination.swiper-pagination-hidden {
            opacity: 0;
        }

        .swiper-pagination-disabled>.swiper-pagination,
        .swiper-pagination.swiper-pagination-disabled {
            display: none !important;
        }

        /* Common Styles */
        .swiper-pagination-fraction,
        .swiper-pagination-custom,
        .swiper-horizontal>.swiper-pagination-bullets,
        .swiper-pagination-bullets.swiper-pagination-horizontal {
            bottom: var(--swiper-pagination-bottom, 33px);
            top: var(--swiper-pagination-top, auto);
            left: 0;
            width: 100%;
        }

        /* Bullets */
        .swiper-pagination-bullets-dynamic {
            overflow: hidden;
            font-size: 0;
        }

        .swiper-pagination-bullets-dynamic .swiper-pagination-bullet {
            transform: scale(0.33);
            position: relative;
        }

        .swiper-pagination-bullets-dynamic .swiper-pagination-bullet-active {
            transform: scale(1);
        }

        .swiper-pagination-bullets-dynamic .swiper-pagination-bullet-active-main {
            transform: scale(1);
        }

        .swiper-pagination-bullets-dynamic .swiper-pagination-bullet-active-prev {
            transform: scale(0.66);
        }

        .swiper-pagination-bullets-dynamic .swiper-pagination-bullet-active-prev-prev {
            transform: scale(0.33);
        }

        .swiper-pagination-bullets-dynamic .swiper-pagination-bullet-active-next {
            transform: scale(0.66);
        }

        .swiper-pagination-bullets-dynamic .swiper-pagination-bullet-active-next-next {
            transform: scale(0.33);
        }

        .swiper-pagination-bullet {
            width: var(--swiper-pagination-bullet-width,
                    var(--swiper-pagination-bullet-size, 8px));
            height: var(--swiper-pagination-bullet-height,
                    var(--swiper-pagination-bullet-size, 8px));
            display: inline-block;
            border-radius: var(--swiper-pagination-bullet-border-radius, 50%);
            background: var(--swiper-pagination-bullet-inactive-color, #000);
            opacity: var(--swiper-pagination-bullet-inactive-opacity, 0.2);
        }

        button.swiper-pagination-bullet {
            border: none;
            margin: 0;
            padding: 0;
            box-shadow: none;
            -webkit-appearance: none;
            appearance: none;
        }

        .swiper-pagination-clickable .swiper-pagination-bullet {
            cursor: pointer;
        }

        .swiper-pagination-bullet:only-child {
            display: none !important;
        }

        .swiper-pagination-bullet-active {
            opacity: var(--swiper-pagination-bullet-opacity, 1);
            background: var(--swiper-pagination-color, var(--swiper-theme-color));
        }

        .swiper-vertical>.swiper-pagination-bullets,
        .swiper-pagination-vertical.swiper-pagination-bullets {
            right: var(--swiper-pagination-right, 8px);
            left: var(--swiper-pagination-left, auto);
            top: 50%;
            transform: translate3d(0px, -50%, 0);
        }

        .swiper-vertical>.swiper-pagination-bullets .swiper-pagination-bullet,
        .swiper-pagination-vertical.swiper-pagination-bullets .swiper-pagination-bullet {
            margin: var(--swiper-pagination-bullet-vertical-gap, 6px) 0;
            display: block;
        }

        .swiper-vertical>.swiper-pagination-bullets.swiper-pagination-bullets-dynamic,
        .swiper-pagination-vertical.swiper-pagination-bullets.swiper-pagination-bullets-dynamic {
            top: 50%;
            transform: translateY(-50%);
            width: 8px;
        }

        .swiper-vertical>.swiper-pagination-bullets.swiper-pagination-bullets-dynamic .swiper-pagination-bullet,
        .swiper-pagination-vertical.swiper-pagination-bullets.swiper-pagination-bullets-dynamic .swiper-pagination-bullet {
            display: inline-block;
            transition: 200ms transform, 200ms top;
        }

        .swiper-horizontal>.swiper-pagination-bullets .swiper-pagination-bullet,
        .swiper-pagination-horizontal.swiper-pagination-bullets .swiper-pagination-bullet {
            margin: 0 var(--swiper-pagination-bullet-horizontal-gap, 4px);
        }

        .swiper-horizontal>.swiper-pagination-bullets.swiper-pagination-bullets-dynamic,
        .swiper-pagination-horizontal.swiper-pagination-bullets.swiper-pagination-bullets-dynamic {
            left: 50%;
            transform: translateX(-50%);
            white-space: nowrap;
        }

        .swiper-horizontal>.swiper-pagination-bullets.swiper-pagination-bullets-dynamic .swiper-pagination-bullet,
        .swiper-pagination-horizontal.swiper-pagination-bullets.swiper-pagination-bullets-dynamic .swiper-pagination-bullet {
            transition: 200ms transform, 200ms left;
        }

        .swiper-horizontal.swiper-rtl>.swiper-pagination-bullets-dynamic .swiper-pagination-bullet {
            transition: 200ms transform, 200ms right;
        }

        /* Fraction */
        .swiper-pagination-fraction {
            color: var(--swiper-pagination-fraction-color, inherit);
        }

        /* Progress */
        .swiper-pagination-progressbar {
            background: var(--swiper-pagination-progressbar-bg-color,
                    rgba(0, 0, 0, 0.25));
            position: absolute;
        }

        .swiper-pagination-progressbar .swiper-pagination-progressbar-fill {
            background: var(--swiper-pagination-color, var(--swiper-theme-color));
            position: absolute;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            transform: scale(0);
            transform-origin: left top;
        }

        .swiper-rtl .swiper-pagination-progressbar .swiper-pagination-progressbar-fill {
            transform-origin: right top;
        }

        .swiper-horizontal>.swiper-pagination-progressbar,
        .swiper-pagination-progressbar.swiper-pagination-horizontal,
        .swiper-vertical>.swiper-pagination-progressbar.swiper-pagination-progressbar-opposite,
        .swiper-pagination-progressbar.swiper-pagination-vertical.swiper-pagination-progressbar-opposite {
            width: 100%;
            height: var(--swiper-pagination-progressbar-size, 4px);
            left: 0;
            top: 0;
        }

        .swiper-vertical>.swiper-pagination-progressbar,
        .swiper-pagination-progressbar.swiper-pagination-vertical,
        .swiper-horizontal>.swiper-pagination-progressbar.swiper-pagination-progressbar-opposite,
        .swiper-pagination-progressbar.swiper-pagination-horizontal.swiper-pagination-progressbar-opposite {
            width: var(--swiper-pagination-progressbar-size, 4px);
            height: 100%;
            left: 0;
            top: 0;
        }

        .swiper-pagination-lock {
            display: none;
        }

        :root {
            /*
            --swiper-scrollbar-border-radius: 10px;
            --swiper-scrollbar-top: auto;
            --swiper-scrollbar-bottom: 4px;
            --swiper-scrollbar-left: auto;
            --swiper-scrollbar-right: 4px;
            --swiper-scrollbar-sides-offset: 1%;
            --swiper-scrollbar-bg-color: rgba(0, 0, 0, 0.1);
            --swiper-scrollbar-drag-bg-color: rgba(0, 0, 0, 0.5);
            --swiper-scrollbar-size: 4px;
            */
        }

        .swiper-scrollbar {
            border-radius: var(--swiper-scrollbar-border-radius, 10px);
            position: relative;
            -ms-touch-action: none;
            background: var(--swiper-scrollbar-bg-color, rgba(0, 0, 0, 0.1));
        }

        .swiper-scrollbar-disabled>.swiper-scrollbar,
        .swiper-scrollbar.swiper-scrollbar-disabled {
            display: none !important;
        }

        .swiper-horizontal>.swiper-scrollbar,
        .swiper-scrollbar.swiper-scrollbar-horizontal {
            position: absolute;
            left: var(--swiper-scrollbar-sides-offset, 1%);
            bottom: var(--swiper-scrollbar-bottom, 4px);
            top: var(--swiper-scrollbar-top, auto);
            z-index: 50;
            height: var(--swiper-scrollbar-size, 4px);
            width: calc(100% - 2 * var(--swiper-scrollbar-sides-offset, 1%));
        }

        .swiper-vertical>.swiper-scrollbar,
        .swiper-scrollbar.swiper-scrollbar-vertical {
            position: absolute;
            left: var(--swiper-scrollbar-left, auto);
            right: var(--swiper-scrollbar-right, 4px);
            top: var(--swiper-scrollbar-sides-offset, 1%);
            z-index: 50;
            width: var(--swiper-scrollbar-size, 4px);
            height: calc(100% - 2 * var(--swiper-scrollbar-sides-offset, 1%));
        }

        .swiper-scrollbar-drag {
            height: 100%;
            width: 100%;
            position: relative;
            background: var(--swiper-scrollbar-drag-bg-color, rgba(0, 0, 0, 0.5));
            border-radius: var(--swiper-scrollbar-border-radius, 10px);
            left: 0;
            top: 0;
        }

        .swiper-scrollbar-cursor-drag {
            cursor: move;
        }

        .swiper-scrollbar-lock {
            display: none;
        }

        .swiper-zoom-container {
            width: 100%;
            height: 100%;
            display: flex;
            justify-content: center;
            align-items: center;
            text-align: center;
        }

        .swiper-zoom-container>img,
        .swiper-zoom-container>svg,
        .swiper-zoom-container>canvas {
            max-width: 100%;
            max-height: 100%;
            object-fit: contain;
        }

        .swiper-slide-zoomed {
            cursor: move;
            touch-action: none;
        }

        /* a11y */
        .swiper .swiper-notification {
            position: absolute;
            left: 0;
            top: 0;
            pointer-events: none;
            opacity: 0;
            z-index: -1000;
        }

        .swiper-free-mode>.swiper-wrapper {
            transition-timing-function: ease-out;
            margin: 0 auto;
        }

        .swiper-grid>.swiper-wrapper {
            flex-wrap: wrap;
        }

        .swiper-grid-column>.swiper-wrapper {
            flex-wrap: wrap;
            flex-direction: column;
        }

        .swiper-fade.swiper-free-mode .swiper-slide {
            transition-timing-function: ease-out;
        }

        .swiper-fade .swiper-slide {
            pointer-events: none;
            transition-property: opacity;
        }

        .swiper-fade .swiper-slide .swiper-slide {
            pointer-events: none;
        }

        .swiper-fade .swiper-slide-active,
        .swiper-fade .swiper-slide-active .swiper-slide-active {
            pointer-events: auto;
        }

        .swiper-cube {
            overflow: visible;
        }

        .swiper-cube .swiper-slide {
            pointer-events: none;
            -webkit-backface-visibility: hidden;
            backface-visibility: hidden;
            z-index: 1;
            visibility: hidden;
            transform-origin: 0 0;
            width: 100%;
            height: 100%;
        }

        .swiper-cube .swiper-slide .swiper-slide {
            pointer-events: none;
        }

        .swiper-cube.swiper-rtl .swiper-slide {
            transform-origin: 100% 0;
        }

        .swiper-cube .swiper-slide-active,
        .swiper-cube .swiper-slide-active .swiper-slide-active {
            pointer-events: auto;
        }

        .swiper-cube .swiper-slide-active,
        .swiper-cube .swiper-slide-next,
        .swiper-cube .swiper-slide-prev {
            pointer-events: auto;
            visibility: visible;
        }

        .swiper-cube .swiper-cube-shadow {
            position: absolute;
            left: 0;
            bottom: 0px;
            width: 100%;
            height: 100%;
            opacity: 0.6;
            z-index: 0;
        }

        .swiper-cube .swiper-cube-shadow:before {
            content: "";
            background: #000;
            position: absolute;
            left: 0;
            top: 0;
            bottom: 0;
            right: 0;
            filter: blur(50px);
        }

        .swiper-cube .swiper-slide-next+.swiper-slide {
            pointer-events: auto;
            visibility: visible;
        }

        /* Cube slide shadows start */
        .swiper-cube .swiper-slide-shadow-cube.swiper-slide-shadow-top,
        .swiper-cube .swiper-slide-shadow-cube.swiper-slide-shadow-bottom,
        .swiper-cube .swiper-slide-shadow-cube.swiper-slide-shadow-left,
        .swiper-cube .swiper-slide-shadow-cube.swiper-slide-shadow-right {
            z-index: 0;
            -webkit-backface-visibility: hidden;
            backface-visibility: hidden;
        }

        /* Cube slide shadows end */
        .swiper-flip {
            overflow: visible;
        }

        .swiper-flip .swiper-slide {
            pointer-events: none;
            -webkit-backface-visibility: hidden;
            backface-visibility: hidden;
            z-index: 1;
        }

        .swiper-flip .swiper-slide .swiper-slide {
            pointer-events: none;
        }

        .swiper-flip .swiper-slide-active,
        .swiper-flip .swiper-slide-active .swiper-slide-active {
            pointer-events: auto;
        }

        /* Flip slide shadows start */
        .swiper-flip .swiper-slide-shadow-flip.swiper-slide-shadow-top,
        .swiper-flip .swiper-slide-shadow-flip.swiper-slide-shadow-bottom,
        .swiper-flip .swiper-slide-shadow-flip.swiper-slide-shadow-left,
        .swiper-flip .swiper-slide-shadow-flip.swiper-slide-shadow-right {
            z-index: 0;
            -webkit-backface-visibility: hidden;
            backface-visibility: hidden;
        }

        /* Flip slide shadows end */
        .swiper-creative .swiper-slide {
            -webkit-backface-visibility: hidden;
            backface-visibility: hidden;
            overflow: hidden;
            transition-property: transform, opacity, height;
        }

        .swiper-cards {
            overflow: visible;
        }

        .swiper-cards .swiper-slide {
            transform-origin: center bottom;
            -webkit-backface-visibility: hidden;
            backface-visibility: hidden;
            overflow: hidden;
        }

        /*!
                * Font Awesome Free 6.0.0-beta3 by @fontawesome - https://fontawesome.com
                * License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License)
                * Copyright 2021 Fonticons, Inc.
                */
        .fa {
            font-family: var(--fa-style-family, "Font Awesome 6 Free");
            font-weight: var(--fa-style, 900);
        }

        .fa,
        .fas,
        .fa-solid,
        .far,
        .fa-regular,
        .fal,
        .fa-light,
        .fat,
        .fa-thin,
        .fad,
        .fa-duotone,
        .fab,
        .fa-brands {
            -moz-osx-font-smoothing: grayscale;
            -webkit-font-smoothing: antialiased;
            display: var(--fa-display, inline-block);
            font-style: normal;
            font-variant: normal;
            line-height: 1;
            text-rendering: auto;
        }

        .fa-1x {
            font-size: 1em;
        }

        .fa-2x {
            font-size: 2em;
        }

        .fa-3x {
            font-size: 3em;
        }

        .fa-4x {
            font-size: 4em;
        }

        .fa-5x {
            font-size: 5em;
        }

        .fa-6x {
            font-size: 6em;
        }

        .fa-7x {
            font-size: 7em;
        }

        .fa-8x {
            font-size: 8em;
        }

        .fa-9x {
            font-size: 9em;
        }

        .fa-10x {
            font-size: 10em;
        }

        .fa-2xs {
            font-size: 0.625em;
            line-height: 0.1em;
            vertical-align: 0.225em;
        }

        .fa-xs {
            font-size: 0.75em;
            line-height: 0.08333em;
            vertical-align: 0.125em;
        }

        .fa-sm {
            font-size: 0.875em;
            line-height: 0.07143em;
            vertical-align: 0.05357em;
        }

        .fa-lg {
            font-size: 1.25em;
            line-height: 0.05em;
            vertical-align: -0.075em;
        }

        .fa-xl {
            font-size: 1.5em;
            line-height: 0.04167em;
            vertical-align: -0.125em;
        }

        .fa-2xl {
            font-size: 2em;
            line-height: 0.03125em;
            vertical-align: -0.1875em;
        }

        .fa-fw {
            text-align: center;
            width: 1.25em;
        }

        .fa-ul {
            list-style-type: none;
            margin-left: var(--fa-li-margin, 2.5em);
            padding-left: 0;
        }

        .fa-ul>li {
            position: relative;
        }

        .fa-li {
            left: calc(var(--fa-li-width, 2em) * -1);
            position: absolute;
            text-align: center;
            width: var(--fa-li-width, 2em);
            line-height: inherit;
        }

        .fa-border {
            border-color: var(--fa-border-color, #eee);
            border-radius: var(--fa-border-radius, 0.1em);
            border-style: var(--fa-border-style, solid);
            border-width: var(--fa-border-width, 0.08em);
            padding: var(--fa-border-padding, 0.2em 0.25em 0.15em);
        }

        .fa-pull-left {
            float: left;
            margin-right: var(--fa-pull-margin, 0.3em);
        }

        .fa-pull-right {
            float: right;
            margin-left: var(--fa-pull-margin, 0.3em);
        }

        .fa-beat {
            -webkit-animation-name: fa-beat;
            animation-name: fa-beat;
            -webkit-animation-delay: var(--fa-animation-delay, 0);
            animation-delay: var(--fa-animation-delay, 0);
            -webkit-animation-direction: var(--fa-animation-direction, normal);
            animation-direction: var(--fa-animation-direction, normal);
            -webkit-animation-duration: var(--fa-animation-duration, 1s);
            animation-duration: var(--fa-animation-duration, 1s);
            -webkit-animation-iteration-count: var(--fa-animation-iteration-count,
                    infinite);
            animation-iteration-count: var(--fa-animation-iteration-count,
                    infinite);
            -webkit-animation-timing-function: var(--fa-animation-timing,
                    ease-in-out);
            animation-timing-function: var(--fa-animation-timing, ease-in-out);
        }

        .fa-fade {
            -webkit-animation-name: fa-fade;
            animation-name: fa-fade;
            -webkit-animation-delay: var(--fa-animation-delay, 0);
            animation-delay: var(--fa-animation-delay, 0);
            -webkit-animation-direction: var(--fa-animation-direction, normal);
            animation-direction: var(--fa-animation-direction, normal);
            -webkit-animation-duration: var(--fa-animation-duration, 1s);
            animation-duration: var(--fa-animation-duration, 1s);
            -webkit-animation-iteration-count: var(--fa-animation-iteration-count,
                    infinite);
            animation-iteration-count: var(--fa-animation-iteration-count,
                    infinite);
            -webkit-animation-timing-function: var(--fa-animation-timing,
                    cubic-bezier(0.4, 0, 0.6, 1));
            animation-timing-function: var(--fa-animation-timing,
                    cubic-bezier(0.4, 0, 0.6, 1));
        }

        .fa-beat-fade {
            -webkit-animation-name: fa-beat-fade;
            animation-name: fa-beat-fade;
            -webkit-animation-delay: var(--fa-animation-delay, 0);
            animation-delay: var(--fa-animation-delay, 0);
            -webkit-animation-direction: var(--fa-animation-direction, normal);
            animation-direction: var(--fa-animation-direction, normal);
            -webkit-animation-duration: var(--fa-animation-duration, 1s);
            animation-duration: var(--fa-animation-duration, 1s);
            -webkit-animation-iteration-count: var(--fa-animation-iteration-count,
                    infinite);
            animation-iteration-count: var(--fa-animation-iteration-count,
                    infinite);
            -webkit-animation-timing-function: var(--fa-animation-timing,
                    cubic-bezier(0.4, 0, 0.6, 1));
            animation-timing-function: var(--fa-animation-timing,
                    cubic-bezier(0.4, 0, 0.6, 1));
        }

        .fa-flip {
            -webkit-animation-name: fa-flip;
            animation-name: fa-flip;
            -webkit-animation-delay: var(--fa-animation-delay, 0);
            animation-delay: var(--fa-animation-delay, 0);
            -webkit-animation-direction: var(--fa-animation-direction, normal);
            animation-direction: var(--fa-animation-direction, normal);
            -webkit-animation-duration: var(--fa-animation-duration, 1s);
            animation-duration: var(--fa-animation-duration, 1s);
            -webkit-animation-iteration-count: var(--fa-animation-iteration-count,
                    infinite);
            animation-iteration-count: var(--fa-animation-iteration-count,
                    infinite);
            -webkit-animation-timing-function: var(--fa-animation-timing,
                    ease-in-out);
            animation-timing-function: var(--fa-animation-timing, ease-in-out);
        }

        .fa-spin {
            -webkit-animation-name: fa-spin;
            animation-name: fa-spin;
            -webkit-animation-delay: var(--fa-animation-delay, 0);
            animation-delay: var(--fa-animation-delay, 0);
            -webkit-animation-direction: var(--fa-animation-direction, normal);
            animation-direction: var(--fa-animation-direction, normal);
            -webkit-animation-duration: var(--fa-animation-duration, 2s);
            animation-duration: var(--fa-animation-duration, 2s);
            -webkit-animation-iteration-count: var(--fa-animation-iteration-count,
                    infinite);
            animation-iteration-count: var(--fa-animation-iteration-count,
                    infinite);
            -webkit-animation-timing-function: var(--fa-animation-timing, linear);
            animation-timing-function: var(--fa-animation-timing, linear);
        }

        .fa-spin-reverse {
            --fa-animation-direction: reverse;
        }

        .fa-pulse,
        .fa-spin-pulse {
            -webkit-animation-name: fa-spin;
            animation-name: fa-spin;
            -webkit-animation-direction: var(--fa-animation-direction, normal);
            animation-direction: var(--fa-animation-direction, normal);
            -webkit-animation-duration: var(--fa-animation-duration, 1s);
            animation-duration: var(--fa-animation-duration, 1s);
            -webkit-animation-iteration-count: var(--fa-animation-iteration-count,
                    infinite);
            animation-iteration-count: var(--fa-animation-iteration-count,
                    infinite);
            -webkit-animation-timing-function: var(--fa-animation-timing, steps(8));
            animation-timing-function: var(--fa-animation-timing, steps(8));
        }

        @media (prefers-reduced-motion: reduce) {

            .fa-beat,
            .fa-fade,
            .fa-beat-fade,
            .fa-flip,
            .fa-pulse,
            .fa-spin,
            .fa-spin-pulse {
                -webkit-animation-delay: -1ms;
                animation-delay: -1ms;
                -webkit-animation-duration: 1ms;
                animation-duration: 1ms;
                -webkit-animation-iteration-count: 1;
                animation-iteration-count: 1;
                -webkit-transition-delay: 0s;
                transition-delay: 0s;
                -webkit-transition-duration: 0s;
                transition-duration: 0s;
            }
        }

        @-webkit-keyframes fa-beat {

            0%,
            90% {
                -webkit-transform: scale(1);
                transform: scale(1);
            }

            45% {
                -webkit-transform: scale(var(--fa-beat-scale, 1.25));
                transform: scale(var(--fa-beat-scale, 1.25));
            }
        }

        @keyframes fa-beat {

            0%,
            90% {
                -webkit-transform: scale(1);
                transform: scale(1);
            }

            45% {
                -webkit-transform: scale(var(--fa-beat-scale, 1.25));
                transform: scale(var(--fa-beat-scale, 1.25));
            }
        }

        @-webkit-keyframes fa-fade {
            50% {
                opacity: var(--fa-fade-opacity, 0.4);
            }
        }

        @keyframes fa-fade {
            50% {
                opacity: var(--fa-fade-opacity, 0.4);
            }
        }

        @-webkit-keyframes fa-beat-fade {

            0%,
            100% {
                opacity: var(--fa-beat-fade-opacity, 0.4);
                -webkit-transform: scale(1);
                transform: scale(1);
            }

            50% {
                opacity: 1;
                -webkit-transform: scale(var(--fa-beat-fade-scale, 1.125));
                transform: scale(var(--fa-beat-fade-scale, 1.125));
            }
        }

        @keyframes fa-beat-fade {

            0%,
            100% {
                opacity: var(--fa-beat-fade-opacity, 0.4);
                -webkit-transform: scale(1);
                transform: scale(1);
            }

            50% {
                opacity: 1;
                -webkit-transform: scale(var(--fa-beat-fade-scale, 1.125));
                transform: scale(var(--fa-beat-fade-scale, 1.125));
            }
        }

        @-webkit-keyframes fa-flip {
            50% {
                -webkit-transform: rotate3d(var(--fa-flip-x, 0),
                        var(--fa-flip-y, 1),
                        var(--fa-flip-z, 0),
                        var(--fa-flip-angle, -180deg));
                transform: rotate3d(var(--fa-flip-x, 0),
                        var(--fa-flip-y, 1),
                        var(--fa-flip-z, 0),
                        var(--fa-flip-angle, -180deg));
            }
        }

        @keyframes fa-flip {
            50% {
                -webkit-transform: rotate3d(var(--fa-flip-x, 0),
                        var(--fa-flip-y, 1),
                        var(--fa-flip-z, 0),
                        var(--fa-flip-angle, -180deg));
                transform: rotate3d(var(--fa-flip-x, 0),
                        var(--fa-flip-y, 1),
                        var(--fa-flip-z, 0),
                        var(--fa-flip-angle, -180deg));
            }
        }

        @-webkit-keyframes fa-spin {
            0% {
                -webkit-transform: rotate(0deg);
                transform: rotate(0deg);
            }

            100% {
                -webkit-transform: rotate(360deg);
                transform: rotate(360deg);
            }
        }

        @keyframes fa-spin {
            0% {
                -webkit-transform: rotate(0deg);
                transform: rotate(0deg);
            }

            100% {
                -webkit-transform: rotate(360deg);
                transform: rotate(360deg);
            }
        }

        .fa-rotate-90 {
            -webkit-transform: rotate(90deg);
            transform: rotate(90deg);
        }

        .fa-rotate-180 {
            -webkit-transform: rotate(180deg);
            transform: rotate(180deg);
        }

        .fa-rotate-270 {
            -webkit-transform: rotate(270deg);
            transform: rotate(270deg);
        }

        .fa-flip-horizontal {
            -webkit-transform: scale(-1, 1);
            transform: scale(-1, 1);
        }

        .fa-flip-vertical {
            -webkit-transform: scale(1, -1);
            transform: scale(1, -1);
        }

        .fa-flip-both,
        .fa-flip-horizontal.fa-flip-vertical {
            -webkit-transform: scale(-1, -1);
            transform: scale(-1, -1);
        }

        .fa-rotate-by {
            -webkit-transform: rotate(var(--fa-rotate-angle, none));
            transform: rotate(var(--fa-rotate-angle, none));
        }

        .fa-stack {
            display: inline-block;
            height: 2em;
            line-height: 2em;
            position: relative;
            vertical-align: middle;
            width: 2.5em;
        }

        .fa-stack-1x,
        .fa-stack-2x {
            left: 0;
            position: absolute;
            text-align: center;
            width: 100%;
            z-index: var(--fa-stack-z-index, auto);
        }

        .fa-stack-1x {
            line-height: inherit;
        }

        .fa-stack-2x {
            font-size: 2em;
        }

        .fa-inverse {
            color: var(--fa-inverse, #fff);
        }

        /* Font Awesome uses the Unicode Private Use Area (PUA) to ensure screen
            readers do not read off random characters that represent icons */
        .fa-0::before {
            content: "\30";
        }

        .fa-1::before {
            content: "\31";
        }

        .fa-2::before {
            content: "\32";
        }

        .fa-3::before {
            content: "\33";
        }

        .fa-4::before {
            content: "\34";
        }

        .fa-5::before {
            content: "\35";
        }

        .fa-6::before {
            content: "\36";
        }

        .fa-7::before {
            content: "\37";
        }

        .fa-8::before {
            content: "\38";
        }

        .fa-9::before {
            content: "\39";
        }

        .fa-a::before {
            content: "\41";
        }

        .fa-address-book::before {
            content: "\f2b9";
        }

        .fa-contact-book::before {
            content: "\f2b9";
        }

        .fa-address-card::before {
            content: "\f2bb";
        }

        .fa-contact-card::before {
            content: "\f2bb";
        }

        .fa-vcard::before {
            content: "\f2bb";
        }

        .fa-align-center::before {
            content: "\f037";
        }

        .fa-align-justify::before {
            content: "\f039";
        }

        .fa-align-left::before {
            content: "\f036";
        }

        .fa-align-right::before {
            content: "\f038";
        }

        .fa-anchor::before {
            content: "\f13d";
        }

        .fa-angle-down::before {
            content: "\f107";
        }

        .fa-angle-left::before {
            content: "\f104";
        }

        .fa-angle-right::before {
            content: "\f105";
        }

        .fa-angle-up::before {
            content: "\f106";
        }

        .fa-angles-down::before {
            content: "\f103";
        }

        .fa-angle-double-down::before {
            content: "\f103";
        }

        .fa-angles-left::before {
            content: "\f100";
        }

        .fa-angle-double-left::before {
            content: "\f100";
        }

        .fa-angles-right::before {
            content: "\f101";
        }

        .fa-angle-double-right::before {
            content: "\f101";
        }

        .fa-angles-up::before {
            content: "\f102";
        }

        .fa-angle-double-up::before {
            content: "\f102";
        }

        .fa-ankh::before {
            content: "\f644";
        }

        .fa-apple-whole::before {
            content: "\f5d1";
        }

        .fa-apple-alt::before {
            content: "\f5d1";
        }

        .fa-archway::before {
            content: "\f557";
        }

        .fa-arrow-down::before {
            content: "\f063";
        }

        .fa-arrow-down-1-9::before {
            content: "\f162";
        }

        .fa-sort-numeric-asc::before {
            content: "\f162";
        }

        .fa-sort-numeric-down::before {
            content: "\f162";
        }

        .fa-arrow-down-9-1::before {
            content: "\f886";
        }

        .fa-sort-numeric-desc::before {
            content: "\f886";
        }

        .fa-sort-numeric-down-alt::before {
            content: "\f886";
        }

        .fa-arrow-down-a-z::before {
            content: "\f15d";
        }

        .fa-sort-alpha-asc::before {
            content: "\f15d";
        }

        .fa-sort-alpha-down::before {
            content: "\f15d";
        }

        .fa-arrow-down-long::before {
            content: "\f175";
        }

        .fa-long-arrow-down::before {
            content: "\f175";
        }

        .fa-arrow-down-short-wide::before {
            content: "\f884";
        }

        .fa-sort-amount-desc::before {
            content: "\f884";
        }

        .fa-sort-amount-down-alt::before {
            content: "\f884";
        }

        .fa-arrow-down-wide-short::before {
            content: "\f160";
        }

        .fa-sort-amount-asc::before {
            content: "\f160";
        }

        .fa-sort-amount-down::before {
            content: "\f160";
        }

        .fa-arrow-down-z-a::before {
            content: "\f881";
        }

        .fa-sort-alpha-desc::before {
            content: "\f881";
        }

        .fa-sort-alpha-down-alt::before {
            content: "\f881";
        }

        .fa-arrow-left::before {
            content: "\f060";
        }

        .fa-arrow-left-long::before {
            content: "\f177";
        }

        .fa-long-arrow-left::before {
            content: "\f177";
        }

        .fa-arrow-pointer::before {
            content: "\f245";
        }

        .fa-mouse-pointer::before {
            content: "\f245";
        }

        .fa-arrow-right::before {
            content: "\f061";
        }

        .fa-arrow-right-arrow-left::before {
            content: "\f0ec";
        }

        .fa-exchange::before {
            content: "\f0ec";
        }

        .fa-arrow-right-from-bracket::before {
            content: "\f08b";
        }

        .fa-sign-out::before {
            content: "\f08b";
        }

        .fa-arrow-right-long::before {
            content: "\f178";
        }

        .fa-long-arrow-right::before {
            content: "\f178";
        }

        .fa-arrow-right-to-bracket::before {
            content: "\f090";
        }

        .fa-sign-in::before {
            content: "\f090";
        }

        .fa-arrow-rotate-left::before {
            content: "\f0e2";
        }

        .fa-arrow-left-rotate::before {
            content: "\f0e2";
        }

        .fa-arrow-rotate-back::before {
            content: "\f0e2";
        }

        .fa-arrow-rotate-backward::before {
            content: "\f0e2";
        }

        .fa-undo::before {
            content: "\f0e2";
        }

        .fa-arrow-rotate-right::before {
            content: "\f01e";
        }

        .fa-arrow-right-rotate::before {
            content: "\f01e";
        }

        .fa-arrow-rotate-forward::before {
            content: "\f01e";
        }

        .fa-redo::before {
            content: "\f01e";
        }

        .fa-arrow-trend-down::before {
            content: "\e097";
        }

        .fa-arrow-trend-up::before {
            content: "\e098";
        }

        .fa-arrow-turn-down::before {
            content: "\f149";
        }

        .fa-level-down::before {
            content: "\f149";
        }

        .fa-arrow-turn-up::before {
            content: "\f148";
        }

        .fa-level-up::before {
            content: "\f148";
        }

        .fa-arrow-up::before {
            content: "\f062";
        }

        .fa-arrow-up-1-9::before {
            content: "\f163";
        }

        .fa-sort-numeric-up::before {
            content: "\f163";
        }

        .fa-arrow-up-9-1::before {
            content: "\f887";
        }

        .fa-sort-numeric-up-alt::before {
            content: "\f887";
        }

        .fa-arrow-up-a-z::before {
            content: "\f15e";
        }

        .fa-sort-alpha-up::before {
            content: "\f15e";
        }

        .fa-arrow-up-from-bracket::before {
            content: "\e09a";
        }

        .fa-arrow-up-long::before {
            content: "\f176";
        }

        .fa-long-arrow-up::before {
            content: "\f176";
        }

        .fa-arrow-up-right-from-square::before {
            content: "\f08e";
        }

        .fa-external-link::before {
            content: "\f08e";
        }

        .fa-arrow-up-short-wide::before {
            content: "\f885";
        }

        .fa-sort-amount-up-alt::before {
            content: "\f885";
        }

        .fa-arrow-up-wide-short::before {
            content: "\f161";
        }

        .fa-sort-amount-up::before {
            content: "\f161";
        }

        .fa-arrow-up-z-a::before {
            content: "\f882";
        }

        .fa-sort-alpha-up-alt::before {
            content: "\f882";
        }

        .fa-arrows-left-right::before {
            content: "\f07e";
        }

        .fa-arrows-h::before {
            content: "\f07e";
        }

        .fa-arrows-rotate::before {
            content: "\f021";
        }

        .fa-refresh::before {
            content: "\f021";
        }

        .fa-sync::before {
            content: "\f021";
        }

        .fa-arrows-up-down::before {
            content: "\f07d";
        }

        .fa-arrows-v::before {
            content: "\f07d";
        }

        .fa-arrows-up-down-left-right::before {
            content: "\f047";
        }

        .fa-arrows::before {
            content: "\f047";
        }

        .fa-asterisk::before {
            content: "\2a";
        }

        .fa-at::before {
            content: "\40";
        }

        .fa-atom::before {
            content: "\f5d2";
        }

        .fa-audio-description::before {
            content: "\f29e";
        }

        .fa-austral-sign::before {
            content: "\e0a9";
        }

        .fa-award::before {
            content: "\f559";
        }

        .fa-b::before {
            content: "\42";
        }

        .fa-baby::before {
            content: "\f77c";
        }

        .fa-baby-carriage::before {
            content: "\f77d";
        }

        .fa-carriage-baby::before {
            content: "\f77d";
        }

        .fa-backward::before {
            content: "\f04a";
        }

        .fa-backward-fast::before {
            content: "\f049";
        }

        .fa-fast-backward::before {
            content: "\f049";
        }

        .fa-backward-step::before {
            content: "\f048";
        }

        .fa-step-backward::before {
            content: "\f048";
        }

        .fa-bacon::before {
            content: "\f7e5";
        }

        .fa-bacteria::before {
            content: "\e059";
        }

        .fa-bacterium::before {
            content: "\e05a";
        }

        .fa-bag-shopping::before {
            content: "\f290";
        }

        .fa-shopping-bag::before {
            content: "\f290";
        }

        .fa-bahai::before {
            content: "\f666";
        }

        .fa-baht-sign::before {
            content: "\e0ac";
        }

        .fa-ban::before {
            content: "\f05e";
        }

        .fa-cancel::before {
            content: "\f05e";
        }

        .fa-ban-smoking::before {
            content: "\f54d";
        }

        .fa-smoking-ban::before {
            content: "\f54d";
        }

        .fa-bandage::before {
            content: "\f462";
        }

        .fa-band-aid::before {
            content: "\f462";
        }

        .fa-bank::before {
            content: "\f19c";
        }

        .fa-institution::before {
            content: "\f19c";
        }

        .fa-university::before {
            content: "\f19c";
        }

        .fa-barcode::before {
            content: "\f02a";
        }

        .fa-bars::before {
            content: "\f0c9";
        }

        .fa-navicon::before {
            content: "\f0c9";
        }

        .fa-bars-progress::before {
            content: "\f828";
        }

        .fa-tasks-alt::before {
            content: "\f828";
        }

        .fa-bars-staggered::before {
            content: "\f550";
        }

        .fa-reorder::before {
            content: "\f550";
        }

        .fa-stream::before {
            content: "\f550";
        }

        .fa-baseball::before {
            content: "\f433";
        }

        .fa-baseball-ball::before {
            content: "\f433";
        }

        .fa-basket-shopping::before {
            content: "\f291";
        }

        .fa-shopping-basket::before {
            content: "\f291";
        }

        .fa-basketball::before {
            content: "\f434";
        }

        .fa-basketball-ball::before {
            content: "\f434";
        }

        .fa-bath::before {
            content: "\f2cd";
        }

        .fa-bathtub::before {
            content: "\f2cd";
        }

        .fa-battery-empty::before {
            content: "\f244";
        }

        .fa-battery-0::before {
            content: "\f244";
        }

        .fa-battery-full::before {
            content: "\f240";
        }

        .fa-battery::before {
            content: "\f240";
        }

        .fa-battery-5::before {
            content: "\f240";
        }

        .fa-battery-half::before {
            content: "\f242";
        }

        .fa-battery-3::before {
            content: "\f242";
        }

        .fa-battery-quarter::before {
            content: "\f243";
        }

        .fa-battery-2::before {
            content: "\f243";
        }

        .fa-battery-three-quarters::before {
            content: "\f241";
        }

        .fa-battery-4::before {
            content: "\f241";
        }

        .fa-bed::before {
            content: "\f236";
        }

        .fa-bed-pulse::before {
            content: "\f487";
        }

        .fa-procedures::before {
            content: "\f487";
        }

        .fa-beer-mug-empty::before {
            content: "\f0fc";
        }

        .fa-beer::before {
            content: "\f0fc";
        }

        .fa-bell::before {
            content: "\f0f3";
        }

        .fa-bell-concierge::before {
            content: "\f562";
        }

        .fa-concierge-bell::before {
            content: "\f562";
        }

        .fa-bell-slash::before {
            content: "\f1f6";
        }

        .fa-bezier-curve::before {
            content: "\f55b";
        }

        .fa-bicycle::before {
            content: "\f206";
        }

        .fa-binoculars::before {
            content: "\f1e5";
        }

        .fa-biohazard::before {
            content: "\f780";
        }

        .fa-bitcoin-sign::before {
            content: "\e0b4";
        }

        .fa-blender::before {
            content: "\f517";
        }

        .fa-blender-phone::before {
            content: "\f6b6";
        }

        .fa-blog::before {
            content: "\f781";
        }

        .fa-bold::before {
            content: "\f032";
        }

        .fa-bolt::before {
            content: "\f0e7";
        }

        .fa-zap::before {
            content: "\f0e7";
        }

        .fa-bomb::before {
            content: "\f1e2";
        }

        .fa-bone::before {
            content: "\f5d7";
        }

        .fa-bong::before {
            content: "\f55c";
        }

        .fa-book::before {
            content: "\f02d";
        }

        .fa-book-atlas::before {
            content: "\f558";
        }

        .fa-atlas::before {
            content: "\f558";
        }

        .fa-book-bible::before {
            content: "\f647";
        }

        .fa-bible::before {
            content: "\f647";
        }

        .fa-book-journal-whills::before {
            content: "\f66a";
        }

        .fa-journal-whills::before {
            content: "\f66a";
        }

        .fa-book-medical::before {
            content: "\f7e6";
        }

        .fa-book-open::before {
            content: "\f518";
        }

        .fa-book-open-reader::before {
            content: "\f5da";
        }

        .fa-book-reader::before {
            content: "\f5da";
        }

        .fa-book-quran::before {
            content: "\f687";
        }

        .fa-quran::before {
            content: "\f687";
        }

        .fa-book-skull::before {
            content: "\f6b7";
        }

        .fa-book-dead::before {
            content: "\f6b7";
        }

        .fa-bookmark::before {
            content: "\f02e";
        }

        .fa-border-all::before {
            content: "\f84c";
        }

        .fa-border-none::before {
            content: "\f850";
        }

        .fa-border-top-left::before {
            content: "\f853";
        }

        .fa-border-style::before {
            content: "\f853";
        }

        .fa-bowling-ball::before {
            content: "\f436";
        }

        .fa-box::before {
            content: "\f466";
        }

        .fa-box-archive::before {
            content: "\f187";
        }

        .fa-archive::before {
            content: "\f187";
        }

        .fa-box-open::before {
            content: "\f49e";
        }

        .fa-box-tissue::before {
            content: "\e05b";
        }

        .fa-boxes-stacked::before {
            content: "\f468";
        }

        .fa-boxes::before {
            content: "\f468";
        }

        .fa-boxes-alt::before {
            content: "\f468";
        }

        .fa-braille::before {
            content: "\f2a1";
        }

        .fa-brain::before {
            content: "\f5dc";
        }

        .fa-brazilian-real-sign::before {
            content: "\e46c";
        }

        .fa-bread-slice::before {
            content: "\f7ec";
        }

        .fa-briefcase::before {
            content: "\f0b1";
        }

        .fa-briefcase-medical::before {
            content: "\f469";
        }

        .fa-broom::before {
            content: "\f51a";
        }

        .fa-broom-ball::before {
            content: "\f458";
        }

        .fa-quidditch::before {
            content: "\f458";
        }

        .fa-quidditch-broom-ball::before {
            content: "\f458";
        }

        .fa-brush::before {
            content: "\f55d";
        }

        .fa-bug::before {
            content: "\f188";
        }

        .fa-building::before {
            content: "\f1ad";
        }

        .fa-bullhorn::before {
            content: "\f0a1";
        }

        .fa-bullseye::before {
            content: "\f140";
        }

        .fa-burger::before {
            content: "\f805";
        }

        .fa-hamburger::before {
            content: "\f805";
        }

        .fa-bus::before {
            content: "\f207";
        }

        .fa-bus-simple::before {
            content: "\f55e";
        }

        .fa-bus-alt::before {
            content: "\f55e";
        }

        .fa-business-time::before {
            content: "\f64a";
        }

        .fa-briefcase-clock::before {
            content: "\f64a";
        }

        .fa-c::before {
            content: "\43";
        }

        .fa-cake-candles::before {
            content: "\f1fd";
        }

        .fa-birthday-cake::before {
            content: "\f1fd";
        }

        .fa-cake::before {
            content: "\f1fd";
        }

        .fa-calculator::before {
            content: "\f1ec";
        }

        .fa-calendar::before {
            content: "\f133";
        }

        .fa-calendar-check::before {
            content: "\f274";
        }

        .fa-calendar-day::before {
            content: "\f783";
        }

        .fa-calendar-days::before {
            content: "\f073";
        }

        .fa-calendar-alt::before {
            content: "\f073";
        }

        .fa-calendar-minus::before {
            content: "\f272";
        }

        .fa-calendar-plus::before {
            content: "\f271";
        }

        .fa-calendar-week::before {
            content: "\f784";
        }

        .fa-calendar-xmark::before {
            content: "\f273";
        }

        .fa-calendar-times::before {
            content: "\f273";
        }

        .fa-camera::before {
            content: "\f030";
        }

        .fa-camera-alt::before {
            content: "\f030";
        }

        .fa-camera-retro::before {
            content: "\f083";
        }

        .fa-camera-rotate::before {
            content: "\e0d8";
        }

        .fa-campground::before {
            content: "\f6bb";
        }

        .fa-candy-cane::before {
            content: "\f786";
        }

        .fa-cannabis::before {
            content: "\f55f";
        }

        .fa-capsules::before {
            content: "\f46b";
        }

        .fa-car::before {
            content: "\f1b9";
        }

        .fa-automobile::before {
            content: "\f1b9";
        }

        .fa-car-battery::before {
            content: "\f5df";
        }

        .fa-battery-car::before {
            content: "\f5df";
        }

        .fa-car-crash::before {
            content: "\f5e1";
        }

        .fa-car-rear::before {
            content: "\f5de";
        }

        .fa-car-alt::before {
            content: "\f5de";
        }

        .fa-car-side::before {
            content: "\f5e4";
        }

        .fa-caravan::before {
            content: "\f8ff";
        }

        .fa-caret-down::before {
            content: "\f0d7";
        }

        .fa-caret-left::before {
            content: "\f0d9";
        }

        .fa-caret-right::before {
            content: "\f0da";
        }

        .fa-caret-up::before {
            content: "\f0d8";
        }

        .fa-carrot::before {
            content: "\f787";
        }

        .fa-cart-arrow-down::before {
            content: "\f218";
        }

        .fa-cart-flatbed::before {
            content: "\f474";
        }

        .fa-dolly-flatbed::before {
            content: "\f474";
        }

        .fa-cart-flatbed-suitcase::before {
            content: "\f59d";
        }

        .fa-luggage-cart::before {
            content: "\f59d";
        }

        .fa-cart-plus::before {
            content: "\f217";
        }

        .fa-cart-shopping::before {
            content: "\f07a";
        }

        .fa-shopping-cart::before {
            content: "\f07a";
        }

        .fa-cash-register::before {
            content: "\f788";
        }

        .fa-cat::before {
            content: "\f6be";
        }

        .fa-cedi-sign::before {
            content: "\e0df";
        }

        .fa-cent-sign::before {
            content: "\e3f5";
        }

        .fa-certificate::before {
            content: "\f0a3";
        }

        .fa-chair::before {
            content: "\f6c0";
        }

        .fa-chalkboard::before {
            content: "\f51b";
        }

        .fa-blackboard::before {
            content: "\f51b";
        }

        .fa-chalkboard-user::before {
            content: "\f51c";
        }

        .fa-chalkboard-teacher::before {
            content: "\f51c";
        }

        .fa-champagne-glasses::before {
            content: "\f79f";
        }

        .fa-glass-cheers::before {
            content: "\f79f";
        }

        .fa-charging-station::before {
            content: "\f5e7";
        }

        .fa-chart-area::before {
            content: "\f1fe";
        }

        .fa-area-chart::before {
            content: "\f1fe";
        }

        .fa-chart-bar::before {
            content: "\f080";
        }

        .fa-bar-chart::before {
            content: "\f080";
        }

        .fa-chart-column::before {
            content: "\e0e3";
        }

        .fa-chart-gantt::before {
            content: "\e0e4";
        }

        .fa-chart-line::before {
            content: "\f201";
        }

        .fa-line-chart::before {
            content: "\f201";
        }

        .fa-chart-pie::before {
            content: "\f200";
        }

        .fa-pie-chart::before {
            content: "\f200";
        }

        .fa-check::before {
            content: "\f00c";
        }

        .fa-check-double::before {
            content: "\f560";
        }

        .fa-check-to-slot::before {
            content: "\f772";
        }

        .fa-vote-yea::before {
            content: "\f772";
        }

        .fa-cheese::before {
            content: "\f7ef";
        }

        .fa-chess::before {
            content: "\f439";
        }

        .fa-chess-bishop::before {
            content: "\f43a";
        }

        .fa-chess-board::before {
            content: "\f43c";
        }

        .fa-chess-king::before {
            content: "\f43f";
        }

        .fa-chess-knight::before {
            content: "\f441";
        }

        .fa-chess-pawn::before {
            content: "\f443";
        }

        .fa-chess-queen::before {
            content: "\f445";
        }

        .fa-chess-rook::before {
            content: "\f447";
        }

        .fa-chevron-down::before {
            content: "\f078";
        }

        .fa-chevron-left::before {
            content: "\f053";
        }

        .fa-chevron-right::before {
            content: "\f054";
        }

        .fa-chevron-up::before {
            content: "\f077";
        }

        .fa-child::before {
            content: "\f1ae";
        }

        .fa-church::before {
            content: "\f51d";
        }

        .fa-circle::before {
            content: "\f111";
        }

        .fa-circle-arrow-down::before {
            content: "\f0ab";
        }

        .fa-arrow-circle-down::before {
            content: "\f0ab";
        }

        .fa-circle-arrow-left::before {
            content: "\f0a8";
        }

        .fa-arrow-circle-left::before {
            content: "\f0a8";
        }

        .fa-circle-arrow-right::before {
            content: "\f0a9";
        }

        .fa-arrow-circle-right::before {
            content: "\f0a9";
        }

        .fa-circle-arrow-up::before {
            content: "\f0aa";
        }

        .fa-arrow-circle-up::before {
            content: "\f0aa";
        }

        .fa-circle-check::before {
            content: "\f058";
        }

        .fa-check-circle::before {
            content: "\f058";
        }

        .fa-circle-chevron-down::before {
            content: "\f13a";
        }

        .fa-chevron-circle-down::before {
            content: "\f13a";
        }

        .fa-circle-chevron-left::before {
            content: "\f137";
        }

        .fa-chevron-circle-left::before {
            content: "\f137";
        }

        .fa-circle-chevron-right::before {
            content: "\f138";
        }

        .fa-chevron-circle-right::before {
            content: "\f138";
        }

        .fa-circle-chevron-up::before {
            content: "\f139";
        }

        .fa-chevron-circle-up::before {
            content: "\f139";
        }

        .fa-circle-dollar-to-slot::before {
            content: "\f4b9";
        }

        .fa-donate::before {
            content: "\f4b9";
        }

        .fa-circle-dot::before {
            content: "\f192";
        }

        .fa-dot-circle::before {
            content: "\f192";
        }

        .fa-circle-down::before {
            content: "\f358";
        }

        .fa-arrow-alt-circle-down::before {
            content: "\f358";
        }

        .fa-circle-exclamation::before {
            content: "\f06a";
        }

        .fa-exclamation-circle::before {
            content: "\f06a";
        }

        .fa-circle-h::before {
            content: "\f47e";
        }

        .fa-hospital-symbol::before {
            content: "\f47e";
        }

        .fa-circle-half-stroke::before {
            content: "\f042";
        }

        .fa-adjust::before {
            content: "\f042";
        }

        .fa-circle-info::before {
            content: "\f05a";
        }

        .fa-info-circle::before {
            content: "\f05a";
        }

        .fa-circle-left::before {
            content: "\f359";
        }

        .fa-arrow-alt-circle-left::before {
            content: "\f359";
        }

        .fa-circle-minus::before {
            content: "\f056";
        }

        .fa-minus-circle::before {
            content: "\f056";
        }

        .fa-circle-notch::before {
            content: "\f1ce";
        }

        .fa-circle-pause::before {
            content: "\f28b";
        }

        .fa-pause-circle::before {
            content: "\f28b";
        }

        .fa-circle-play::before {
            content: "\f144";
        }

        .fa-play-circle::before {
            content: "\f144";
        }

        .fa-circle-plus::before {
            content: "\f055";
        }

        .fa-plus-circle::before {
            content: "\f055";
        }

        .fa-circle-question::before {
            content: "\f059";
        }

        .fa-question-circle::before {
            content: "\f059";
        }

        .fa-circle-radiation::before {
            content: "\f7ba";
        }

        .fa-radiation-alt::before {
            content: "\f7ba";
        }

        .fa-circle-right::before {
            content: "\f35a";
        }

        .fa-arrow-alt-circle-right::before {
            content: "\f35a";
        }

        .fa-circle-stop::before {
            content: "\f28d";
        }

        .fa-stop-circle::before {
            content: "\f28d";
        }

        .fa-circle-up::before {
            content: "\f35b";
        }

        .fa-arrow-alt-circle-up::before {
            content: "\f35b";
        }

        .fa-circle-user::before {
            content: "\f2bd";
        }

        .fa-user-circle::before {
            content: "\f2bd";
        }

        .fa-circle-xmark::before {
            content: "\f057";
        }

        .fa-times-circle::before {
            content: "\f057";
        }

        .fa-xmark-circle::before {
            content: "\f057";
        }

        .fa-city::before {
            content: "\f64f";
        }

        .fa-clapperboard::before {
            content: "\e131";
        }

        .fa-clipboard::before {
            content: "\f328";
        }

        .fa-clipboard-check::before {
            content: "\f46c";
        }

        .fa-clipboard-list::before {
            content: "\f46d";
        }

        .fa-clock::before {
            content: "\f017";
        }

        .fa-clock-four::before {
            content: "\f017";
        }

        .fa-clock-rotate-left::before {
            content: "\f1da";
        }

        .fa-history::before {
            content: "\f1da";
        }

        .fa-clone::before {
            content: "\f24d";
        }

        .fa-closed-captioning::before {
            content: "\f20a";
        }

        .fa-cloud::before {
            content: "\f0c2";
        }

        .fa-cloud-arrow-down::before {
            content: "\f0ed";
        }

        .fa-cloud-download::before {
            content: "\f0ed";
        }

        .fa-cloud-download-alt::before {
            content: "\f0ed";
        }

        .fa-cloud-arrow-up::before {
            content: "\f0ee";
        }

        .fa-cloud-upload::before {
            content: "\f0ee";
        }

        .fa-cloud-upload-alt::before {
            content: "\f0ee";
        }

        .fa-cloud-meatball::before {
            content: "\f73b";
        }

        .fa-cloud-moon::before {
            content: "\f6c3";
        }

        .fa-cloud-moon-rain::before {
            content: "\f73c";
        }

        .fa-cloud-rain::before {
            content: "\f73d";
        }

        .fa-cloud-showers-heavy::before {
            content: "\f740";
        }

        .fa-cloud-sun::before {
            content: "\f6c4";
        }

        .fa-cloud-sun-rain::before {
            content: "\f743";
        }

        .fa-clover::before {
            content: "\e139";
        }

        .fa-code::before {
            content: "\f121";
        }

        .fa-code-branch::before {
            content: "\f126";
        }

        .fa-code-commit::before {
            content: "\f386";
        }

        .fa-code-compare::before {
            content: "\e13a";
        }

        .fa-code-fork::before {
            content: "\e13b";
        }

        .fa-code-merge::before {
            content: "\f387";
        }

        .fa-code-pull-request::before {
            content: "\e13c";
        }

        .fa-coins::before {
            content: "\f51e";
        }

        .fa-colon-sign::before {
            content: "\e140";
        }

        .fa-comment::before {
            content: "\f075";
        }

        .fa-comment-dollar::before {
            content: "\f651";
        }

        .fa-comment-dots::before {
            content: "\f4ad";
        }

        .fa-commenting::before {
            content: "\f4ad";
        }

        .fa-comment-medical::before {
            content: "\f7f5";
        }

        .fa-comment-slash::before {
            content: "\f4b3";
        }

        .fa-comment-sms::before {
            content: "\f7cd";
        }

        .fa-sms::before {
            content: "\f7cd";
        }

        .fa-comments::before {
            content: "\f086";
        }

        .fa-comments-dollar::before {
            content: "\f653";
        }

        .fa-compact-disc::before {
            content: "\f51f";
        }

        .fa-compass::before {
            content: "\f14e";
        }

        .fa-compass-drafting::before {
            content: "\f568";
        }

        .fa-drafting-compass::before {
            content: "\f568";
        }

        .fa-compress::before {
            content: "\f066";
        }

        .fa-computer-mouse::before {
            content: "\f8cc";
        }

        .fa-mouse::before {
            content: "\f8cc";
        }

        .fa-cookie::before {
            content: "\f563";
        }

        .fa-cookie-bite::before {
            content: "\f564";
        }

        .fa-copy::before {
            content: "\f0c5";
        }

        .fa-copyright::before {
            content: "\f1f9";
        }

        .fa-couch::before {
            content: "\f4b8";
        }

        .fa-credit-card::before {
            content: "\f09d";
        }

        .fa-credit-card-alt::before {
            content: "\f09d";
        }

        .fa-crop::before {
            content: "\f125";
        }

        .fa-crop-simple::before {
            content: "\f565";
        }

        .fa-crop-alt::before {
            content: "\f565";
        }

        .fa-cross::before {
            content: "\f654";
        }

        .fa-crosshairs::before {
            content: "\f05b";
        }

        .fa-crow::before {
            content: "\f520";
        }

        .fa-crown::before {
            content: "\f521";
        }

        .fa-crutch::before {
            content: "\f7f7";
        }

        .fa-cruzeiro-sign::before {
            content: "\e152";
        }

        .fa-cube::before {
            content: "\f1b2";
        }

        .fa-cubes::before {
            content: "\f1b3";
        }

        .fa-d::before {
            content: "\44";
        }

        .fa-database::before {
            content: "\f1c0";
        }

        .fa-delete-left::before {
            content: "\f55a";
        }

        .fa-backspace::before {
            content: "\f55a";
        }

        .fa-democrat::before {
            content: "\f747";
        }

        .fa-desktop::before {
            content: "\f390";
        }

        .fa-desktop-alt::before {
            content: "\f390";
        }

        .fa-dharmachakra::before {
            content: "\f655";
        }

        .fa-diagram-project::before {
            content: "\f542";
        }

        .fa-project-diagram::before {
            content: "\f542";
        }

        .fa-diamond::before {
            content: "\f219";
        }

        .fa-diamond-turn-right::before {
            content: "\f5eb";
        }

        .fa-directions::before {
            content: "\f5eb";
        }

        .fa-dice::before {
            content: "\f522";
        }

        .fa-dice-d20::before {
            content: "\f6cf";
        }

        .fa-dice-d6::before {
            content: "\f6d1";
        }

        .fa-dice-five::before {
            content: "\f523";
        }

        .fa-dice-four::before {
            content: "\f524";
        }

        .fa-dice-one::before {
            content: "\f525";
        }

        .fa-dice-six::before {
            content: "\f526";
        }

        .fa-dice-three::before {
            content: "\f527";
        }

        .fa-dice-two::before {
            content: "\f528";
        }

        .fa-disease::before {
            content: "\f7fa";
        }

        .fa-divide::before {
            content: "\f529";
        }

        .fa-dna::before {
            content: "\f471";
        }

        .fa-dog::before {
            content: "\f6d3";
        }

        .fa-dollar-sign::before {
            content: "\24";
        }

        .fa-dollar::before {
            content: "\24";
        }

        .fa-usd::before {
            content: "\24";
        }

        .fa-dolly::before {
            content: "\f472";
        }

        .fa-dolly-box::before {
            content: "\f472";
        }

        .fa-dong-sign::before {
            content: "\e169";
        }

        .fa-door-closed::before {
            content: "\f52a";
        }

        .fa-door-open::before {
            content: "\f52b";
        }

        .fa-dove::before {
            content: "\f4ba";
        }

        .fa-down-left-and-up-right-to-center::before {
            content: "\f422";
        }

        .fa-compress-alt::before {
            content: "\f422";
        }

        .fa-down-long::before {
            content: "\f309";
        }

        .fa-long-arrow-alt-down::before {
            content: "\f309";
        }

        .fa-download::before {
            content: "\f019";
        }

        .fa-dragon::before {
            content: "\f6d5";
        }

        .fa-draw-polygon::before {
            content: "\f5ee";
        }

        .fa-droplet::before {
            content: "\f043";
        }

        .fa-tint::before {
            content: "\f043";
        }

        .fa-droplet-slash::before {
            content: "\f5c7";
        }

        .fa-tint-slash::before {
            content: "\f5c7";
        }

        .fa-drum::before {
            content: "\f569";
        }

        .fa-drum-steelpan::before {
            content: "\f56a";
        }

        .fa-drumstick-bite::before {
            content: "\f6d7";
        }

        .fa-dumbbell::before {
            content: "\f44b";
        }

        .fa-dumpster::before {
            content: "\f793";
        }

        .fa-dumpster-fire::before {
            content: "\f794";
        }

        .fa-dungeon::before {
            content: "\f6d9";
        }

        .fa-e::before {
            content: "\45";
        }

        .fa-ear-deaf::before {
            content: "\f2a4";
        }

        .fa-deaf::before {
            content: "\f2a4";
        }

        .fa-deafness::before {
            content: "\f2a4";
        }

        .fa-hard-of-hearing::before {
            content: "\f2a4";
        }

        .fa-ear-listen::before {
            content: "\f2a2";
        }

        .fa-assistive-listening-systems::before {
            content: "\f2a2";
        }

        .fa-earth-africa::before {
            content: "\f57c";
        }

        .fa-globe-africa::before {
            content: "\f57c";
        }

        .fa-earth-americas::before {
            content: "\f57d";
        }

        .fa-earth::before {
            content: "\f57d";
        }

        .fa-earth-america::before {
            content: "\f57d";
        }

        .fa-globe-americas::before {
            content: "\f57d";
        }

        .fa-earth-asia::before {
            content: "\f57e";
        }

        .fa-globe-asia::before {
            content: "\f57e";
        }

        .fa-earth-europe::before {
            content: "\f7a2";
        }

        .fa-globe-europe::before {
            content: "\f7a2";
        }

        .fa-earth-oceania::before {
            content: "\e47b";
        }

        .fa-globe-oceania::before {
            content: "\e47b";
        }

        .fa-egg::before {
            content: "\f7fb";
        }

        .fa-eject::before {
            content: "\f052";
        }

        .fa-elevator::before {
            content: "\e16d";
        }

        .fa-ellipsis::before {
            content: "\f141";
        }

        .fa-ellipsis-h::before {
            content: "\f141";
        }

        .fa-ellipsis-vertical::before {
            content: "\f142";
        }

        .fa-ellipsis-v::before {
            content: "\f142";
        }

        .fa-envelope::before {
            content: "\f0e0";
        }

        .fa-envelope-open::before {
            content: "\f2b6";
        }

        .fa-envelope-open-text::before {
            content: "\f658";
        }

        .fa-envelopes-bulk::before {
            content: "\f674";
        }

        .fa-mail-bulk::before {
            content: "\f674";
        }

        .fa-equals::before {
            content: "\3d";
        }

        .fa-eraser::before {
            content: "\f12d";
        }

        .fa-ethernet::before {
            content: "\f796";
        }

        .fa-euro-sign::before {
            content: "\f153";
        }

        .fa-eur::before {
            content: "\f153";
        }

        .fa-euro::before {
            content: "\f153";
        }

        .fa-exclamation::before {
            content: "\21";
        }

        .fa-expand::before {
            content: "\f065";
        }

        .fa-eye::before {
            content: "\f06e";
        }

        .fa-eye-dropper::before {
            content: "\f1fb";
        }

        .fa-eye-dropper-empty::before {
            content: "\f1fb";
        }

        .fa-eyedropper::before {
            content: "\f1fb";
        }

        .fa-eye-low-vision::before {
            content: "\f2a8";
        }

        .fa-low-vision::before {
            content: "\f2a8";
        }

        .fa-eye-slash::before {
            content: "\f070";
        }

        .fa-f::before {
            content: "\46";
        }

        .fa-face-angry::before {
            content: "\f556";
        }

        .fa-angry::before {
            content: "\f556";
        }

        .fa-face-dizzy::before {
            content: "\f567";
        }

        .fa-dizzy::before {
            content: "\f567";
        }

        .fa-face-flushed::before {
            content: "\f579";
        }

        .fa-flushed::before {
            content: "\f579";
        }

        .fa-face-frown::before {
            content: "\f119";
        }

        .fa-frown::before {
            content: "\f119";
        }

        .fa-face-frown-open::before {
            content: "\f57a";
        }

        .fa-frown-open::before {
            content: "\f57a";
        }

        .fa-face-grimace::before {
            content: "\f57f";
        }

        .fa-grimace::before {
            content: "\f57f";
        }

        .fa-face-grin::before {
            content: "\f580";
        }

        .fa-grin::before {
            content: "\f580";
        }

        .fa-face-grin-beam::before {
            content: "\f582";
        }

        .fa-grin-beam::before {
            content: "\f582";
        }

        .fa-face-grin-beam-sweat::before {
            content: "\f583";
        }

        .fa-grin-beam-sweat::before {
            content: "\f583";
        }

        .fa-face-grin-hearts::before {
            content: "\f584";
        }

        .fa-grin-hearts::before {
            content: "\f584";
        }

        .fa-face-grin-squint::before {
            content: "\f585";
        }

        .fa-grin-squint::before {
            content: "\f585";
        }

        .fa-face-grin-squint-tears::before {
            content: "\f586";
        }

        .fa-grin-squint-tears::before {
            content: "\f586";
        }

        .fa-face-grin-stars::before {
            content: "\f587";
        }

        .fa-grin-stars::before {
            content: "\f587";
        }

        .fa-face-grin-tears::before {
            content: "\f588";
        }

        .fa-grin-tears::before {
            content: "\f588";
        }

        .fa-face-grin-tongue::before {
            content: "\f589";
        }

        .fa-grin-tongue::before {
            content: "\f589";
        }

        .fa-face-grin-tongue-squint::before {
            content: "\f58a";
        }

        .fa-grin-tongue-squint::before {
            content: "\f58a";
        }

        .fa-face-grin-tongue-wink::before {
            content: "\f58b";
        }

        .fa-grin-tongue-wink::before {
            content: "\f58b";
        }

        .fa-face-grin-wide::before {
            content: "\f581";
        }

        .fa-grin-alt::before {
            content: "\f581";
        }

        .fa-face-grin-wink::before {
            content: "\f58c";
        }

        .fa-grin-wink::before {
            content: "\f58c";
        }

        .fa-face-kiss::before {
            content: "\f596";
        }

        .fa-kiss::before {
            content: "\f596";
        }

        .fa-face-kiss-beam::before {
            content: "\f597";
        }

        .fa-kiss-beam::before {
            content: "\f597";
        }

        .fa-face-kiss-wink-heart::before {
            content: "\f598";
        }

        .fa-kiss-wink-heart::before {
            content: "\f598";
        }

        .fa-face-laugh::before {
            content: "\f599";
        }

        .fa-laugh::before {
            content: "\f599";
        }

        .fa-face-laugh-beam::before {
            content: "\f59a";
        }

        .fa-laugh-beam::before {
            content: "\f59a";
        }

        .fa-face-laugh-squint::before {
            content: "\f59b";
        }

        .fa-laugh-squint::before {
            content: "\f59b";
        }

        .fa-face-laugh-wink::before {
            content: "\f59c";
        }

        .fa-laugh-wink::before {
            content: "\f59c";
        }

        .fa-face-meh::before {
            content: "\f11a";
        }

        .fa-meh::before {
            content: "\f11a";
        }

        .fa-face-meh-blank::before {
            content: "\f5a4";
        }

        .fa-meh-blank::before {
            content: "\f5a4";
        }

        .fa-face-rolling-eyes::before {
            content: "\f5a5";
        }

        .fa-meh-rolling-eyes::before {
            content: "\f5a5";
        }

        .fa-face-sad-cry::before {
            content: "\f5b3";
        }

        .fa-sad-cry::before {
            content: "\f5b3";
        }

        .fa-face-sad-tear::before {
            content: "\f5b4";
        }

        .fa-sad-tear::before {
            content: "\f5b4";
        }

        .fa-face-smile::before {
            content: "\f118";
        }

        .fa-smile::before {
            content: "\f118";
        }

        .fa-face-smile-beam::before {
            content: "\f5b8";
        }

        .fa-smile-beam::before {
            content: "\f5b8";
        }

        .fa-face-smile-wink::before {
            content: "\f4da";
        }

        .fa-smile-wink::before {
            content: "\f4da";
        }

        .fa-face-surprise::before {
            content: "\f5c2";
        }

        .fa-surprise::before {
            content: "\f5c2";
        }

        .fa-face-tired::before {
            content: "\f5c8";
        }

        .fa-tired::before {
            content: "\f5c8";
        }

        .fa-fan::before {
            content: "\f863";
        }

        .fa-faucet::before {
            content: "\e005";
        }

        .fa-fax::before {
            content: "\f1ac";
        }

        .fa-feather::before {
            content: "\f52d";
        }

        .fa-feather-pointed::before {
            content: "\f56b";
        }

        .fa-feather-alt::before {
            content: "\f56b";
        }

        .fa-file::before {
            content: "\f15b";
        }

        .fa-file-arrow-down::before {
            content: "\f56d";
        }

        .fa-file-download::before {
            content: "\f56d";
        }

        .fa-file-arrow-up::before {
            content: "\f574";
        }

        .fa-file-upload::before {
            content: "\f574";
        }

        .fa-file-audio::before {
            content: "\f1c7";
        }

        .fa-file-code::before {
            content: "\f1c9";
        }

        .fa-file-contract::before {
            content: "\f56c";
        }

        .fa-file-csv::before {
            content: "\f6dd";
        }

        .fa-file-excel::before {
            content: "\f1c3";
        }

        .fa-file-export::before {
            content: "\f56e";
        }

        .fa-arrow-right-from-file::before {
            content: "\f56e";
        }

        .fa-file-image::before {
            content: "\f1c5";
        }

        .fa-file-import::before {
            content: "\f56f";
        }

        .fa-arrow-right-to-file::before {
            content: "\f56f";
        }

        .fa-file-invoice::before {
            content: "\f570";
        }

        .fa-file-invoice-dollar::before {
            content: "\f571";
        }

        .fa-file-lines::before {
            content: "\f15c";
        }

        .fa-file-alt::before {
            content: "\f15c";
        }

        .fa-file-text::before {
            content: "\f15c";
        }

        .fa-file-medical::before {
            content: "\f477";
        }

        .fa-file-pdf::before {
            content: "\f1c1";
        }

        .fa-file-powerpoint::before {
            content: "\f1c4";
        }

        .fa-file-prescription::before {
            content: "\f572";
        }

        .fa-file-signature::before {
            content: "\f573";
        }

        .fa-file-video::before {
            content: "\f1c8";
        }

        .fa-file-waveform::before {
            content: "\f478";
        }

        .fa-file-medical-alt::before {
            content: "\f478";
        }

        .fa-file-word::before {
            content: "\f1c2";
        }

        .fa-file-zipper::before {
            content: "\f1c6";
        }

        .fa-file-archive::before {
            content: "\f1c6";
        }

        .fa-fill::before {
            content: "\f575";
        }

        .fa-fill-drip::before {
            content: "\f576";
        }

        .fa-film::before {
            content: "\f008";
        }

        .fa-filter::before {
            content: "\f0b0";
        }

        .fa-filter-circle-dollar::before {
            content: "\f662";
        }

        .fa-funnel-dollar::before {
            content: "\f662";
        }

        .fa-filter-circle-xmark::before {
            content: "\e17b";
        }

        .fa-fingerprint::before {
            content: "\f577";
        }

        .fa-fire::before {
            content: "\f06d";
        }

        .fa-fire-extinguisher::before {
            content: "\f134";
        }

        .fa-fire-flame-curved::before {
            content: "\f7e4";
        }

        .fa-fire-alt::before {
            content: "\f7e4";
        }

        .fa-fire-flame-simple::before {
            content: "\f46a";
        }

        .fa-burn::before {
            content: "\f46a";
        }

        .fa-fish::before {
            content: "\f578";
        }

        .fa-flag::before {
            content: "\f024";
        }

        .fa-flag-checkered::before {
            content: "\f11e";
        }

        .fa-flag-usa::before {
            content: "\f74d";
        }

        .fa-flask::before {
            content: "\f0c3";
        }

        .fa-floppy-disk::before {
            content: "\f0c7";
        }

        .fa-save::before {
            content: "\f0c7";
        }

        .fa-florin-sign::before {
            content: "\e184";
        }

        .fa-folder::before {
            content: "\f07b";
        }

        .fa-folder-minus::before {
            content: "\f65d";
        }

        .fa-folder-open::before {
            content: "\f07c";
        }

        .fa-folder-plus::before {
            content: "\f65e";
        }

        .fa-folder-tree::before {
            content: "\f802";
        }

        .fa-font::before {
            content: "\f031";
        }

        .fa-football::before {
            content: "\f44e";
        }

        .fa-football-ball::before {
            content: "\f44e";
        }

        .fa-forward::before {
            content: "\f04e";
        }

        .fa-forward-fast::before {
            content: "\f050";
        }

        .fa-fast-forward::before {
            content: "\f050";
        }

        .fa-forward-step::before {
            content: "\f051";
        }

        .fa-step-forward::before {
            content: "\f051";
        }

        .fa-franc-sign::before {
            content: "\e18f";
        }

        .fa-frog::before {
            content: "\f52e";
        }

        .fa-futbol::before {
            content: "\f1e3";
        }

        .fa-futbol-ball::before {
            content: "\f1e3";
        }

        .fa-soccer-ball::before {
            content: "\f1e3";
        }

        .fa-g::before {
            content: "\47";
        }

        .fa-gamepad::before {
            content: "\f11b";
        }

        .fa-gas-pump::before {
            content: "\f52f";
        }

        .fa-gauge::before {
            content: "\f625";
        }

        .fa-dashboard::before {
            content: "\f625";
        }

        .fa-gauge-high::before {
            content: "\f625";
        }

        .fa-tachometer-alt::before {
            content: "\f625";
        }

        .fa-tachometer-alt-fast::before {
            content: "\f625";
        }

        .fa-gauge-simple::before {
            content: "\f62a";
        }

        .fa-gauge-simple-high::before {
            content: "\f62a";
        }

        .fa-tachometer::before {
            content: "\f62a";
        }

        .fa-tachometer-fast::before {
            content: "\f62a";
        }

        .fa-gavel::before {
            content: "\f0e3";
        }

        .fa-legal::before {
            content: "\f0e3";
        }

        .fa-gear::before {
            content: "\f013";
        }

        .fa-cog::before {
            content: "\f013";
        }

        .fa-gears::before {
            content: "\f085";
        }

        .fa-cogs::before {
            content: "\f085";
        }

        .fa-gem::before {
            content: "\f3a5";
        }

        .fa-genderless::before {
            content: "\f22d";
        }

        .fa-ghost::before {
            content: "\f6e2";
        }

        .fa-gift::before {
            content: "\f06b";
        }

        .fa-gifts::before {
            content: "\f79c";
        }

        .fa-glasses::before {
            content: "\f530";
        }

        .fa-globe::before {
            content: "\f0ac";
        }

        .fa-golf-ball-tee::before {
            content: "\f450";
        }

        .fa-golf-ball::before {
            content: "\f450";
        }

        .fa-gopuram::before {
            content: "\f664";
        }

        .fa-graduation-cap::before {
            content: "\f19d";
        }

        .fa-mortar-board::before {
            content: "\f19d";
        }

        .fa-greater-than::before {
            content: "\3e";
        }

        .fa-greater-than-equal::before {
            content: "\f532";
        }

        .fa-grip::before {
            content: "\f58d";
        }

        .fa-grip-horizontal::before {
            content: "\f58d";
        }

        .fa-grip-lines::before {
            content: "\f7a4";
        }

        .fa-grip-lines-vertical::before {
            content: "\f7a5";
        }

        .fa-grip-vertical::before {
            content: "\f58e";
        }

        .fa-guarani-sign::before {
            content: "\e19a";
        }

        .fa-guitar::before {
            content: "\f7a6";
        }

        .fa-gun::before {
            content: "\e19b";
        }

        .fa-h::before {
            content: "\48";
        }

        .fa-hammer::before {
            content: "\f6e3";
        }

        .fa-hamsa::before {
            content: "\f665";
        }

        .fa-hand::before {
            content: "\f256";
        }

        .fa-hand-paper::before {
            content: "\f256";
        }

        .fa-hand-back-fist::before {
            content: "\f255";
        }

        .fa-hand-rock::before {
            content: "\f255";
        }

        .fa-hand-dots::before {
            content: "\f461";
        }

        .fa-allergies::before {
            content: "\f461";
        }

        .fa-hand-fist::before {
            content: "\f6de";
        }

        .fa-fist-raised::before {
            content: "\f6de";
        }

        .fa-hand-holding::before {
            content: "\f4bd";
        }

        .fa-hand-holding-dollar::before {
            content: "\f4c0";
        }

        .fa-hand-holding-usd::before {
            content: "\f4c0";
        }

        .fa-hand-holding-droplet::before {
            content: "\f4c1";
        }

        .fa-hand-holding-water::before {
            content: "\f4c1";
        }

        .fa-hand-holding-heart::before {
            content: "\f4be";
        }

        .fa-hand-holding-medical::before {
            content: "\e05c";
        }

        .fa-hand-lizard::before {
            content: "\f258";
        }

        .fa-hand-middle-finger::before {
            content: "\f806";
        }

        .fa-hand-peace::before {
            content: "\f25b";
        }

        .fa-hand-point-down::before {
            content: "\f0a7";
        }

        .fa-hand-point-left::before {
            content: "\f0a5";
        }

        .fa-hand-point-right::before {
            content: "\f0a4";
        }

        .fa-hand-point-up::before {
            content: "\f0a6";
        }

        .fa-hand-pointer::before {
            content: "\f25a";
        }

        .fa-hand-scissors::before {
            content: "\f257";
        }

        .fa-hand-sparkles::before {
            content: "\e05d";
        }

        .fa-hand-spock::before {
            content: "\f259";
        }

        .fa-hands::before {
            content: "\f2a7";
        }

        .fa-sign-language::before {
            content: "\f2a7";
        }

        .fa-signing::before {
            content: "\f2a7";
        }

        .fa-hands-asl-interpreting::before {
            content: "\f2a3";
        }

        .fa-american-sign-language-interpreting::before {
            content: "\f2a3";
        }

        .fa-asl-interpreting::before {
            content: "\f2a3";
        }

        .fa-hands-american-sign-language-interpreting::before {
            content: "\f2a3";
        }

        .fa-hands-bubbles::before {
            content: "\e05e";
        }

        .fa-hands-wash::before {
            content: "\e05e";
        }

        .fa-hands-clapping::before {
            content: "\e1a8";
        }

        .fa-hands-holding::before {
            content: "\f4c2";
        }

        .fa-hands-praying::before {
            content: "\f684";
        }

        .fa-praying-hands::before {
            content: "\f684";
        }

        .fa-handshake::before {
            content: "\f2b5";
        }

        .fa-handshake-angle::before {
            content: "\f4c4";
        }

        .fa-hands-helping::before {
            content: "\f4c4";
        }

        .fa-handshake-simple-slash::before {
            content: "\e05f";
        }

        .fa-handshake-alt-slash::before {
            content: "\e05f";
        }

        .fa-handshake-slash::before {
            content: "\e060";
        }

        .fa-hanukiah::before {
            content: "\f6e6";
        }

        .fa-hard-drive::before {
            content: "\f0a0";
        }

        .fa-hdd::before {
            content: "\f0a0";
        }

        .fa-hashtag::before {
            content: "\23";
        }

        .fa-hat-cowboy::before {
            content: "\f8c0";
        }

        .fa-hat-cowboy-side::before {
            content: "\f8c1";
        }

        .fa-hat-wizard::before {
            content: "\f6e8";
        }

        .fa-head-side-cough::before {
            content: "\e061";
        }

        .fa-head-side-cough-slash::before {
            content: "\e062";
        }

        .fa-head-side-mask::before {
            content: "\e063";
        }

        .fa-head-side-virus::before {
            content: "\e064";
        }

        .fa-heading::before {
            content: "\f1dc";
        }

        .fa-header::before {
            content: "\f1dc";
        }

        .fa-headphones::before {
            content: "\f025";
        }

        .fa-headphones-simple::before {
            content: "\f58f";
        }

        .fa-headphones-alt::before {
            content: "\f58f";
        }

        .fa-headset::before {
            content: "\f590";
        }

        .fa-heart::before {
            content: "\f004";
        }

        .fa-heart-crack::before {
            content: "\f7a9";
        }

        .fa-heart-broken::before {
            content: "\f7a9";
        }

        .fa-heart-pulse::before {
            content: "\f21e";
        }

        .fa-heartbeat::before {
            content: "\f21e";
        }

        .fa-helicopter::before {
            content: "\f533";
        }

        .fa-helmet-safety::before {
            content: "\f807";
        }

        .fa-hard-hat::before {
            content: "\f807";
        }

        .fa-hat-hard::before {
            content: "\f807";
        }

        .fa-highlighter::before {
            content: "\f591";
        }

        .fa-hippo::before {
            content: "\f6ed";
        }

        .fa-hockey-puck::before {
            content: "\f453";
        }

        .fa-holly-berry::before {
            content: "\f7aa";
        }

        .fa-horse::before {
            content: "\f6f0";
        }

        .fa-horse-head::before {
            content: "\f7ab";
        }

        .fa-hospital::before {
            content: "\f0f8";
        }

        .fa-hospital-alt::before {
            content: "\f0f8";
        }

        .fa-hospital-wide::before {
            content: "\f0f8";
        }

        .fa-hospital-user::before {
            content: "\f80d";
        }

        .fa-hot-tub-person::before {
            content: "\f593";
        }

        .fa-hot-tub::before {
            content: "\f593";
        }

        .fa-hotdog::before {
            content: "\f80f";
        }

        .fa-hotel::before {
            content: "\f594";
        }

        .fa-hourglass::before {
            content: "\f254";
        }

        .fa-hourglass-2::before {
            content: "\f254";
        }

        .fa-hourglass-half::before {
            content: "\f254";
        }

        .fa-hourglass-empty::before {
            content: "\f252";
        }

        .fa-hourglass-end::before {
            content: "\f253";
        }

        .fa-hourglass-3::before {
            content: "\f253";
        }

        .fa-hourglass-start::before {
            content: "\f251";
        }

        .fa-hourglass-1::before {
            content: "\f251";
        }

        .fa-house::before {
            content: "\f015";
        }

        .fa-home::before {
            content: "\f015";
        }

        .fa-home-alt::before {
            content: "\f015";
        }

        .fa-home-lg-alt::before {
            content: "\f015";
        }

        .fa-house-chimney::before {
            content: "\e3af";
        }

        .fa-home-lg::before {
            content: "\e3af";
        }

        .fa-house-chimney-crack::before {
            content: "\f6f1";
        }

        .fa-house-damage::before {
            content: "\f6f1";
        }

        .fa-house-chimney-medical::before {
            content: "\f7f2";
        }

        .fa-clinic-medical::before {
            content: "\f7f2";
        }

        .fa-house-chimney-user::before {
            content: "\e065";
        }

        .fa-house-crack::before {
            content: "\e3b1";
        }

        .fa-house-laptop::before {
            content: "\e066";
        }

        .fa-laptop-house::before {
            content: "\e066";
        }

        .fa-house-medical::before {
            content: "\e3b2";
        }

        .fa-house-user::before {
            content: "\e1b0";
        }

        .fa-home-user::before {
            content: "\e1b0";
        }

        .fa-hryvnia-sign::before {
            content: "\f6f2";
        }

        .fa-hryvnia::before {
            content: "\f6f2";
        }

        .fa-i::before {
            content: "\49";
        }

        .fa-i-cursor::before {
            content: "\f246";
        }

        .fa-ice-cream::before {
            content: "\f810";
        }

        .fa-icicles::before {
            content: "\f7ad";
        }

        .fa-icons::before {
            content: "\f86d";
        }

        .fa-heart-music-camera-bolt::before {
            content: "\f86d";
        }

        .fa-id-badge::before {
            content: "\f2c1";
        }

        .fa-id-card::before {
            content: "\f2c2";
        }

        .fa-drivers-license::before {
            content: "\f2c2";
        }

        .fa-id-card-clip::before {
            content: "\f47f";
        }

        .fa-id-card-alt::before {
            content: "\f47f";
        }

        .fa-igloo::before {
            content: "\f7ae";
        }

        .fa-image::before {
            content: "\f03e";
        }

        .fa-image-portrait::before {
            content: "\f3e0";
        }

        .fa-portrait::before {
            content: "\f3e0";
        }

        .fa-images::before {
            content: "\f302";
        }

        .fa-inbox::before {
            content: "\f01c";
        }

        .fa-indent::before {
            content: "\f03c";
        }

        .fa-indian-rupee-sign::before {
            content: "\e1bc";
        }

        .fa-indian-rupee::before {
            content: "\e1bc";
        }

        .fa-inr::before {
            content: "\e1bc";
        }

        .fa-industry::before {
            content: "\f275";
        }

        .fa-infinity::before {
            content: "\f534";
        }

        .fa-info::before {
            content: "\f129";
        }

        .fa-italic::before {
            content: "\f033";
        }

        .fa-j::before {
            content: "\4a";
        }

        .fa-jedi::before {
            content: "\f669";
        }

        .fa-jet-fighter::before {
            content: "\f0fb";
        }

        .fa-fighter-jet::before {
            content: "\f0fb";
        }

        .fa-joint::before {
            content: "\f595";
        }

        .fa-k::before {
            content: "\4b";
        }

        .fa-kaaba::before {
            content: "\f66b";
        }

        .fa-key::before {
            content: "\f084";
        }

        .fa-keyboard::before {
            content: "\f11c";
        }

        .fa-khanda::before {
            content: "\f66d";
        }

        .fa-kip-sign::before {
            content: "\e1c4";
        }

        .fa-kit-medical::before {
            content: "\f479";
        }

        .fa-first-aid::before {
            content: "\f479";
        }

        .fa-kiwi-bird::before {
            content: "\f535";
        }

        .fa-l::before {
            content: "\4c";
        }

        .fa-landmark::before {
            content: "\f66f";
        }

        .fa-language::before {
            content: "\f1ab";
        }

        .fa-laptop::before {
            content: "\f109";
        }

        .fa-laptop-code::before {
            content: "\f5fc";
        }

        .fa-laptop-medical::before {
            content: "\f812";
        }

        .fa-lari-sign::before {
            content: "\e1c8";
        }

        .fa-layer-group::before {
            content: "\f5fd";
        }

        .fa-leaf::before {
            content: "\f06c";
        }

        .fa-left-long::before {
            content: "\f30a";
        }

        .fa-long-arrow-alt-left::before {
            content: "\f30a";
        }

        .fa-left-right::before {
            content: "\f337";
        }

        .fa-arrows-alt-h::before {
            content: "\f337";
        }

        .fa-lemon::before {
            content: "\f094";
        }

        .fa-less-than::before {
            content: "\3c";
        }

        .fa-less-than-equal::before {
            content: "\f537";
        }

        .fa-life-ring::before {
            content: "\f1cd";
        }

        .fa-lightbulb::before {
            content: "\f0eb";
        }

        .fa-link::before {
            content: "\f0c1";
        }

        .fa-chain::before {
            content: "\f0c1";
        }

        .fa-link-slash::before {
            content: "\f127";
        }

        .fa-chain-broken::before {
            content: "\f127";
        }

        .fa-chain-slash::before {
            content: "\f127";
        }

        .fa-unlink::before {
            content: "\f127";
        }

        .fa-lira-sign::before {
            content: "\f195";
        }

        .fa-list::before {
            content: "\f03a";
        }

        .fa-list-squares::before {
            content: "\f03a";
        }

        .fa-list-check::before {
            content: "\f0ae";
        }

        .fa-tasks::before {
            content: "\f0ae";
        }

        .fa-list-ol::before {
            content: "\f0cb";
        }

        .fa-list-1-2::before {
            content: "\f0cb";
        }

        .fa-list-numeric::before {
            content: "\f0cb";
        }

        .fa-list-ul::before {
            content: "\f0ca";
        }

        .fa-list-dots::before {
            content: "\f0ca";
        }

        .fa-litecoin-sign::before {
            content: "\e1d3";
        }

        .fa-location-arrow::before {
            content: "\f124";
        }

        .fa-location-crosshairs::before {
            content: "\f601";
        }

        .fa-location::before {
            content: "\f601";
        }

        .fa-location-dot::before {
            content: "\f3c5";
        }

        .fa-map-marker-alt::before {
            content: "\f3c5";
        }

        .fa-location-pin::before {
            content: "\f041";
        }

        .fa-map-marker::before {
            content: "\f041";
        }

        .fa-lock::before {
            content: "\f023";
        }

        .fa-lock-open::before {
            content: "\f3c1";
        }

        .fa-lungs::before {
            content: "\f604";
        }

        .fa-lungs-virus::before {
            content: "\e067";
        }

        .fa-m::before {
            content: "\4d";
        }

        .fa-magnet::before {
            content: "\f076";
        }

        .fa-magnifying-glass::before {
            content: "\f002";
        }

        .fa-search::before {
            content: "\f002";
        }

        .fa-magnifying-glass-dollar::before {
            content: "\f688";
        }

        .fa-search-dollar::before {
            content: "\f688";
        }

        .fa-magnifying-glass-location::before {
            content: "\f689";
        }

        .fa-search-location::before {
            content: "\f689";
        }

        .fa-magnifying-glass-minus::before {
            content: "\f010";
        }

        .fa-search-minus::before {
            content: "\f010";
        }

        .fa-magnifying-glass-plus::before {
            content: "\f00e";
        }

        .fa-search-plus::before {
            content: "\f00e";
        }

        .fa-manat-sign::before {
            content: "\e1d5";
        }

        .fa-map::before {
            content: "\f279";
        }

        .fa-map-location::before {
            content: "\f59f";
        }

        .fa-map-marked::before {
            content: "\f59f";
        }

        .fa-map-location-dot::before {
            content: "\f5a0";
        }

        .fa-map-marked-alt::before {
            content: "\f5a0";
        }

        .fa-map-pin::before {
            content: "\f276";
        }

        .fa-marker::before {
            content: "\f5a1";
        }

        .fa-mars::before {
            content: "\f222";
        }

        .fa-mars-and-venus::before {
            content: "\f224";
        }

        .fa-mars-double::before {
            content: "\f227";
        }

        .fa-mars-stroke::before {
            content: "\f229";
        }

        .fa-mars-stroke-right::before {
            content: "\f22b";
        }

        .fa-mars-stroke-h::before {
            content: "\f22b";
        }

        .fa-mars-stroke-up::before {
            content: "\f22a";
        }

        .fa-mars-stroke-v::before {
            content: "\f22a";
        }

        .fa-martini-glass::before {
            content: "\f57b";
        }

        .fa-glass-martini-alt::before {
            content: "\f57b";
        }

        .fa-martini-glass-citrus::before {
            content: "\f561";
        }

        .fa-cocktail::before {
            content: "\f561";
        }

        .fa-martini-glass-empty::before {
            content: "\f000";
        }

        .fa-glass-martini::before {
            content: "\f000";
        }

        .fa-mask::before {
            content: "\f6fa";
        }

        .fa-mask-face::before {
            content: "\e1d7";
        }

        .fa-masks-theater::before {
            content: "\f630";
        }

        .fa-theater-masks::before {
            content: "\f630";
        }

        .fa-maximize::before {
            content: "\f31e";
        }

        .fa-expand-arrows-alt::before {
            content: "\f31e";
        }

        .fa-medal::before {
            content: "\f5a2";
        }

        .fa-memory::before {
            content: "\f538";
        }

        .fa-menorah::before {
            content: "\f676";
        }

        .fa-mercury::before {
            content: "\f223";
        }

        .fa-message::before {
            content: "\f27a";
        }

        .fa-comment-alt::before {
            content: "\f27a";
        }

        .fa-meteor::before {
            content: "\f753";
        }

        .fa-microchip::before {
            content: "\f2db";
        }

        .fa-microphone::before {
            content: "\f130";
        }

        .fa-microphone-lines::before {
            content: "\f3c9";
        }

        .fa-microphone-alt::before {
            content: "\f3c9";
        }

        .fa-microphone-lines-slash::before {
            content: "\f539";
        }

        .fa-microphone-alt-slash::before {
            content: "\f539";
        }

        .fa-microphone-slash::before {
            content: "\f131";
        }

        .fa-microscope::before {
            content: "\f610";
        }

        .fa-mill-sign::before {
            content: "\e1ed";
        }

        .fa-minimize::before {
            content: "\f78c";
        }

        .fa-compress-arrows-alt::before {
            content: "\f78c";
        }

        .fa-minus::before {
            content: "\f068";
        }

        .fa-subtract::before {
            content: "\f068";
        }

        .fa-mitten::before {
            content: "\f7b5";
        }

        .fa-mobile-button::before {
            content: "\f10b";
        }

        .fa-mobile-screen-button::before {
            content: "\f3cd";
        }

        .fa-mobile-alt::before {
            content: "\f3cd";
        }

        .fa-money-bill::before {
            content: "\f0d6";
        }

        .fa-money-bill-1::before {
            content: "\f3d1";
        }

        .fa-money-bill-alt::before {
            content: "\f3d1";
        }

        .fa-money-bill-1-wave::before {
            content: "\f53b";
        }

        .fa-money-bill-wave-alt::before {
            content: "\f53b";
        }

        .fa-money-bill-wave::before {
            content: "\f53a";
        }

        .fa-money-check::before {
            content: "\f53c";
        }

        .fa-money-check-dollar::before {
            content: "\f53d";
        }

        .fa-money-check-alt::before {
            content: "\f53d";
        }

        .fa-monument::before {
            content: "\f5a6";
        }

        .fa-moon::before {
            content: "\f186";
        }

        .fa-mortar-pestle::before {
            content: "\f5a7";
        }

        .fa-mosque::before {
            content: "\f678";
        }

        .fa-motorcycle::before {
            content: "\f21c";
        }

        .fa-mountain::before {
            content: "\f6fc";
        }

        .fa-mug-hot::before {
            content: "\f7b6";
        }

        .fa-mug-saucer::before {
            content: "\f0f4";
        }

        .fa-coffee::before {
            content: "\f0f4";
        }

        .fa-music::before {
            content: "\f001";
        }

        .fa-n::before {
            content: "\4e";
        }

        .fa-naira-sign::before {
            content: "\e1f6";
        }

        .fa-network-wired::before {
            content: "\f6ff";
        }

        .fa-neuter::before {
            content: "\f22c";
        }

        .fa-newspaper::before {
            content: "\f1ea";
        }

        .fa-not-equal::before {
            content: "\f53e";
        }

        .fa-note-sticky::before {
            content: "\f249";
        }

        .fa-sticky-note::before {
            content: "\f249";
        }

        .fa-notes-medical::before {
            content: "\f481";
        }

        .fa-o::before {
            content: "\4f";
        }

        .fa-object-group::before {
            content: "\f247";
        }

        .fa-object-ungroup::before {
            content: "\f248";
        }

        .fa-oil-can::before {
            content: "\f613";
        }

        .fa-om::before {
            content: "\f679";
        }

        .fa-otter::before {
            content: "\f700";
        }

        .fa-outdent::before {
            content: "\f03b";
        }

        .fa-dedent::before {
            content: "\f03b";
        }

        .fa-p::before {
            content: "\50";
        }

        .fa-pager::before {
            content: "\f815";
        }

        .fa-paint-brush::before {
            content: "\f1fc";
        }

        .fa-paint-roller::before {
            content: "\f5aa";
        }

        .fa-palette::before {
            content: "\f53f";
        }

        .fa-pallet::before {
            content: "\f482";
        }

        .fa-panorama::before {
            content: "\e209";
        }

        .fa-paper-plane::before {
            content: "\f1d8";
        }

        .fa-paperclip::before {
            content: "\f0c6";
        }

        .fa-parachute-box::before {
            content: "\f4cd";
        }

        .fa-paragraph::before {
            content: "\f1dd";
        }

        .fa-passport::before {
            content: "\f5ab";
        }

        .fa-paste::before {
            content: "\f0ea";
        }

        .fa-file-clipboard::before {
            content: "\f0ea";
        }

        .fa-pause::before {
            content: "\f04c";
        }

        .fa-paw::before {
            content: "\f1b0";
        }

        .fa-peace::before {
            content: "\f67c";
        }

        .fa-pen::before {
            content: "\f304";
        }

        .fa-pen-clip::before {
            content: "\f305";
        }

        .fa-pen-alt::before {
            content: "\f305";
        }

        .fa-pen-fancy::before {
            content: "\f5ac";
        }

        .fa-pen-nib::before {
            content: "\f5ad";
        }

        .fa-pen-ruler::before {
            content: "\f5ae";
        }

        .fa-pencil-ruler::before {
            content: "\f5ae";
        }

        .fa-pen-to-square::before {
            content: "\f044";
        }

        .fa-edit::before {
            content: "\f044";
        }

        .fa-pencil::before {
            content: "\f303";
        }

        .fa-pencil-alt::before {
            content: "\f303";
        }

        .fa-people-arrows-left-right::before {
            content: "\e068";
        }

        .fa-people-arrows::before {
            content: "\e068";
        }

        .fa-people-carry-box::before {
            content: "\f4ce";
        }

        .fa-people-carry::before {
            content: "\f4ce";
        }

        .fa-pepper-hot::before {
            content: "\f816";
        }

        .fa-percent::before {
            content: "\25";
        }

        .fa-percentage::before {
            content: "\25";
        }

        .fa-person::before {
            content: "\f183";
        }

        .fa-male::before {
            content: "\f183";
        }

        .fa-person-biking::before {
            content: "\f84a";
        }

        .fa-biking::before {
            content: "\f84a";
        }

        .fa-person-booth::before {
            content: "\f756";
        }

        .fa-person-dots-from-line::before {
            content: "\f470";
        }

        .fa-diagnoses::before {
            content: "\f470";
        }

        .fa-person-dress::before {
            content: "\f182";
        }

        .fa-female::before {
            content: "\f182";
        }

        .fa-person-hiking::before {
            content: "\f6ec";
        }

        .fa-hiking::before {
            content: "\f6ec";
        }

        .fa-person-praying::before {
            content: "\f683";
        }

        .fa-pray::before {
            content: "\f683";
        }

        .fa-person-running::before {
            content: "\f70c";
        }

        .fa-running::before {
            content: "\f70c";
        }

        .fa-person-skating::before {
            content: "\f7c5";
        }

        .fa-skating::before {
            content: "\f7c5";
        }

        .fa-person-skiing::before {
            content: "\f7c9";
        }

        .fa-skiing::before {
            content: "\f7c9";
        }

        .fa-person-skiing-nordic::before {
            content: "\f7ca";
        }

        .fa-skiing-nordic::before {
            content: "\f7ca";
        }

        .fa-person-snowboarding::before {
            content: "\f7ce";
        }

        .fa-snowboarding::before {
            content: "\f7ce";
        }

        .fa-person-swimming::before {
            content: "\f5c4";
        }

        .fa-swimmer::before {
            content: "\f5c4";
        }

        .fa-person-walking::before {
            content: "\f554";
        }

        .fa-walking::before {
            content: "\f554";
        }

        .fa-person-walking-with-cane::before {
            content: "\f29d";
        }

        .fa-blind::before {
            content: "\f29d";
        }

        .fa-peseta-sign::before {
            content: "\e221";
        }

        .fa-peso-sign::before {
            content: "\e222";
        }

        .fa-phone::before {
            content: "\f095";
        }

        .fa-phone-flip::before {
            content: "\f879";
        }

        .fa-phone-alt::before {
            content: "\f879";
        }

        .fa-phone-slash::before {
            content: "\f3dd";
        }

        .fa-phone-volume::before {
            content: "\f2a0";
        }

        .fa-volume-control-phone::before {
            content: "\f2a0";
        }

        .fa-photo-film::before {
            content: "\f87c";
        }

        .fa-photo-video::before {
            content: "\f87c";
        }

        .fa-piggy-bank::before {
            content: "\f4d3";
        }

        .fa-pills::before {
            content: "\f484";
        }

        .fa-pizza-slice::before {
            content: "\f818";
        }

        .fa-place-of-worship::before {
            content: "\f67f";
        }

        .fa-plane::before {
            content: "\f072";
        }

        .fa-plane-arrival::before {
            content: "\f5af";
        }

        .fa-plane-departure::before {
            content: "\f5b0";
        }

        .fa-plane-slash::before {
            content: "\e069";
        }

        .fa-play::before {
            content: "\f04b";
        }

        .fa-plug::before {
            content: "\f1e6";
        }

        .fa-plus::before {
            content: "\2b";
        }

        .fa-add::before {
            content: "\2b";
        }

        .fa-plus-minus::before {
            content: "\e43c";
        }

        .fa-podcast::before {
            content: "\f2ce";
        }

        .fa-poo::before {
            content: "\f2fe";
        }

        .fa-poo-storm::before {
            content: "\f75a";
        }

        .fa-poo-bolt::before {
            content: "\f75a";
        }

        .fa-poop::before {
            content: "\f619";
        }

        .fa-power-off::before {
            content: "\f011";
        }

        .fa-prescription::before {
            content: "\f5b1";
        }

        .fa-prescription-bottle::before {
            content: "\f485";
        }

        .fa-prescription-bottle-medical::before {
            content: "\f486";
        }

        .fa-prescription-bottle-alt::before {
            content: "\f486";
        }

        .fa-print::before {
            content: "\f02f";
        }

        .fa-pump-medical::before {
            content: "\e06a";
        }

        .fa-pump-soap::before {
            content: "\e06b";
        }

        .fa-puzzle-piece::before {
            content: "\f12e";
        }

        .fa-q::before {
            content: "\51";
        }

        .fa-qrcode::before {
            content: "\f029";
        }

        .fa-question::before {
            content: "\3f";
        }

        .fa-quote-left::before {
            content: "\f10d";
        }

        .fa-quote-left-alt::before {
            content: "\f10d";
        }

        .fa-quote-right::before {
            content: "\f10e";
        }

        .fa-quote-right-alt::before {
            content: "\f10e";
        }

        .fa-r::before {
            content: "\52";
        }

        .fa-radiation::before {
            content: "\f7b9";
        }

        .fa-rainbow::before {
            content: "\f75b";
        }

        .fa-receipt::before {
            content: "\f543";
        }

        .fa-record-vinyl::before {
            content: "\f8d9";
        }

        .fa-rectangle-ad::before {
            content: "\f641";
        }

        .fa-ad::before {
            content: "\f641";
        }

        .fa-rectangle-list::before {
            content: "\f022";
        }

        .fa-list-alt::before {
            content: "\f022";
        }

        .fa-rectangle-xmark::before {
            content: "\f410";
        }

        .fa-rectangle-times::before {
            content: "\f410";
        }

        .fa-times-rectangle::before {
            content: "\f410";
        }

        .fa-window-close::before {
            content: "\f410";
        }

        .fa-recycle::before {
            content: "\f1b8";
        }

        .fa-registered::before {
            content: "\f25d";
        }

        .fa-repeat::before {
            content: "\f363";
        }

        .fa-reply::before {
            content: "\f3e5";
        }

        .fa-mail-reply::before {
            content: "\f3e5";
        }

        .fa-reply-all::before {
            content: "\f122";
        }

        .fa-mail-reply-all::before {
            content: "\f122";
        }

        .fa-republican::before {
            content: "\f75e";
        }

        .fa-restroom::before {
            content: "\f7bd";
        }

        .fa-retweet::before {
            content: "\f079";
        }

        .fa-ribbon::before {
            content: "\f4d6";
        }

        .fa-right-from-bracket::before {
            content: "\f2f5";
        }

        .fa-sign-out-alt::before {
            content: "\f2f5";
        }

        .fa-right-left::before {
            content: "\f362";
        }

        .fa-exchange-alt::before {
            content: "\f362";
        }

        .fa-right-long::before {
            content: "\f30b";
        }

        .fa-long-arrow-alt-right::before {
            content: "\f30b";
        }

        .fa-right-to-bracket::before {
            content: "\f2f6";
        }

        .fa-sign-in-alt::before {
            content: "\f2f6";
        }

        .fa-ring::before {
            content: "\f70b";
        }

        .fa-road::before {
            content: "\f018";
        }

        .fa-robot::before {
            content: "\f544";
        }

        .fa-rocket::before {
            content: "\f135";
        }

        .fa-rotate::before {
            content: "\f2f1";
        }

        .fa-sync-alt::before {
            content: "\f2f1";
        }

        .fa-rotate-left::before {
            content: "\f2ea";
        }

        .fa-rotate-back::before {
            content: "\f2ea";
        }

        .fa-rotate-backward::before {
            content: "\f2ea";
        }

        .fa-undo-alt::before {
            content: "\f2ea";
        }

        .fa-rotate-right::before {
            content: "\f2f9";
        }

        .fa-redo-alt::before {
            content: "\f2f9";
        }

        .fa-rotate-forward::before {
            content: "\f2f9";
        }

        .fa-route::before {
            content: "\f4d7";
        }

        .fa-rss::before {
            content: "\f09e";
        }

        .fa-feed::before {
            content: "\f09e";
        }

        .fa-ruble-sign::before {
            content: "\f158";
        }

        .fa-rouble::before {
            content: "\f158";
        }

        .fa-rub::before {
            content: "\f158";
        }

        .fa-ruble::before {
            content: "\f158";
        }

        .fa-ruler::before {
            content: "\f545";
        }

        .fa-ruler-combined::before {
            content: "\f546";
        }

        .fa-ruler-horizontal::before {
            content: "\f547";
        }

        .fa-ruler-vertical::before {
            content: "\f548";
        }

        .fa-rupee-sign::before {
            content: "\f156";
        }

        .fa-rupee::before {
            content: "\f156";
        }

        .fa-rupiah-sign::before {
            content: "\e23d";
        }

        .fa-s::before {
            content: "\53";
        }

        .fa-sailboat::before {
            content: "\e445";
        }

        .fa-satellite::before {
            content: "\f7bf";
        }

        .fa-satellite-dish::before {
            content: "\f7c0";
        }

        .fa-scale-balanced::before {
            content: "\f24e";
        }

        .fa-balance-scale::before {
            content: "\f24e";
        }

        .fa-scale-unbalanced::before {
            content: "\f515";
        }

        .fa-balance-scale-left::before {
            content: "\f515";
        }

        .fa-scale-unbalanced-flip::before {
            content: "\f516";
        }

        .fa-balance-scale-right::before {
            content: "\f516";
        }

        .fa-school::before {
            content: "\f549";
        }

        .fa-scissors::before {
            content: "\f0c4";
        }

        .fa-cut::before {
            content: "\f0c4";
        }

        .fa-screwdriver::before {
            content: "\f54a";
        }

        .fa-screwdriver-wrench::before {
            content: "\f7d9";
        }

        .fa-tools::before {
            content: "\f7d9";
        }

        .fa-scroll::before {
            content: "\f70e";
        }

        .fa-scroll-torah::before {
            content: "\f6a0";
        }

        .fa-torah::before {
            content: "\f6a0";
        }

        .fa-sd-card::before {
            content: "\f7c2";
        }

        .fa-section::before {
            content: "\e447";
        }

        .fa-seedling::before {
            content: "\f4d8";
        }

        .fa-sprout::before {
            content: "\f4d8";
        }

        .fa-server::before {
            content: "\f233";
        }

        .fa-shapes::before {
            content: "\f61f";
        }

        .fa-triangle-circle-square::before {
            content: "\f61f";
        }

        .fa-share::before {
            content: "\f064";
        }

        .fa-arrow-turn-right::before {
            content: "\f064";
        }

        .fa-mail-forward::before {
            content: "\f064";
        }

        .fa-share-from-square::before {
            content: "\f14d";
        }

        .fa-share-square::before {
            content: "\f14d";
        }

        .fa-share-nodes::before {
            content: "\f1e0";
        }

        .fa-share-alt::before {
            content: "\f1e0";
        }

        .fa-shekel-sign::before {
            content: "\f20b";
        }

        .fa-ils::before {
            content: "\f20b";
        }

        .fa-shekel::before {
            content: "\f20b";
        }

        .fa-sheqel::before {
            content: "\f20b";
        }

        .fa-sheqel-sign::before {
            content: "\f20b";
        }

        .fa-shield::before {
            content: "\f132";
        }

        .fa-shield-blank::before {
            content: "\f3ed";
        }

        .fa-shield-alt::before {
            content: "\f3ed";
        }

        .fa-shield-virus::before {
            content: "\e06c";
        }

        .fa-ship::before {
            content: "\f21a";
        }

        .fa-shirt::before {
            content: "\f553";
        }

        .fa-t-shirt::before {
            content: "\f553";
        }

        .fa-tshirt::before {
            content: "\f553";
        }

        .fa-shoe-prints::before {
            content: "\f54b";
        }

        .fa-shop::before {
            content: "\f54f";
        }

        .fa-store-alt::before {
            content: "\f54f";
        }

        .fa-shop-slash::before {
            content: "\e070";
        }

        .fa-store-alt-slash::before {
            content: "\e070";
        }

        .fa-shower::before {
            content: "\f2cc";
        }

        .fa-shrimp::before {
            content: "\e448";
        }

        .fa-shuffle::before {
            content: "\f074";
        }

        .fa-random::before {
            content: "\f074";
        }

        .fa-shuttle-space::before {
            content: "\f197";
        }

        .fa-space-shuttle::before {
            content: "\f197";
        }

        .fa-sign-hanging::before {
            content: "\f4d9";
        }

        .fa-sign::before {
            content: "\f4d9";
        }

        .fa-signal::before {
            content: "\f012";
        }

        .fa-signal-5::before {
            content: "\f012";
        }

        .fa-signal-perfect::before {
            content: "\f012";
        }

        .fa-signature::before {
            content: "\f5b7";
        }

        .fa-signs-post::before {
            content: "\f277";
        }

        .fa-map-signs::before {
            content: "\f277";
        }

        .fa-sim-card::before {
            content: "\f7c4";
        }

        .fa-sink::before {
            content: "\e06d";
        }

        .fa-sitemap::before {
            content: "\f0e8";
        }

        .fa-skull::before {
            content: "\f54c";
        }

        .fa-skull-crossbones::before {
            content: "\f714";
        }

        .fa-slash::before {
            content: "\f715";
        }

        .fa-sleigh::before {
            content: "\f7cc";
        }

        .fa-sliders::before {
            content: "\f1de";
        }

        .fa-sliders-h::before {
            content: "\f1de";
        }

        .fa-smog::before {
            content: "\f75f";
        }

        .fa-smoking::before {
            content: "\f48d";
        }

        .fa-snowflake::before {
            content: "\f2dc";
        }

        .fa-snowman::before {
            content: "\f7d0";
        }

        .fa-snowplow::before {
            content: "\f7d2";
        }

        .fa-soap::before {
            content: "\e06e";
        }

        .fa-socks::before {
            content: "\f696";
        }

        .fa-solar-panel::before {
            content: "\f5ba";
        }

        .fa-sort::before {
            content: "\f0dc";
        }

        .fa-unsorted::before {
            content: "\f0dc";
        }

        .fa-sort-down::before {
            content: "\f0dd";
        }

        .fa-sort-desc::before {
            content: "\f0dd";
        }

        .fa-sort-up::before {
            content: "\f0de";
        }

        .fa-sort-asc::before {
            content: "\f0de";
        }

        .fa-spa::before {
            content: "\f5bb";
        }

        .fa-spaghetti-monster-flying::before {
            content: "\f67b";
        }

        .fa-pastafarianism::before {
            content: "\f67b";
        }

        .fa-spell-check::before {
            content: "\f891";
        }

        .fa-spider::before {
            content: "\f717";
        }

        .fa-spinner::before {
            content: "\f110";
        }

        .fa-splotch::before {
            content: "\f5bc";
        }

        .fa-spoon::before {
            content: "\f2e5";
        }

        .fa-utensil-spoon::before {
            content: "\f2e5";
        }

        .fa-spray-can::before {
            content: "\f5bd";
        }

        .fa-spray-can-sparkles::before {
            content: "\f5d0";
        }

        .fa-air-freshener::before {
            content: "\f5d0";
        }

        .fa-square::before {
            content: "\f0c8";
        }

        .fa-square-arrow-up-right::before {
            content: "\f14c";
        }

        .fa-external-link-square::before {
            content: "\f14c";
        }

        .fa-square-caret-down::before {
            content: "\f150";
        }

        .fa-caret-square-down::before {
            content: "\f150";
        }

        .fa-square-caret-left::before {
            content: "\f191";
        }

        .fa-caret-square-left::before {
            content: "\f191";
        }

        .fa-square-caret-right::before {
            content: "\f152";
        }

        .fa-caret-square-right::before {
            content: "\f152";
        }

        .fa-square-caret-up::before {
            content: "\f151";
        }

        .fa-caret-square-up::before {
            content: "\f151";
        }

        .fa-square-check::before {
            content: "\f14a";
        }

        .fa-check-square::before {
            content: "\f14a";
        }

        .fa-square-envelope::before {
            content: "\f199";
        }

        .fa-envelope-square::before {
            content: "\f199";
        }

        .fa-square-full::before {
            content: "\f45c";
        }

        .fa-square-h::before {
            content: "\f0fd";
        }

        .fa-h-square::before {
            content: "\f0fd";
        }

        .fa-square-minus::before {
            content: "\f146";
        }

        .fa-minus-square::before {
            content: "\f146";
        }

        .fa-square-parking::before {
            content: "\f540";
        }

        .fa-parking::before {
            content: "\f540";
        }

        .fa-square-pen::before {
            content: "\f14b";
        }

        .fa-pen-square::before {
            content: "\f14b";
        }

        .fa-pencil-square::before {
            content: "\f14b";
        }

        .fa-square-phone::before {
            content: "\f098";
        }

        .fa-phone-square::before {
            content: "\f098";
        }

        .fa-square-phone-flip::before {
            content: "\f87b";
        }

        .fa-phone-square-alt::before {
            content: "\f87b";
        }

        .fa-square-plus::before {
            content: "\f0fe";
        }

        .fa-plus-square::before {
            content: "\f0fe";
        }

        .fa-square-poll-horizontal::before {
            content: "\f682";
        }

        .fa-poll-h::before {
            content: "\f682";
        }

        .fa-square-poll-vertical::before {
            content: "\f681";
        }

        .fa-poll::before {
            content: "\f681";
        }

        .fa-square-root-variable::before {
            content: "\f698";
        }

        .fa-square-root-alt::before {
            content: "\f698";
        }

        .fa-square-rss::before {
            content: "\f143";
        }

        .fa-rss-square::before {
            content: "\f143";
        }

        .fa-square-share-nodes::before {
            content: "\f1e1";
        }

        .fa-share-alt-square::before {
            content: "\f1e1";
        }

        .fa-square-up-right::before {
            content: "\f360";
        }

        .fa-external-link-square-alt::before {
            content: "\f360";
        }

        .fa-square-xmark::before {
            content: "\f2d3";
        }

        .fa-times-square::before {
            content: "\f2d3";
        }

        .fa-xmark-square::before {
            content: "\f2d3";
        }

        .fa-stairs::before {
            content: "\e289";
        }

        .fa-stamp::before {
            content: "\f5bf";
        }

        .fa-star::before {
            content: "\f005";
        }

        .fa-star-and-crescent::before {
            content: "\f699";
        }

        .fa-star-half::before {
            content: "\f089";
        }

        .fa-star-half-stroke::before {
            content: "\f5c0";
        }

        .fa-star-half-alt::before {
            content: "\f5c0";
        }

        .fa-star-of-david::before {
            content: "\f69a";
        }

        .fa-star-of-life::before {
            content: "\f621";
        }

        .fa-sterling-sign::before {
            content: "\f154";
        }

        .fa-gbp::before {
            content: "\f154";
        }

        .fa-pound-sign::before {
            content: "\f154";
        }

        .fa-stethoscope::before {
            content: "\f0f1";
        }

        .fa-stop::before {
            content: "\f04d";
        }

        .fa-stopwatch::before {
            content: "\f2f2";
        }

        .fa-stopwatch-20::before {
            content: "\e06f";
        }

        .fa-store::before {
            content: "\f54e";
        }

        .fa-store-slash::before {
            content: "\e071";
        }

        .fa-street-view::before {
            content: "\f21d";
        }

        .fa-strikethrough::before {
            content: "\f0cc";
        }

        .fa-stroopwafel::before {
            content: "\f551";
        }

        .fa-subscript::before {
            content: "\f12c";
        }

        .fa-suitcase::before {
            content: "\f0f2";
        }

        .fa-suitcase-medical::before {
            content: "\f0fa";
        }

        .fa-medkit::before {
            content: "\f0fa";
        }

        .fa-suitcase-rolling::before {
            content: "\f5c1";
        }

        .fa-sun::before {
            content: "\f185";
        }

        .fa-superscript::before {
            content: "\f12b";
        }

        .fa-swatchbook::before {
            content: "\f5c3";
        }

        .fa-synagogue::before {
            content: "\f69b";
        }

        .fa-syringe::before {
            content: "\f48e";
        }

        .fa-t::before {
            content: "\54";
        }

        .fa-table::before {
            content: "\f0ce";
        }

        .fa-table-cells::before {
            content: "\f00a";
        }

        .fa-th::before {
            content: "\f00a";
        }

        .fa-table-cells-large::before {
            content: "\f009";
        }

        .fa-th-large::before {
            content: "\f009";
        }

        .fa-table-columns::before {
            content: "\f0db";
        }

        .fa-columns::before {
            content: "\f0db";
        }

        .fa-table-list::before {
            content: "\f00b";
        }

        .fa-th-list::before {
            content: "\f00b";
        }

        .fa-table-tennis-paddle-ball::before {
            content: "\f45d";
        }

        .fa-ping-pong-paddle-ball::before {
            content: "\f45d";
        }

        .fa-table-tennis::before {
            content: "\f45d";
        }

        .fa-tablet-button::before {
            content: "\f10a";
        }

        .fa-tablet-screen-button::before {
            content: "\f3fa";
        }

        .fa-tablet-alt::before {
            content: "\f3fa";
        }

        .fa-tablets::before {
            content: "\f490";
        }

        .fa-tachograph-digital::before {
            content: "\f566";
        }

        .fa-digital-tachograph::before {
            content: "\f566";
        }

        .fa-tag::before {
            content: "\f02b";
        }

        .fa-tags::before {
            content: "\f02c";
        }

        .fa-tape::before {
            content: "\f4db";
        }

        .fa-taxi::before {
            content: "\f1ba";
        }

        .fa-cab::before {
            content: "\f1ba";
        }

        .fa-teeth::before {
            content: "\f62e";
        }

        .fa-teeth-open::before {
            content: "\f62f";
        }

        .fa-temperature-empty::before {
            content: "\f2cb";
        }

        .fa-temperature-0::before {
            content: "\f2cb";
        }

        .fa-thermometer-0::before {
            content: "\f2cb";
        }

        .fa-thermometer-empty::before {
            content: "\f2cb";
        }

        .fa-temperature-full::before {
            content: "\f2c7";
        }

        .fa-temperature-4::before {
            content: "\f2c7";
        }

        .fa-thermometer-4::before {
            content: "\f2c7";
        }

        .fa-thermometer-full::before {
            content: "\f2c7";
        }

        .fa-temperature-half::before {
            content: "\f2c9";
        }

        .fa-temperature-2::before {
            content: "\f2c9";
        }

        .fa-thermometer-2::before {
            content: "\f2c9";
        }

        .fa-thermometer-half::before {
            content: "\f2c9";
        }

        .fa-temperature-high::before {
            content: "\f769";
        }

        .fa-temperature-low::before {
            content: "\f76b";
        }

        .fa-temperature-quarter::before {
            content: "\f2ca";
        }

        .fa-temperature-1::before {
            content: "\f2ca";
        }

        .fa-thermometer-1::before {
            content: "\f2ca";
        }

        .fa-thermometer-quarter::before {
            content: "\f2ca";
        }

        .fa-temperature-three-quarters::before {
            content: "\f2c8";
        }

        .fa-temperature-3::before {
            content: "\f2c8";
        }

        .fa-thermometer-3::before {
            content: "\f2c8";
        }

        .fa-thermometer-three-quarters::before {
            content: "\f2c8";
        }

        .fa-tenge-sign::before {
            content: "\f7d7";
        }

        .fa-tenge::before {
            content: "\f7d7";
        }

        .fa-terminal::before {
            content: "\f120";
        }

        .fa-text-height::before {
            content: "\f034";
        }

        .fa-text-slash::before {
            content: "\f87d";
        }

        .fa-remove-format::before {
            content: "\f87d";
        }

        .fa-text-width::before {
            content: "\f035";
        }

        .fa-thermometer::before {
            content: "\f491";
        }

        .fa-thumbs-down::before {
            content: "\f165";
        }

        .fa-thumbs-up::before {
            content: "\f164";
        }

        .fa-thumbtack::before {
            content: "\f08d";
        }

        .fa-thumb-tack::before {
            content: "\f08d";
        }

        .fa-ticket::before {
            content: "\f145";
        }

        .fa-ticket-simple::before {
            content: "\f3ff";
        }

        .fa-ticket-alt::before {
            content: "\f3ff";
        }

        .fa-timeline::before {
            content: "\e29c";
        }

        .fa-toggle-off::before {
            content: "\f204";
        }

        .fa-toggle-on::before {
            content: "\f205";
        }

        .fa-toilet::before {
            content: "\f7d8";
        }

        .fa-toilet-paper::before {
            content: "\f71e";
        }

        .fa-toilet-paper-slash::before {
            content: "\e072";
        }

        .fa-toolbox::before {
            content: "\f552";
        }

        .fa-tooth::before {
            content: "\f5c9";
        }

        .fa-torii-gate::before {
            content: "\f6a1";
        }

        .fa-tower-broadcast::before {
            content: "\f519";
        }

        .fa-broadcast-tower::before {
            content: "\f519";
        }

        .fa-tractor::before {
            content: "\f722";
        }

        .fa-trademark::before {
            content: "\f25c";
        }

        .fa-traffic-light::before {
            content: "\f637";
        }

        .fa-trailer::before {
            content: "\e041";
        }

        .fa-train::before {
            content: "\f238";
        }

        .fa-train-subway::before {
            content: "\f239";
        }

        .fa-subway::before {
            content: "\f239";
        }

        .fa-train-tram::before {
            content: "\f7da";
        }

        .fa-tram::before {
            content: "\f7da";
        }

        .fa-transgender::before {
            content: "\f225";
        }

        .fa-transgender-alt::before {
            content: "\f225";
        }

        .fa-trash::before {
            content: "\f1f8";
        }

        .fa-trash-arrow-up::before {
            content: "\f829";
        }

        .fa-trash-restore::before {
            content: "\f829";
        }

        .fa-trash-can::before {
            content: "\f2ed";
        }

        .fa-trash-alt::before {
            content: "\f2ed";
        }

        .fa-trash-can-arrow-up::before {
            content: "\f82a";
        }

        .fa-trash-restore-alt::before {
            content: "\f82a";
        }

        .fa-tree::before {
            content: "\f1bb";
        }

        .fa-triangle-exclamation::before {
            content: "\f071";
        }

        .fa-exclamation-triangle::before {
            content: "\f071";
        }

        .fa-warning::before {
            content: "\f071";
        }

        .fa-trophy::before {
            content: "\f091";
        }

        .fa-truck::before {
            content: "\f0d1";
        }

        .fa-truck-fast::before {
            content: "\f48b";
        }

        .fa-shipping-fast::before {
            content: "\f48b";
        }

        .fa-truck-medical::before {
            content: "\f0f9";
        }

        .fa-ambulance::before {
            content: "\f0f9";
        }

        .fa-truck-monster::before {
            content: "\f63b";
        }

        .fa-truck-moving::before {
            content: "\f4df";
        }

        .fa-truck-pickup::before {
            content: "\f63c";
        }

        .fa-truck-ramp-box::before {
            content: "\f4de";
        }

        .fa-truck-loading::before {
            content: "\f4de";
        }

        .fa-tty::before {
            content: "\f1e4";
        }

        .fa-teletype::before {
            content: "\f1e4";
        }

        .fa-turkish-lira-sign::before {
            content: "\e2bb";
        }

        .fa-try::before {
            content: "\e2bb";
        }

        .fa-turkish-lira::before {
            content: "\e2bb";
        }

        .fa-turn-down::before {
            content: "\f3be";
        }

        .fa-level-down-alt::before {
            content: "\f3be";
        }

        .fa-turn-up::before {
            content: "\f3bf";
        }

        .fa-level-up-alt::before {
            content: "\f3bf";
        }

        .fa-tv::before {
            content: "\f26c";
        }

        .fa-television::before {
            content: "\f26c";
        }

        .fa-tv-alt::before {
            content: "\f26c";
        }

        .fa-u::before {
            content: "\55";
        }

        .fa-umbrella::before {
            content: "\f0e9";
        }

        .fa-umbrella-beach::before {
            content: "\f5ca";
        }

        .fa-underline::before {
            content: "\f0cd";
        }

        .fa-universal-access::before {
            content: "\f29a";
        }

        .fa-unlock::before {
            content: "\f09c";
        }

        .fa-unlock-keyhole::before {
            content: "\f13e";
        }

        .fa-unlock-alt::before {
            content: "\f13e";
        }

        .fa-up-down::before {
            content: "\f338";
        }

        .fa-arrows-alt-v::before {
            content: "\f338";
        }

        .fa-up-down-left-right::before {
            content: "\f0b2";
        }

        .fa-arrows-alt::before {
            content: "\f0b2";
        }

        .fa-up-long::before {
            content: "\f30c";
        }

        .fa-long-arrow-alt-up::before {
            content: "\f30c";
        }

        .fa-up-right-and-down-left-from-center::before {
            content: "\f424";
        }

        .fa-expand-alt::before {
            content: "\f424";
        }

        .fa-up-right-from-square::before {
            content: "\f35d";
        }

        .fa-external-link-alt::before {
            content: "\f35d";
        }

        .fa-upload::before {
            content: "\f093";
        }

        .fa-user::before {
            content: "\f007";
        }

        .fa-user-astronaut::before {
            content: "\f4fb";
        }

        .fa-user-check::before {
            content: "\f4fc";
        }

        .fa-user-clock::before {
            content: "\f4fd";
        }

        .fa-user-doctor::before {
            content: "\f0f0";
        }

        .fa-user-md::before {
            content: "\f0f0";
        }

        .fa-user-gear::before {
            content: "\f4fe";
        }

        .fa-user-cog::before {
            content: "\f4fe";
        }

        .fa-user-graduate::before {
            content: "\f501";
        }

        .fa-user-group::before {
            content: "\f500";
        }

        .fa-user-friends::before {
            content: "\f500";
        }

        .fa-user-injured::before {
            content: "\f728";
        }

        .fa-user-large::before {
            content: "\f406";
        }

        .fa-user-alt::before {
            content: "\f406";
        }

        .fa-user-large-slash::before {
            content: "\f4fa";
        }

        .fa-user-alt-slash::before {
            content: "\f4fa";
        }

        .fa-user-lock::before {
            content: "\f502";
        }

        .fa-user-minus::before {
            content: "\f503";
        }

        .fa-user-ninja::before {
            content: "\f504";
        }

        .fa-user-nurse::before {
            content: "\f82f";
        }

        .fa-user-pen::before {
            content: "\f4ff";
        }

        .fa-user-edit::before {
            content: "\f4ff";
        }

        .fa-user-plus::before {
            content: "\f234";
        }

        .fa-user-secret::before {
            content: "\f21b";
        }

        .fa-user-shield::before {
            content: "\f505";
        }

        .fa-user-slash::before {
            content: "\f506";
        }

        .fa-user-tag::before {
            content: "\f507";
        }

        .fa-user-tie::before {
            content: "\f508";
        }

        .fa-user-xmark::before {
            content: "\f235";
        }

        .fa-user-times::before {
            content: "\f235";
        }

        .fa-users::before {
            content: "\f0c0";
        }

        .fa-users-gear::before {
            content: "\f509";
        }

        .fa-users-cog::before {
            content: "\f509";
        }

        .fa-users-slash::before {
            content: "\e073";
        }

        .fa-utensils::before {
            content: "\f2e7";
        }

        .fa-cutlery::before {
            content: "\f2e7";
        }

        .fa-v::before {
            content: "\56";
        }

        .fa-van-shuttle::before {
            content: "\f5b6";
        }

        .fa-shuttle-van::before {
            content: "\f5b6";
        }

        .fa-vault::before {
            content: "\e2c5";
        }

        .fa-vector-square::before {
            content: "\f5cb";
        }

        .fa-venus::before {
            content: "\f221";
        }

        .fa-venus-double::before {
            content: "\f226";
        }

        .fa-venus-mars::before {
            content: "\f228";
        }

        .fa-vest::before {
            content: "\e085";
        }

        .fa-vest-patches::before {
            content: "\e086";
        }

        .fa-vial::before {
            content: "\f492";
        }

        .fa-vials::before {
            content: "\f493";
        }

        .fa-video::before {
            content: "\f03d";
        }

        .fa-video-camera::before {
            content: "\f03d";
        }

        .fa-video-slash::before {
            content: "\f4e2";
        }

        .fa-vihara::before {
            content: "\f6a7";
        }

        .fa-virus::before {
            content: "\e074";
        }

        .fa-virus-slash::before {
            content: "\e075";
        }

        .fa-viruses::before {
            content: "\e076";
        }

        .fa-voicemail::before {
            content: "\f897";
        }

        .fa-volleyball::before {
            content: "\f45f";
        }

        .fa-volleyball-ball::before {
            content: "\f45f";
        }

        .fa-volume-high::before {
            content: "\f028";
        }

        .fa-volume-up::before {
            content: "\f028";
        }

        .fa-volume-low::before {
            content: "\f027";
        }

        .fa-volume-down::before {
            content: "\f027";
        }

        .fa-volume-off::before {
            content: "\f026";
        }

        .fa-volume-xmark::before {
            content: "\f6a9";
        }

        .fa-volume-mute::before {
            content: "\f6a9";
        }

        .fa-volume-times::before {
            content: "\f6a9";
        }

        .fa-vr-cardboard::before {
            content: "\f729";
        }

        .fa-w::before {
            content: "\57";
        }

        .fa-wallet::before {
            content: "\f555";
        }

        .fa-wand-magic::before {
            content: "\f0d0";
        }

        .fa-magic::before {
            content: "\f0d0";
        }

        .fa-wand-magic-sparkles::before {
            content: "\e2ca";
        }

        .fa-magic-wand-sparkles::before {
            content: "\e2ca";
        }

        .fa-warehouse::before {
            content: "\f494";
        }

        .fa-water::before {
            content: "\f773";
        }

        .fa-water-ladder::before {
            content: "\f5c5";
        }

        .fa-ladder-water::before {
            content: "\f5c5";
        }

        .fa-swimming-pool::before {
            content: "\f5c5";
        }

        .fa-wave-square::before {
            content: "\f83e";
        }

        .fa-weight-hanging::before {
            content: "\f5cd";
        }

        .fa-weight-scale::before {
            content: "\f496";
        }

        .fa-weight::before {
            content: "\f496";
        }

        .fa-wheelchair::before {
            content: "\f193";
        }

        .fa-whiskey-glass::before {
            content: "\f7a0";
        }

        .fa-glass-whiskey::before {
            content: "\f7a0";
        }

        .fa-wifi::before {
            content: "\f1eb";
        }

        .fa-wifi-3::before {
            content: "\f1eb";
        }

        .fa-wifi-strong::before {
            content: "\f1eb";
        }

        .fa-wind::before {
            content: "\f72e";
        }

        .fa-window-maximize::before {
            content: "\f2d0";
        }

        .fa-window-minimize::before {
            content: "\f2d1";
        }

        .fa-window-restore::before {
            content: "\f2d2";
        }

        .fa-wine-bottle::before {
            content: "\f72f";
        }

        .fa-wine-glass::before {
            content: "\f4e3";
        }

        .fa-wine-glass-empty::before {
            content: "\f5ce";
        }

        .fa-wine-glass-alt::before {
            content: "\f5ce";
        }

        .fa-won-sign::before {
            content: "\f159";
        }

        .fa-krw::before {
            content: "\f159";
        }

        .fa-won::before {
            content: "\f159";
        }

        .fa-wrench::before {
            content: "\f0ad";
        }

        .fa-x::before {
            content: "\58";
        }

        .fa-x-ray::before {
            content: "\f497";
        }

        .fa-xmark::before {
            content: "\f00d";
        }

        .fa-close::before {
            content: "\f00d";
        }

        .fa-multiply::before {
            content: "\f00d";
        }

        .fa-remove::before {
            content: "\f00d";
        }

        .fa-times::before {
            content: "\f00d";
        }

        .fa-y::before {
            content: "\59";
        }

        .fa-yen-sign::before {
            content: "\f157";
        }

        .fa-cny::before {
            content: "\f157";
        }

        .fa-jpy::before {
            content: "\f157";
        }

        .fa-rmb::before {
            content: "\f157";
        }

        .fa-yen::before {
            content: "\f157";
        }

        .fa-yin-yang::before {
            content: "\f6ad";
        }

        .fa-z::before {
            content: "\5a";
        }

        .sr-only,
        .fa-sr-only {
            position: absolute;
            width: 1px;
            height: 1px;
            padding: 0;
            margin: -1px;
            overflow: hidden;
            clip: rect(0, 0, 0, 0);
            white-space: nowrap;
            border-width: 0;
        }

        .sr-only-focusable:not(:focus),
        .fa-sr-only-focusable:not(:focus) {
            position: absolute;
            width: 1px;
            height: 1px;
            padding: 0;
            margin: -1px;
            overflow: hidden;
            clip: rect(0, 0, 0, 0);
            white-space: nowrap;
            border-width: 0;
        }

        :root,
        :host {
            --fa-font-brands: normal 400 1em/1 "Font Awesome 6 Brands";
        }

        @font-face {
            font-family: "Font Awesome 6 Brands";
            font-style: normal;
            font-weight: 400;
            font-display: block;
            src: url("../webfonts/fa-brands-400.woff2") format("woff2"),
                url("../webfonts/fa-brands-400.ttf") format("truetype");
        }

        .fab,
        .fa-brands {
            font-family: "Font Awesome 6 Brands";
            font-weight: 400;
        }

        .fa-42-group:before {
            content: "\e080";
        }

        .fa-innosoft:before {
            content: "\e080";
        }

        .fa-500px:before {
            content: "\f26e";
        }

        .fa-accessible-icon:before {
            content: "\f368";
        }

        .fa-accusoft:before {
            content: "\f369";
        }

        .fa-acquisitions-incorporated:before {
            content: "\f6af";
        }

        .fa-adn:before {
            content: "\f170";
        }

        .fa-adversal:before {
            content: "\f36a";
        }

        .fa-affiliatetheme:before {
            content: "\f36b";
        }

        .fa-airbnb:before {
            content: "\f834";
        }

        .fa-algolia:before {
            content: "\f36c";
        }

        .fa-alipay:before {
            content: "\f642";
        }

        .fa-amazon:before {
            content: "\f270";
        }

        .fa-amazon-pay:before {
            content: "\f42c";
        }

        .fa-amilia:before {
            content: "\f36d";
        }

        .fa-android:before {
            content: "\f17b";
        }

        .fa-angellist:before {
            content: "\f209";
        }

        .fa-angrycreative:before {
            content: "\f36e";
        }

        .fa-angular:before {
            content: "\f420";
        }

        .fa-app-store:before {
            content: "\f36f";
        }

        .fa-app-store-ios:before {
            content: "\f370";
        }

        .fa-apper:before {
            content: "\f371";
        }

        .fa-apple:before {
            content: "\f179";
        }

        .fa-apple-pay:before {
            content: "\f415";
        }

        .fa-artstation:before {
            content: "\f77a";
        }

        .fa-asymmetrik:before {
            content: "\f372";
        }

        .fa-atlassian:before {
            content: "\f77b";
        }

        .fa-audible:before {
            content: "\f373";
        }

        .fa-autoprefixer:before {
            content: "\f41c";
        }

        .fa-avianex:before {
            content: "\f374";
        }

        .fa-aviato:before {
            content: "\f421";
        }

        .fa-aws:before {
            content: "\f375";
        }

        .fa-bandcamp:before {
            content: "\f2d5";
        }

        .fa-battle-net:before {
            content: "\f835";
        }

        .fa-behance:before {
            content: "\f1b4";
        }

        .fa-behance-square:before {
            content: "\f1b5";
        }

        .fa-bilibili:before {
            content: "\e3d9";
        }

        .fa-bimobject:before {
            content: "\f378";
        }

        .fa-bitbucket:before {
            content: "\f171";
        }

        .fa-bitcoin:before {
            content: "\f379";
        }

        .fa-bity:before {
            content: "\f37a";
        }

        .fa-black-tie:before {
            content: "\f27e";
        }

        .fa-blackberry:before {
            content: "\f37b";
        }

        .fa-blogger:before {
            content: "\f37c";
        }

        .fa-blogger-b:before {
            content: "\f37d";
        }

        .fa-bluetooth:before {
            content: "\f293";
        }

        .fa-bluetooth-b:before {
            content: "\f294";
        }

        .fa-bootstrap:before {
            content: "\f836";
        }

        .fa-bots:before {
            content: "\e340";
        }

        .fa-btc:before {
            content: "\f15a";
        }

        .fa-buffer:before {
            content: "\f837";
        }

        .fa-buromobelexperte:before {
            content: "\f37f";
        }

        .fa-buy-n-large:before {
            content: "\f8a6";
        }

        .fa-buysellads:before {
            content: "\f20d";
        }

        .fa-canadian-maple-leaf:before {
            content: "\f785";
        }

        .fa-cc-amazon-pay:before {
            content: "\f42d";
        }

        .fa-cc-amex:before {
            content: "\f1f3";
        }

        .fa-cc-apple-pay:before {
            content: "\f416";
        }

        .fa-cc-diners-club:before {
            content: "\f24c";
        }

        .fa-cc-discover:before {
            content: "\f1f2";
        }

        .fa-cc-jcb:before {
            content: "\f24b";
        }

        .fa-cc-mastercard:before {
            content: "\f1f1";
        }

        .fa-cc-paypal:before {
            content: "\f1f4";
        }

        .fa-cc-stripe:before {
            content: "\f1f5";
        }

        .fa-cc-visa:before {
            content: "\f1f0";
        }

        .fa-centercode:before {
            content: "\f380";
        }

        .fa-centos:before {
            content: "\f789";
        }

        .fa-chrome:before {
            content: "\f268";
        }

        .fa-chromecast:before {
            content: "\f838";
        }

        .fa-cloudflare:before {
            content: "\e07d";
        }

        .fa-cloudscale:before {
            content: "\f383";
        }

        .fa-cloudsmith:before {
            content: "\f384";
        }

        .fa-cloudversify:before {
            content: "\f385";
        }

        .fa-cmplid:before {
            content: "\e360";
        }

        .fa-codepen:before {
            content: "\f1cb";
        }

        .fa-codiepie:before {
            content: "\f284";
        }

        .fa-confluence:before {
            content: "\f78d";
        }

        .fa-connectdevelop:before {
            content: "\f20e";
        }

        .fa-contao:before {
            content: "\f26d";
        }

        .fa-cotton-bureau:before {
            content: "\f89e";
        }

        .fa-cpanel:before {
            content: "\f388";
        }

        .fa-creative-commons:before {
            content: "\f25e";
        }

        .fa-creative-commons-by:before {
            content: "\f4e7";
        }

        .fa-creative-commons-nc:before {
            content: "\f4e8";
        }

        .fa-creative-commons-nc-eu:before {
            content: "\f4e9";
        }

        .fa-creative-commons-nc-jp:before {
            content: "\f4ea";
        }

        .fa-creative-commons-nd:before {
            content: "\f4eb";
        }

        .fa-creative-commons-pd:before {
            content: "\f4ec";
        }

        .fa-creative-commons-pd-alt:before {
            content: "\f4ed";
        }

        .fa-creative-commons-remix:before {
            content: "\f4ee";
        }

        .fa-creative-commons-sa:before {
            content: "\f4ef";
        }

        .fa-creative-commons-sampling:before {
            content: "\f4f0";
        }

        .fa-creative-commons-sampling-plus:before {
            content: "\f4f1";
        }

        .fa-creative-commons-share:before {
            content: "\f4f2";
        }

        .fa-creative-commons-zero:before {
            content: "\f4f3";
        }

        .fa-critical-role:before {
            content: "\f6c9";
        }

        .fa-css3:before {
            content: "\f13c";
        }

        .fa-css3-alt:before {
            content: "\f38b";
        }

        .fa-cuttlefish:before {
            content: "\f38c";
        }

        .fa-d-and-d:before {
            content: "\f38d";
        }

        .fa-d-and-d-beyond:before {
            content: "\f6ca";
        }

        .fa-dailymotion:before {
            content: "\e052";
        }

        .fa-dashcube:before {
            content: "\f210";
        }

        .fa-deezer:before {
            content: "\e077";
        }

        .fa-delicious:before {
            content: "\f1a5";
        }

        .fa-deploydog:before {
            content: "\f38e";
        }

        .fa-deskpro:before {
            content: "\f38f";
        }

        .fa-dev:before {
            content: "\f6cc";
        }

        .fa-deviantart:before {
            content: "\f1bd";
        }

        .fa-dhl:before {
            content: "\f790";
        }

        .fa-diaspora:before {
            content: "\f791";
        }

        .fa-digg:before {
            content: "\f1a6";
        }

        .fa-digital-ocean:before {
            content: "\f391";
        }

        .fa-discord:before {
            content: "\f392";
        }

        .fa-discourse:before {
            content: "\f393";
        }

        .fa-dochub:before {
            content: "\f394";
        }

        .fa-docker:before {
            content: "\f395";
        }

        .fa-draft2digital:before {
            content: "\f396";
        }

        .fa-dribbble:before {
            content: "\f17d";
        }

        .fa-dribbble-square:before {
            content: "\f397";
        }

        .fa-dropbox:before {
            content: "\f16b";
        }

        .fa-drupal:before {
            content: "\f1a9";
        }

        .fa-dyalog:before {
            content: "\f399";
        }

        .fa-earlybirds:before {
            content: "\f39a";
        }

        .fa-ebay:before {
            content: "\f4f4";
        }

        .fa-edge:before {
            content: "\f282";
        }

        .fa-edge-legacy:before {
            content: "\e078";
        }

        .fa-elementor:before {
            content: "\f430";
        }

        .fa-ello:before {
            content: "\f5f1";
        }

        .fa-ember:before {
            content: "\f423";
        }

        .fa-empire:before {
            content: "\f1d1";
        }

        .fa-envira:before {
            content: "\f299";
        }

        .fa-erlang:before {
            content: "\f39d";
        }

        .fa-ethereum:before {
            content: "\f42e";
        }

        .fa-etsy:before {
            content: "\f2d7";
        }

        .fa-evernote:before {
            content: "\f839";
        }

        .fa-expeditedssl:before {
            content: "\f23e";
        }

        .fa-facebook:before {
            content: "\f09a";
        }

        .fa-facebook-f:before {
            content: "\f39e";
        }

        .fa-facebook-messenger:before {
            content: "\f39f";
        }

        .fa-facebook-square:before {
            content: "\f082";
        }

        .fa-fantasy-flight-games:before {
            content: "\f6dc";
        }

        .fa-fedex:before {
            content: "\f797";
        }

        .fa-fedora:before {
            content: "\f798";
        }

        .fa-figma:before {
            content: "\f799";
        }

        .fa-firefox:before {
            content: "\f269";
        }

        .fa-firefox-browser:before {
            content: "\e007";
        }

        .fa-first-order:before {
            content: "\f2b0";
        }

        .fa-first-order-alt:before {
            content: "\f50a";
        }

        .fa-firstdraft:before {
            content: "\f3a1";
        }

        .fa-flickr:before {
            content: "\f16e";
        }

        .fa-flipboard:before {
            content: "\f44d";
        }

        .fa-fly:before {
            content: "\f417";
        }

        .fa-font-awesome:before {
            content: "\f2b4";
        }

        .fa-font-awesome-flag:before {
            content: "\f2b4";
        }

        .fa-font-awesome-logo-full:before {
            content: "\f2b4";
        }

        .fa-fonticons:before {
            content: "\f280";
        }

        .fa-fonticons-fi:before {
            content: "\f3a2";
        }

        .fa-fort-awesome:before {
            content: "\f286";
        }

        .fa-fort-awesome-alt:before {
            content: "\f3a3";
        }

        .fa-forumbee:before {
            content: "\f211";
        }

        .fa-foursquare:before {
            content: "\f180";
        }

        .fa-free-code-camp:before {
            content: "\f2c5";
        }

        .fa-freebsd:before {
            content: "\f3a4";
        }

        .fa-fulcrum:before {
            content: "\f50b";
        }

        .fa-galactic-republic:before {
            content: "\f50c";
        }

        .fa-galactic-senate:before {
            content: "\f50d";
        }

        .fa-get-pocket:before {
            content: "\f265";
        }

        .fa-gg:before {
            content: "\f260";
        }

        .fa-gg-circle:before {
            content: "\f261";
        }

        .fa-git:before {
            content: "\f1d3";
        }

        .fa-git-alt:before {
            content: "\f841";
        }

        .fa-git-square:before {
            content: "\f1d2";
        }

        .fa-github:before {
            content: "\f09b";
        }

        .fa-github-alt:before {
            content: "\f113";
        }

        .fa-github-square:before {
            content: "\f092";
        }

        .fa-gitkraken:before {
            content: "\f3a6";
        }

        .fa-gitlab:before {
            content: "\f296";
        }

        .fa-gitter:before {
            content: "\f426";
        }

        .fa-glide:before {
            content: "\f2a5";
        }

        .fa-glide-g:before {
            content: "\f2a6";
        }

        .fa-gofore:before {
            content: "\f3a7";
        }

        .fa-golang:before {
            content: "\e40f";
        }

        .fa-goodreads:before {
            content: "\f3a8";
        }

        .fa-goodreads-g:before {
            content: "\f3a9";
        }

        .fa-google:before {
            content: "\f1a0";
        }

        .fa-google-drive:before {
            content: "\f3aa";
        }

        .fa-google-pay:before {
            content: "\e079";
        }

        .fa-google-play:before {
            content: "\f3ab";
        }

        .fa-google-plus:before {
            content: "\f2b3";
        }

        .fa-google-plus-g:before {
            content: "\f0d5";
        }

        .fa-google-plus-square:before {
            content: "\f0d4";
        }

        .fa-google-wallet:before {
            content: "\f1ee";
        }

        .fa-gratipay:before {
            content: "\f184";
        }

        .fa-grav:before {
            content: "\f2d6";
        }

        .fa-gripfire:before {
            content: "\f3ac";
        }

        .fa-grunt:before {
            content: "\f3ad";
        }

        .fa-guilded:before {
            content: "\e07e";
        }

        .fa-gulp:before {
            content: "\f3ae";
        }

        .fa-hacker-news:before {
            content: "\f1d4";
        }

        .fa-hacker-news-square:before {
            content: "\f3af";
        }

        .fa-hackerrank:before {
            content: "\f5f7";
        }

        .fa-hips:before {
            content: "\f452";
        }

        .fa-hire-a-helper:before {
            content: "\f3b0";
        }

        .fa-hive:before {
            content: "\e07f";
        }

        .fa-hooli:before {
            content: "\f427";
        }

        .fa-hornbill:before {
            content: "\f592";
        }

        .fa-hotjar:before {
            content: "\f3b1";
        }

        .fa-houzz:before {
            content: "\f27c";
        }

        .fa-html5:before {
            content: "\f13b";
        }

        .fa-hubspot:before {
            content: "\f3b2";
        }

        .fa-ideal:before {
            content: "\e013";
        }

        .fa-imdb:before {
            content: "\f2d8";
        }

        .fa-instagram:before {
            content: "\f16d";
        }

        .fa-instagram-square:before {
            content: "\e055";
        }

        .fa-instalod:before {
            content: "\e081";
        }

        .fa-intercom:before {
            content: "\f7af";
        }

        .fa-internet-explorer:before {
            content: "\f26b";
        }

        .fa-invision:before {
            content: "\f7b0";
        }

        .fa-ioxhost:before {
            content: "\f208";
        }

        .fa-itch-io:before {
            content: "\f83a";
        }

        .fa-itunes:before {
            content: "\f3b4";
        }

        .fa-itunes-note:before {
            content: "\f3b5";
        }

        .fa-java:before {
            content: "\f4e4";
        }

        .fa-jedi-order:before {
            content: "\f50e";
        }

        .fa-jenkins:before {
            content: "\f3b6";
        }

        .fa-jira:before {
            content: "\f7b1";
        }

        .fa-joget:before {
            content: "\f3b7";
        }

        .fa-joomla:before {
            content: "\f1aa";
        }

        .fa-js:before {
            content: "\f3b8";
        }

        .fa-js-square:before {
            content: "\f3b9";
        }

        .fa-jsfiddle:before {
            content: "\f1cc";
        }

        .fa-kaggle:before {
            content: "\f5fa";
        }

        .fa-keybase:before {
            content: "\f4f5";
        }

        .fa-keycdn:before {
            content: "\f3ba";
        }

        .fa-kickstarter:before {
            content: "\f3bb";
        }

        .fa-kickstarter-k:before {
            content: "\f3bc";
        }

        .fa-korvue:before {
            content: "\f42f";
        }

        .fa-laravel:before {
            content: "\f3bd";
        }

        .fa-lastfm:before {
            content: "\f202";
        }

        .fa-lastfm-square:before {
            content: "\f203";
        }

        .fa-leanpub:before {
            content: "\f212";
        }

        .fa-less:before {
            content: "\f41d";
        }

        .fa-line:before {
            content: "\f3c0";
        }

        .fa-linkedin:before {
            content: "\f08c";
        }

        .fa-linkedin-in:before {
            content: "\f0e1";
        }

        .fa-linode:before {
            content: "\f2b8";
        }

        .fa-linux:before {
            content: "\f17c";
        }

        .fa-lyft:before {
            content: "\f3c3";
        }

        .fa-magento:before {
            content: "\f3c4";
        }

        .fa-mailchimp:before {
            content: "\f59e";
        }

        .fa-mandalorian:before {
            content: "\f50f";
        }

        .fa-markdown:before {
            content: "\f60f";
        }

        .fa-mastodon:before {
            content: "\f4f6";
        }

        .fa-maxcdn:before {
            content: "\f136";
        }

        .fa-mdb:before {
            content: "\f8ca";
        }

        .fa-medapps:before {
            content: "\f3c6";
        }

        .fa-medium:before {
            content: "\f23a";
        }

        .fa-medium-m:before {
            content: "\f23a";
        }

        .fa-medrt:before {
            content: "\f3c8";
        }

        .fa-meetup:before {
            content: "\f2e0";
        }

        .fa-megaport:before {
            content: "\f5a3";
        }

        .fa-mendeley:before {
            content: "\f7b3";
        }

        .fa-microblog:before {
            content: "\e01a";
        }

        .fa-microsoft:before {
            content: "\f3ca";
        }

        .fa-mix:before {
            content: "\f3cb";
        }

        .fa-mixcloud:before {
            content: "\f289";
        }

        .fa-mixer:before {
            content: "\e056";
        }

        .fa-mizuni:before {
            content: "\f3cc";
        }

        .fa-modx:before {
            content: "\f285";
        }

        .fa-monero:before {
            content: "\f3d0";
        }

        .fa-napster:before {
            content: "\f3d2";
        }

        .fa-neos:before {
            content: "\f612";
        }

        .fa-nimblr:before {
            content: "\f5a8";
        }

        .fa-node:before {
            content: "\f419";
        }

        .fa-node-js:before {
            content: "\f3d3";
        }

        .fa-npm:before {
            content: "\f3d4";
        }

        .fa-ns8:before {
            content: "\f3d5";
        }

        .fa-nutritionix:before {
            content: "\f3d6";
        }

        .fa-octopus-deploy:before {
            content: "\e082";
        }

        .fa-odnoklassniki:before {
            content: "\f263";
        }

        .fa-odnoklassniki-square:before {
            content: "\f264";
        }

        .fa-old-republic:before {
            content: "\f510";
        }

        .fa-opencart:before {
            content: "\f23d";
        }

        .fa-openid:before {
            content: "\f19b";
        }

        .fa-opera:before {
            content: "\f26a";
        }

        .fa-optin-monster:before {
            content: "\f23c";
        }

        .fa-orcid:before {
            content: "\f8d2";
        }

        .fa-osi:before {
            content: "\f41a";
        }

        .fa-page4:before {
            content: "\f3d7";
        }

        .fa-pagelines:before {
            content: "\f18c";
        }

        .fa-palfed:before {
            content: "\f3d8";
        }

        .fa-patreon:before {
            content: "\f3d9";
        }

        .fa-paypal:before {
            content: "\f1ed";
        }

        .fa-penny-arcade:before {
            content: "\f704";
        }

        .fa-perbyte:before {
            content: "\e083";
        }

        .fa-periscope:before {
            content: "\f3da";
        }

        .fa-phabricator:before {
            content: "\f3db";
        }

        .fa-phoenix-framework:before {
            content: "\f3dc";
        }

        .fa-phoenix-squadron:before {
            content: "\f511";
        }

        .fa-php:before {
            content: "\f457";
        }

        .fa-pied-piper:before {
            content: "\f2ae";
        }

        .fa-pied-piper-alt:before {
            content: "\f1a8";
        }

        .fa-pied-piper-hat:before {
            content: "\f4e5";
        }

        .fa-pied-piper-pp:before {
            content: "\f1a7";
        }

        .fa-pied-piper-square:before {
            content: "\e01e";
        }

        .fa-pinterest:before {
            content: "\f0d2";
        }

        .fa-pinterest-p:before {
            content: "\f231";
        }

        .fa-pinterest-square:before {
            content: "\f0d3";
        }

        .fa-pix:before {
            content: "\e43a";
        }

        .fa-playstation:before {
            content: "\f3df";
        }

        .fa-product-hunt:before {
            content: "\f288";
        }

        .fa-pushed:before {
            content: "\f3e1";
        }

        .fa-python:before {
            content: "\f3e2";
        }

        .fa-qq:before {
            content: "\f1d6";
        }

        .fa-quinscape:before {
            content: "\f459";
        }

        .fa-quora:before {
            content: "\f2c4";
        }

        .fa-r-project:before {
            content: "\f4f7";
        }

        .fa-raspberry-pi:before {
            content: "\f7bb";
        }

        .fa-ravelry:before {
            content: "\f2d9";
        }

        .fa-react:before {
            content: "\f41b";
        }

        .fa-reacteurope:before {
            content: "\f75d";
        }

        .fa-readme:before {
            content: "\f4d5";
        }

        .fa-rebel:before {
            content: "\f1d0";
        }

        .fa-red-river:before {
            content: "\f3e3";
        }

        .fa-reddit:before {
            content: "\f1a1";
        }

        .fa-reddit-alien:before {
            content: "\f281";
        }

        .fa-reddit-square:before {
            content: "\f1a2";
        }

        .fa-redhat:before {
            content: "\f7bc";
        }

        .fa-renren:before {
            content: "\f18b";
        }

        .fa-replyd:before {
            content: "\f3e6";
        }

        .fa-researchgate:before {
            content: "\f4f8";
        }

        .fa-resolving:before {
            content: "\f3e7";
        }

        .fa-rev:before {
            content: "\f5b2";
        }

        .fa-rocketchat:before {
            content: "\f3e8";
        }

        .fa-rockrms:before {
            content: "\f3e9";
        }

        .fa-rust:before {
            content: "\e07a";
        }

        .fa-safari:before {
            content: "\f267";
        }

        .fa-salesforce:before {
            content: "\f83b";
        }

        .fa-sass:before {
            content: "\f41e";
        }

        .fa-schlix:before {
            content: "\f3ea";
        }

        .fa-scribd:before {
            content: "\f28a";
        }

        .fa-searchengin:before {
            content: "\f3eb";
        }

        .fa-sellcast:before {
            content: "\f2da";
        }

        .fa-sellsy:before {
            content: "\f213";
        }

        .fa-servicestack:before {
            content: "\f3ec";
        }

        .fa-shirtsinbulk:before {
            content: "\f214";
        }

        .fa-shopify:before {
            content: "\e057";
        }

        .fa-shopware:before {
            content: "\f5b5";
        }

        .fa-simplybuilt:before {
            content: "\f215";
        }

        .fa-sistrix:before {
            content: "\f3ee";
        }

        .fa-sith:before {
            content: "\f512";
        }

        .fa-sitrox:before {
            content: "\e44a";
        }

        .fa-sketch:before {
            content: "\f7c6";
        }

        .fa-skyatlas:before {
            content: "\f216";
        }

        .fa-skype:before {
            content: "\f17e";
        }

        .fa-slack:before {
            content: "\f198";
        }

        .fa-slack-hash:before {
            content: "\f198";
        }

        .fa-slideshare:before {
            content: "\f1e7";
        }

        .fa-snapchat:before {
            content: "\f2ab";
        }

        .fa-snapchat-ghost:before {
            content: "\f2ab";
        }

        .fa-snapchat-square:before {
            content: "\f2ad";
        }

        .fa-soundcloud:before {
            content: "\f1be";
        }

        .fa-sourcetree:before {
            content: "\f7d3";
        }

        .fa-speakap:before {
            content: "\f3f3";
        }

        .fa-speaker-deck:before {
            content: "\f83c";
        }

        .fa-spotify:before {
            content: "\f1bc";
        }

        .fa-square-font-awesome:before {
            content: "\f425";
        }

        .fa-square-font-awesome-stroke:before {
            content: "\f35c";
        }

        .fa-font-awesome-alt:before {
            content: "\f35c";
        }

        .fa-squarespace:before {
            content: "\f5be";
        }

        .fa-stack-exchange:before {
            content: "\f18d";
        }

        .fa-stack-overflow:before {
            content: "\f16c";
        }

        .fa-stackpath:before {
            content: "\f842";
        }

        .fa-staylinked:before {
            content: "\f3f5";
        }

        .fa-steam:before {
            content: "\f1b6";
        }

        .fa-steam-square:before {
            content: "\f1b7";
        }

        .fa-steam-symbol:before {
            content: "\f3f6";
        }

        .fa-sticker-mule:before {
            content: "\f3f7";
        }

        .fa-strava:before {
            content: "\f428";
        }

        .fa-stripe:before {
            content: "\f429";
        }

        .fa-stripe-s:before {
            content: "\f42a";
        }

        .fa-studiovinari:before {
            content: "\f3f8";
        }

        .fa-stumbleupon:before {
            content: "\f1a4";
        }

        .fa-stumbleupon-circle:before {
            content: "\f1a3";
        }

        .fa-superpowers:before {
            content: "\f2dd";
        }

        .fa-supple:before {
            content: "\f3f9";
        }

        .fa-suse:before {
            content: "\f7d6";
        }

        .fa-swift:before {
            content: "\f8e1";
        }

        .fa-symfony:before {
            content: "\f83d";
        }

        .fa-teamspeak:before {
            content: "\f4f9";
        }

        .fa-telegram:before {
            content: "\f2c6";
        }

        .fa-telegram-plane:before {
            content: "\f2c6";
        }

        .fa-tencent-weibo:before {
            content: "\f1d5";
        }

        .fa-the-red-yeti:before {
            content: "\f69d";
        }

        .fa-themeco:before {
            content: "\f5c6";
        }

        .fa-themeisle:before {
            content: "\f2b2";
        }

        .fa-think-peaks:before {
            content: "\f731";
        }

        .fa-tiktok:before {
            content: "\e07b";
        }

        .fa-trade-federation:before {
            content: "\f513";
        }

        .fa-trello:before {
            content: "\f181";
        }

        .fa-tumblr:before {
            content: "\f173";
        }

        .fa-tumblr-square:before {
            content: "\f174";
        }

        .fa-twitch:before {
            content: "\f1e8";
        }

        .fa-twitter:before {
            content: "\f099";
        }

        .fa-twitter-square:before {
            content: "\f081";
        }

        .fa-typo3:before {
            content: "\f42b";
        }

        .fa-uber:before {
            content: "\f402";
        }

        .fa-ubuntu:before {
            content: "\f7df";
        }

        .fa-uikit:before {
            content: "\f403";
        }

        .fa-umbraco:before {
            content: "\f8e8";
        }

        .fa-uncharted:before {
            content: "\e084";
        }

        .fa-uniregistry:before {
            content: "\f404";
        }

        .fa-unity:before {
            content: "\e049";
        }

        .fa-unsplash:before {
            content: "\e07c";
        }

        .fa-untappd:before {
            content: "\f405";
        }

        .fa-ups:before {
            content: "\f7e0";
        }

        .fa-usb:before {
            content: "\f287";
        }

        .fa-usps:before {
            content: "\f7e1";
        }

        .fa-ussunnah:before {
            content: "\f407";
        }

        .fa-vaadin:before {
            content: "\f408";
        }

        .fa-viacoin:before {
            content: "\f237";
        }

        .fa-viadeo:before {
            content: "\f2a9";
        }

        .fa-viadeo-square:before {
            content: "\f2aa";
        }

        .fa-viber:before {
            content: "\f409";
        }

        .fa-vimeo:before {
            content: "\f40a";
        }

        .fa-vimeo-square:before {
            content: "\f194";
        }

        .fa-vimeo-v:before {
            content: "\f27d";
        }

        .fa-vine:before {
            content: "\f1ca";
        }

        .fa-vk:before {
            content: "\f189";
        }

        .fa-vnv:before {
            content: "\f40b";
        }

        .fa-vuejs:before {
            content: "\f41f";
        }

        .fa-watchman-monitoring:before {
            content: "\e087";
        }

        .fa-waze:before {
            content: "\f83f";
        }

        .fa-weebly:before {
            content: "\f5cc";
        }

        .fa-weibo:before {
            content: "\f18a";
        }

        .fa-weixin:before {
            content: "\f1d7";
        }

        .fa-whatsapp:before {
            content: "\f232";
        }

        .fa-whatsapp-square:before {
            content: "\f40c";
        }

        .fa-whmcs:before {
            content: "\f40d";
        }

        .fa-wikipedia-w:before {
            content: "\f266";
        }

        .fa-windows:before {
            content: "\f17a";
        }

        .fa-wirsindhandwerk:before {
            content: "\e2d0";
        }

        .fa-wsh:before {
            content: "\e2d0";
        }

        .fa-wix:before {
            content: "\f5cf";
        }

        .fa-wizards-of-the-coast:before {
            content: "\f730";
        }

        .fa-wodu:before {
            content: "\e088";
        }

        .fa-wolf-pack-battalion:before {
            content: "\f514";
        }

        .fa-wordpress:before {
            content: "\f19a";
        }

        .fa-wordpress-simple:before {
            content: "\f411";
        }

        .fa-wpbeginner:before {
            content: "\f297";
        }

        .fa-wpexplorer:before {
            content: "\f2de";
        }

        .fa-wpforms:before {
            content: "\f298";
        }

        .fa-wpressr:before {
            content: "\f3e4";
        }

        .fa-xbox:before {
            content: "\f412";
        }

        .fa-xing:before {
            content: "\f168";
        }

        .fa-xing-square:before {
            content: "\f169";
        }

        .fa-y-combinator:before {
            content: "\f23b";
        }

        .fa-yahoo:before {
            content: "\f19e";
        }

        .fa-yammer:before {
            content: "\f840";
        }

        .fa-yandex:before {
            content: "\f413";
        }

        .fa-yandex-international:before {
            content: "\f414";
        }

        .fa-yarn:before {
            content: "\f7e3";
        }

        .fa-yelp:before {
            content: "\f1e9";
        }

        .fa-yoast:before {
            content: "\f2b1";
        }

        .fa-youtube:before {
            content: "\f167";
        }

        .fa-youtube-square:before {
            content: "\f431";
        }

        .fa-zhihu:before {
            content: "\f63f";
        }

        :root,
        :host {
            --fa-font-regular: normal 400 1em/1 "Font Awesome 6 Free";
        }

        @font-face {
            font-family: "Font Awesome 6 Free";
            font-style: normal;
            font-weight: 400;
            font-display: block;
            src: url("../webfonts/fa-regular-400.woff2") format("woff2"),
                url("../webfonts/fa-regular-400.ttf") format("truetype");
        }

        .far,
        .fa-regular {
            font-family: "Font Awesome 6 Free";
            font-weight: 400;
        }

        :root,
        :host {
            --fa-font-solid: normal 900 1em/1 "Font Awesome 6 Free";
        }

        @font-face {
            font-family: "Font Awesome 6 Free";
            font-style: normal;
            font-weight: 900;
            font-display: block;
            src: url("../webfonts/fa-solid-900.woff2") format("woff2"),
                url("../webfonts/fa-solid-900.ttf") format("truetype");
        }

        .fas,
        .fa-solid {
            font-family: "Font Awesome 6 Free";
            font-weight: 900;
        }

        @font-face {
            font-family: "Font Awesome 5 Brands";
            font-display: block;
            font-weight: 400;
            src: url("../webfonts/fa-brands-400.woff2") format("woff2"),
                url("../webfonts/fa-brands-400.ttf") format("truetype");
        }

        @font-face {
            font-family: "Font Awesome 5 Free";
            font-display: block;
            font-weight: 900;
            src: url("../webfonts/fa-solid-900.woff2") format("woff2"),
                url("../webfonts/fa-solid-900.ttf") format("truetype");
        }

        @font-face {
            font-family: "Font Awesome 5 Free";
            font-display: block;
            font-weight: 400;
            src: url("../webfonts/fa-regular-400.woff2") format("woff2"),
                url("../webfonts/fa-regular-400.ttf") format("truetype");
        }

        @font-face {
            font-family: "FontAwesome";
            font-display: block;
            src: url("../webfonts/fa-solid-900.woff2") format("woff2"),
                url("../webfonts/fa-solid-900.ttf") format("truetype");
        }

        @font-face {
            font-family: "FontAwesome";
            font-display: block;
            src: url("../webfonts/fa-brands-400.woff2") format("woff2"),
                url("../webfonts/fa-brands-400.ttf") format("truetype");
        }

        @font-face {
            font-family: "FontAwesome";
            font-display: block;
            src: url("../webfonts/fa-regular-400.woff2") format("woff2"),
                url("../webfonts/fa-regular-400.ttf") format("truetype");
            unicode-range: U+F003, U+F006, U+F014, U+F016-F017, U+F01A-F01B, U+F01D,
                U+F022, U+F03E, U+F044, U+F046, U+F05C-F05D, U+F06E, U+F070,
                U+F087-F088, U+F08A, U+F094, U+F096-F097, U+F09D, U+F0A0, U+F0A2,
                U+F0A4-F0A7, U+F0C5, U+F0C7, U+F0E5-F0E6, U+F0EB, U+F0F6-F0F8, U+F10C,
                U+F114-F115, U+F118-F11A, U+F11C-F11D, U+F133, U+F147, U+F14E,
                U+F150-F152, U+F185-F186, U+F18E, U+F190-F192, U+F196, U+F1C1-F1C9,
                U+F1D9, U+F1DB, U+F1E3, U+F1EA, U+F1F7, U+F1F9, U+F20A, U+F247-F248,
                U+F24A, U+F24D, U+F255-F25B, U+F25D, U+F271-F274, U+F278, U+F27B,
                U+F28C, U+F28E, U+F29C, U+F2B5, U+F2B7, U+F2BA, U+F2BC, U+F2BE,
                U+F2C0-F2C1, U+F2C3, U+F2D0, U+F2D2, U+F2D4, U+F2DC;
        }

        @font-face {
            font-family: "FontAwesome";
            font-display: block;
            src: url("../webfonts/fa-v4compatibility.woff2") format("woff2"),
                url("../webfonts/fa-v4compatibility.ttf") format("truetype");
            unicode-range: U+F041, U+F047, U+F065-F066, U+F07D-F07E, U+F080, U+F08B,
                U+F08E, U+F090, U+F09A, U+F0AC, U+F0AE, U+F0B2, U+F0D0, U+F0D6, U+F0E4,
                U+F0EC, U+F10A-F10B, U+F123, U+F13E, U+F148-F149, U+F14C, U+F156,
                U+F15E, U+F160-F161, U+F163, U+F175-F178, U+F195, U+F1F8, U+F219,
                U+F250, U+F252, U+F27A;
        }
    </style>
    <!-- Custom CSS -->
    <style>
        /* CSS Custom */
        body {
            background: #f2f2f2;
        }

        section {
            position: relative;
            display: flex;
            background: var(--2-background-2-light-grey, #f5f6f7);
        }

        /* Begin style Welcome */

        #welcomeSec {
            display: block;
            padding: 30px 0;
            background: linear-gradient(135deg, #faf2eb 0.43%, #ebdaca 99.49%),
                linear-gradient(127deg, #ededed 0.43%, #dfdddd 99.49%);
            text-align: center;
        }

        #welcomeIntro {
            margin: 20px 0 10px;
        }

        #welcomeTitle {
            margin: 10px auto;
        }

        ul.box-setup {
            list-style: none;
            display: flex;
            align-items: start;
            justify-content: center;
            margin: 10px 0;
            padding-inline-start: 0;
        }

        li.box-setup-item {
            margin: 0 10px;
        }

        .font-15 {
            font-size: 15px;
        }

        p.box-setup-item-des {
            width: 83px;
            line-height: 16px;
            font-size: 13px;
        }

        a#btn-setup-apple-pay {
            background-color: #000;
            color: #fff;
            text-decoration: none;
            border-radius: 35px;
            padding: 12px 0;
            display: block;
            margin: 30px 35px 0px;
            font-size: 12px;
        }

        a#btn-setup-apple-pay:hover {
            background-color: #00003a;
        }

        /* Begin Box What you need */
        #box-what-you-need,
        #box-you-want-to-know,
        #let-started,
        #let-use {
            background-color: #fff;
            padding-top: 30px;
            padding-bottom: 30px;
        }

        #let-use {
            border-bottom: 8px solid #f5f5f5;
        }

        #let-started {
            border-top: 8px solid #f5f5f5;
            border-bottom: 8px solid #f5f5f5;
        }

        .header-content-collapse .btn {
            color: #a2a2a2;
            padding: 5px 0;
            width: 50%;
        }

        .header-content-collapse .btn.active {
            color: #000;
            background-color: #fff;
            border-radius: 12px;
        }

        /* Begin style slideshow */
        .swiper {
            /* width: 343px; */
        }

        .wrap-slide {
            border-radius: 12px;
            margin-top: 10px;
            min-height: 430px;
        }

        #let-started .card {
            position: relative;
            background: none;
            border: none;
            /* border-radius: 20px; */
            margin: 20px 0;
            /* box-shadow: 0 5px 10px rgba(0, 0, 0, 0.1); */
        }

        #let-started .card::before {
            content: "";
            position: absolute;
            height: 40%;
            width: 100%;
            border-radius: 20px 20px 0 0;
        }

        #let-started .card .card-content {
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 30px;
            position: relative;
            z-index: 100;
        }

        .content-slide-card {
            margin: 20px;
        }

        #let-started section .card .image {
            height: 140px;
            width: 140px;
            border-radius: 50%;
            padding: 3px;
            background: #7d2ae8;
        }

        #let-started section .card .image img {
            height: 100%;
            width: 100%;
            object-fit: cover;
            border-radius: 50%;
            border: 3px solid #fff;
        }

        #let-started .card .media-icons {
            position: absolute;
            top: 10px;
            right: 20px;
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        #let-started .card .media-icons i {
            color: #fff;
            opacity: 0.6;
            margin-top: 10px;
            transition: all 0.3s ease;
            cursor: pointer;
        }

        #let-started .card .media-icons i:hover {
            opacity: 1;
        }

        #let-started .card .name-profession {
            display: flex;
            flex-direction: column;
            align-items: center;
            margin-top: 10px;
        }

        .name-profession .name {
            font-size: 20px;
            font-weight: 600;
        }

        .name-profession .profession {
            font-size: 15px;
            font-weight: 500;
        }

        .swiper-pagination {
            position: absolute;
        }

        .swiper-pagination-bullet {
            height: 8px;
            width: 8px;
            border-radius: 50%;
            background: #000000;
        }

        .swiper-button-next,
        .swiper-button-prev {
            opacity: 0.7;
            transition: all 0.3s ease;
        }

        .swiper-button-next:hover,
        .swiper-button-prev:hover {
            opacity: 1;
        }

        .swiper-button-disabled {
            display: none;
        }

        /* Modal */
        .modal-header,
        .modal-footer {
            border: none;
        }

        .modal-header .close {
            margin: -1rem;
        }

        .modal-footer {
            justify-content: center;
        }

        .hr-modal-footer {
            width: 45%;
            height: 5px;
            background-color: #000;
            border-radius: 5px;
        }

        .modal-body ul {
            padding-inline-start: 20px;
        }
    </style>
</head>

<body>
    <!-- Box welcome -->
    <div class="container-fluid" id="welcomeSec">
        <div class="col-md-12">
            <!-- Begin Box Welcome -->

            <div>
                <img src="https://media.techcombank.com/uploads/apple-pay-setup-979f42dbd7.png" width="100%"
                    alt="Setup Apple pay" />
            </div>
            <div>
                <p id="welcomeIntro" class="font-15" style="font-weight: 600">
                    Introducing Apple Pay
                </p>
                <h3 id="welcomeTitle">Turn your iPhone into your Techcombank card</h3>
                <ul class="box-setup">
                    <li class="box-setup-item">
                        <svg xmlns="http://www.w3.org/2000/svg" width="49" height="48" viewBox="0 0 49 48" fill="none">
                            <path
                                d="M21.5158 28.1333L17.2791 23.8805L17.2791 23.8805L17.278 23.8795C17.0704 23.6831 16.8226 23.5816 16.537 23.5759C16.2486 23.5703 15.9914 23.6821 15.7671 23.9064C15.5593 24.1141 15.4544 24.3626 15.4544 24.6494C15.4544 24.9362 15.5593 25.1847 15.7671 25.3924L20.6278 30.2791C20.6279 30.2792 20.628 30.2793 20.6282 30.2794C20.8786 30.5409 21.1752 30.6735 21.5158 30.6735C21.8563 30.6735 22.1529 30.5409 22.4033 30.2795C22.4035 30.2794 22.4036 30.2792 22.4037 30.2791L32.1746 20.5244L32.1746 20.5244L32.1755 20.5235C32.3884 20.2994 32.4994 20.0432 32.505 19.7564C32.5107 19.468 32.3989 19.2108 32.1746 18.9865L32.1747 18.9865L32.1731 18.9851C31.948 18.778 31.6866 18.6778 31.3912 18.6869C31.0968 18.6959 30.8444 18.8047 30.6367 19.0124L21.5158 28.1333ZM17.7768 38.7861C19.7251 39.6288 21.8006 40.05 24.0028 40.05C26.2223 40.05 28.3087 39.6286 30.2615 38.7856C32.2135 37.9429 33.9119 36.792 35.3564 35.3328C36.8006 33.8739 37.9439 32.1705 38.7861 30.2232C39.6288 28.2749 40.05 26.1994 40.05 23.9972C40.05 21.7777 39.6286 19.6913 38.7856 17.7385C37.9429 15.7866 36.7991 14.0882 35.3541 12.6438C33.909 11.1994 32.2099 10.0561 30.2572 9.21388C28.3035 8.3712 26.2166 7.95 23.9972 7.95C21.795 7.95 19.7199 8.37141 17.7724 9.21446C15.826 10.0571 14.1234 11.2008 12.665 12.6458C11.2066 14.0908 10.0562 15.79 9.21388 17.7428C8.37121 19.6965 7.95 21.7834 7.95 24.0028C7.95 26.205 8.37141 28.2801 9.21446 30.2276C10.0571 32.1741 11.208 33.8768 12.667 35.3351C14.126 36.7935 15.8294 37.9438 17.7768 38.7861ZM33.95 33.9372C31.2238 36.6721 27.9081 38.0391 24 38.0391C20.1092 38.0391 16.7978 36.6721 14.0629 33.9371C11.3279 31.2022 9.96091 27.8908 9.96091 24C9.96091 20.0919 11.3279 16.7762 14.0628 14.05C16.7978 11.3236 20.1092 9.96091 24 9.96091C27.9081 9.96091 31.2238 11.3237 33.9501 14.0499C36.6763 16.7762 38.0391 20.0919 38.0391 24C38.0391 27.8908 36.6764 31.2022 33.95 33.9372Z"
                                fill="black" stroke="black" stroke-width="0.1" />
                        </svg>
                        <p id="box-setup-item-1" class="box-setup-item-des">
                            Set up in seconds
                        </p>
                    </li>
                    <li class="box-setup-item">
                        <svg xmlns="http://www.w3.org/2000/svg" width="49" height="48" viewBox="0 0 49 48" fill="none">
                            <path
                                d="M20.7824 38.1409L33.3243 23.2557H24.8937L26.5389 10.3442L15.2152 26.5635H22.4462L20.7824 38.1409ZM18.0007 42L19.932 28.732H11L26.9141 6H29.2909L27.3782 21.0873H38L20.3775 42H18.0007Z"
                                fill="black" />
                        </svg>
                        <p id="box-setup-item-2" class="box-setup-item-des">
                            Pay securely with FaceID or TouchID
                        </p>
                    </li>
                    <li class="box-setup-item">
                        <svg xmlns="http://www.w3.org/2000/svg" width="49" height="48" viewBox="0 0 49 48" fill="none">
                            <path d="M2 15V34C2 36.2091 3.79086 38 6 38H27.5" stroke="black" stroke-width="2" />
                            <path d="M39 16H40V15V12C40 9.23858 37.7614 7 35 7H7C4.23858 7 2 9.23858 2 12V15V16H3H39Z"
                                stroke="black" stroke-width="2" />
                            <path d="M39 18H40V17V12C40 9.23858 37.7614 7 35 7H7C4.23858 7 2 9.23858 2 12V17V18H3H39Z"
                                stroke="black" stroke-width="2" />
                            <path
                                d="M45.7885 24.1437L39.0643 22.166C38.6959 22.0576 38.3041 22.0576 37.9357 22.166L31.2115 24.1437C30.4924 24.3552 30 25.002 30 25.738V33.9444C30 36.7222 35.037 42 38.5 42C41.963 42 47 36.7222 47 33.9444V25.738C47 25.002 46.5076 24.3552 45.7885 24.1437Z"
                                stroke="black" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" />
                        </svg>
                        <p id="box-setup-item-3" class="box-setup-item-des">
                            Card number never shared
                        </p>
                    </li>
                </ul>
                <a href="#" id="btn-setup-apple-pay">Set up Apple Pay</a>
            </div>
        </div>
    </div>

    <!-- Box What you'll need -->
    <div class="container-fluid" id="box-what-you-need">
        <h3 id="title-what-you-need">What you’ll need</h3>
        <p id="des-what-you-need" class="font-15" style="font-weight: 300; color: #616161">
            To get started with Apple Pay, you will need
        </p>
        <div class="mb-4">
            <div class="row no-gutters">
                <div class="col-2">
                    <svg xmlns="http://www.w3.org/2000/svg" width="44" height="44" viewBox="0 0 44 44" fill="none">
                        <circle cx="22" cy="22" r="22" fill="#F5F6F7" />
                        <rect x="9.5" y="13.5" width="25" height="17" rx="2.5" fill="#819498" stroke="black" />
                        <path
                            d="M27.9994 25.9986L28.9977 24.9997L27.9994 24L26 25.9986L27.9994 28L28.9977 27.0021L27.9994 25.9986Z"
                            fill="white" />
                        <path
                            d="M30.0004 24L32 25.9986L30.0004 28L28.9977 27.0021L30.0004 25.9986L28.9977 24.9997L30.0004 24Z"
                            fill="white" />
                    </svg>
                </div>
                <div class="col-10">
                    <h6 class="card-title mb-1" id="what-you-need-visa-card">
                        A Techcombank Visa Card
                    </h6>
                    <button type="button" class="btn btn-link p-0" id="des-what-you-need-visa-card" data-toggle="modal"
                        data-target="#modalSupportedCard">
                        See supported cards
                    </button>
                </div>
            </div>
        </div>
        <div class="mb-1">
            <div class="row no-gutters">
                <div class="col-2">
                    <svg xmlns="http://www.w3.org/2000/svg" width="44" height="44" viewBox="0 0 44 44" fill="none">
                        <circle cx="22" cy="22" r="22" fill="#F5F6F7" />
                        <mask id="mask0_7611_28269" style="mask-type: alpha" maskUnits="userSpaceOnUse" x="0" y="0"
                            width="44" height="44">
                            <circle cx="22" cy="22" r="22" fill="#F5F6F7" />
                        </mask>
                        <g mask="url(#mask0_7611_28269)">
                            <rect x="12" y="16" width="20" height="37" rx="3" fill="black" />
                            <rect x="13" y="17" width="18" height="36" rx="2" fill="#819498" />
                        </g>
                    </svg>
                </div>
                <div class="col-10">
                    <h6 class="card-title mb-1" id="what-you-need-apple-device">
                        A compatible Apple device
                    </h6>
                    <button type="button" class="btn btn-link p-0" id="des-what-you-need-device" data-toggle="modal"
                        data-target="#modalSupportedDevice">
                        See supported devices
                    </button>
                </div>
            </div>
        </div>
    </div>
    <!-- Begin Box Let's get started -->
    <div class="container-fluid" id="let-started">
        <h3 id="title-let-started">Let's get started!</h3>
        <p id="des-let-started" class="font-15" style="font-weight: 300; color: #616161">
            Follow 1 of the 2 methods below to add your card through this app or
            Apple Wallet
        </p>
        <!-- Handle display content -->
        <div class="content-collapse">
            <div class="header-content-collapse d-flex justify-content-between"
                style="background-color: #f2f2f2; padding: 3px; border-radius: 12px">
                <button class="btn active" id="btn-techcombank" type="button"
                    onclick="handleActiveBtnSetup('techcombank')">
                    <img src="https://media.techcombank.com/uploads/apple-pay-icon-tcb-20ab01c014.png" width="20"
                        alt="Techcombank" style="margin-right: 5px" />Techcombank
                </button>
                <button class="btn" id="btn-apple-wallet" type="button" onclick="handleActiveBtnSetup('appleWallet')">
                    <img src="https://media.techcombank.com/uploads/apple-wallet-icon-6f721bbd2b.png" width="20"
                        alt="Techcombank" style="margin-right: 5px" />Apple Wallet
                </button>
            </div>
        </div>
        <div id="slide-techcombank" class="d-block">
            <!-- Begin Slideshow -->
            <section class="wrap-slide">
                <div id="mySwiper1" class="swiper mySwiper container">
                    <div class="swiper-wrapper content">
                        <div class="swiper-slide card">
                            <img src="https://media.techcombank.com/uploads/setup-techcombank-1-712d8af6d5.png"
                                width="100%" alt="" />
                            <div class="content-slide-card">
                                <h3 id="setup-select-card-title-1">Select a card</h3>
                                <p style="color: #616161; font-size: 17px; font-weight: 300"
                                    id="setup-select-card-des-1">
                                    Tap on “Select a card" and choose a card to be added to
                                    Apple Pay
                                </p>
                            </div>
                        </div>
                        <div class="swiper-slide card">
                            <img src="https://media.techcombank.com/uploads/setup-techcombank-2-6499121862.png"
                                width="100%" alt="" />
                            <div class="content-slide-card">
                                <h3 id="setup-select-card-title-2">Follow the instruction</h3>
                                <p style="color: #616161; font-size: 17px; font-weight: 300"
                                    id="setup-select-card-des-2">
                                    Tap Add to Apple Wallet and follow the on-screen instruction
                                </p>
                            </div>
                        </div>
                    </div>
                </div>
                <div class="swiper-button-next" id="swiper-button-next-1">
                    <img src="https://media.techcombank.com/uploads/apple-pay-icon-next-89d494a990.png" height="48"
                        alt="" />
                </div>
                <div class="swiper-button-prev" id="swiper-button-prev-1">
                    <img src="https://media.techcombank.com/uploads/apple-pay-icon-pre-d95d2e996d.png" height="48"
                        alt="" />
                </div>
                <div class="swiper-pagination" id="swiper-pagination-1"></div>
            </section>
        </div>
        <div id="silde-apple-wallet" class="d-none">
            <!-- Begin Slideshow -->
            <section class="wrap-slide">
                <div id="mySwiper2" class="swiper mySwiper container">
                    <div class="swiper-wrapper content">
                        <div class="swiper-slide card">
                            <img src="https://media.techcombank.com/uploads/setup-wallet-1-b26090f4ff.png" width="100%"
                                alt="" />
                            <div class="content-slide-card">
                                <h3 id="setup-open-apple-wallet-1">Open Apple Wallet</h3>
                                <p style="color: #616161; font-size: 17px; font-weight: 300"
                                    id="setup-open-wallet-des-1">
                                    Tap the (+) sign at the top right corner to add your card
                                </p>
                            </div>
                        </div>
                        <div class="swiper-slide card">
                            <img src="https://media.techcombank.com/uploads/setup-wallet-2-e6e4488959.png" width="100%"
                                alt="" />
                            <div class="content-slide-card">
                                <h3 id="setup-open-apple-wallet-2">Follow the instruction</h3>
                                <p style="color: #616161; font-size: 17px; font-weight: 300"
                                    id="setup-open-wallet-des-2">
                                    Scan or enter your card information and follow the on-screen
                                    instruction
                                </p>
                            </div>
                        </div>
                    </div>
                </div>
                <div class="swiper-button-next" id="swiper-button-next-2">
                    <img src="https://media.techcombank.com/uploads/apple-pay-icon-next-89d494a990.png" height="48"
                        alt="" />
                </div>
                <div class="swiper-button-prev" id="swiper-button-prev-2">
                    <img src="https://media.techcombank.com/uploads/apple-pay-icon-pre-d95d2e996d.png" height="48"
                        alt="" />
                </div>
                <div class="swiper-pagination" id="swiper-pagination-2"></div>
            </section>
        </div>
    </div>

    <!-- Begin Box Let Use -->
    <div class="container-fluid" id="let-use">
        <h3 id="title-let-use">Use Apple Pay easily and securely</h3>
        <p id="des-let-use" class="font-15" style="font-weight: 300; color: #616161">
            After setting up Apple Pay, you can pay wherever you see one of these
            symbols:
        </p>
        <div class="mb-3">
            <img src="https://media.techcombank.com/uploads/apple-wifi-icon-7d4ddbe9fe.png" alt="" width="48" />
            <img src="https://media.techcombank.com/uploads/apple-pay-icon-07e1779934.png" alt="" width="43"
                class="ml-1" />
        </div>
        <!-- Handle display content -->
        <div class="content-collapse">
            <div class="header-content-collapse d-flex justify-content-between"
                style="background-color: #f2f2f2; padding: 3px; border-radius: 12px">
                <button class="btn active" type="button" id="btn-techcombank-1"
                    onclick="handleActiveBtnEasily('withPhone')">
                    With Phone
                </button>
                <button class="btn" id="btn-apple-wallet-1" type="button" onclick="handleActiveBtnEasily('withWatch')">
                    With Apple Watch
                </button>
            </div>
        </div>

        <!-- Box With Phone Touch ID -->
        <div id="slide-with-phone" class="d-block">
            <!-- Begin Slideshow -->
            <section class="wrap-slide">
                <div id="mySwiper3" class="swiper mySwiper container">
                    <div class="swiper-wrapper content">
                        <div class="swiper-slide card">
                            <img src="https://media.techcombank.com/uploads/pay-touch-id-1-b8d2e4d88b.png" width="100%"
                                alt="" class="d-block" id="img-touch-id" />
                            <div class="content-slide-card d-block" id="des-touch-id">
                                <h3 id="setup-with-phone-touch-id-title-1">
                                    Double-click the Home button
                                </h3>
                                <p style="color: #616161; font-size: 17px; font-weight: 300"
                                    id="setup-with-phone-touch-id-des-1">
                                    And it's ready to pay
                                </p>
                            </div>
                            <img src="https://media.techcombank.com/uploads/pay-face-id-1-810a5f77e3.png" width="100%"
                                alt="" class="d-none" id="img-face-id" />
                            <div class="content-slide-card d-none" id="des-face-id">
                                <h3 id="setup-with-phone-face-id-title-1">
                                    Double-click the Side button
                                </h3>
                                <p style="color: #616161; font-size: 17px; font-weight: 300"
                                    id="setup-with-phone-face-id-des-1">
                                    And glance at the screen to authenticate
                                </p>
                            </div>
                        </div>
                        <div class="swiper-slide card">
                            <img src="https://media.techcombank.com/uploads/pay-touch-id-2-ffcdea75c9.png" width="100%"
                                alt="" />
                            <div class="content-slide-card">
                                <h3 id="setup-with-phone-touch-id-title-2">Tap to pay</h3>
                                <p style="color: #616161; font-size: 17px; font-weight: 300"
                                    id="setup-with-phone-touch-id-des-2">
                                    Hold the top of your iPhone near the card reader
                                </p>
                            </div>
                        </div>
                        <div class="swiper-slide card">
                            <img src="https://media.techcombank.com/uploads/pay-touch-id-3-97c051aead.png" width="100%"
                                alt="" />
                            <div class="content-slide-card">
                                <h3 id="setup-with-phone-touch-id-title-3">
                                    And you're done!
                                </h3>
                                <p style="color: #616161; font-size: 17px; font-weight: 300"
                                    id="setup-with-phone-touch-id-des-3">
                                    Wait for the “Done" checkmark and you are done
                                </p>
                            </div>
                        </div>
                    </div>
                </div>
                <div class="swiper-button-next" id="swiper-button-next-3">
                    <img src="https://media.techcombank.com/uploads/apple-pay-icon-next-89d494a990.png" height="48"
                        alt="" />
                </div>
                <div class="swiper-button-prev" id="swiper-button-prev-3">
                    <img src="https://media.techcombank.com/uploads/apple-pay-icon-pre-d95d2e996d.png" height="48"
                        alt="" />
                </div>
                <div class="swiper-pagination" id="swiper-pagination-3"></div>
            </section>
        </div>

        <!-- Box With Apple Watch -->
        <div id="slide-with-apple-watch" class="d-none">
            <!-- Begin Slideshow -->
            <section class="wrap-slide">
                <div id="mySwiper4" class="swiper mySwiper container">
                    <div class="swiper-wrapper content">
                        <div class="swiper-slide card">
                            <img src="https://media.techcombank.com/uploads/pay-watch-1-c15f11d831.png" width="100%"
                                alt="" />
                            <div class="content-slide-card">
                                <h3 id="setup-with-apple-watch-title-1">
                                    Double-click the Side button
                                </h3>
                                <p style="color: #616161; font-size: 17px; font-weight: 300"
                                    id="setup-with-apple-watch-des-1">
                                    And it's ready to pay
                                </p>
                            </div>
                        </div>
                        <div class="swiper-slide card">
                            <img src="https://media.techcombank.com/uploads/pay-watch-2-8554959048.png" width="100%"
                                alt="" />
                            <div class="content-slide-card">
                                <h3 id="setup-with-apple-watch-title-2">Tap to pay</h3>
                                <p style="color: #616161; font-size: 17px; font-weight: 300"
                                    id="setup-with-apple-watch-des-2">
                                    Hold the top of your iPhone near the card reader
                                </p>
                            </div>
                        </div>
                        <div class="swiper-slide card">
                            <img src="https://media.techcombank.com/uploads/pay-watch-3-04d8baa44d.png" width="100%"
                                alt="" />
                            <div class="content-slide-card">
                                <h3 id="setup-with-apple-watch-title-3">And you're done!</h3>
                                <p style="color: #616161; font-size: 17px; font-weight: 300"
                                    id="setup-with-apple-watch-des-3">
                                    Wait for the “Done" checkmark and you are done
                                </p>
                            </div>
                        </div>
                    </div>
                </div>
                <div class="swiper-button-next" id="swiper-button-next-4">
                    <img src="https://media.techcombank.com/uploads/apple-pay-icon-next-89d494a990.png" height="48"
                        alt="" />
                </div>
                <div class="swiper-button-prev" id="swiper-button-prev-4">
                    <img src="https://media.techcombank.com/uploads/apple-pay-icon-pre-d95d2e996d.png" height="48"
                        alt="" />
                </div>
                <div class="swiper-pagination" id="swiper-pagination-4"></div>
            </section>
        </div>
    </div>

    <!-- Begin Box You might want to know -->
    <div class="container-fluid" id="box-you-want-to-know">
        <h3 id="title-want-to-know" class="mb-4">You might want to know</h3>
        <div class="mb-3 pb-3" style="border-bottom: 1px solid #dedede" data-toggle="modal" data-target="#modalWhere">
            <div class="row no-gutters d-flex align-items-center">
                <div class="col-1">
                    <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none">
                        <path
                            d="M11.9951 11.4542C12.4093 11.4542 12.7451 11.79 12.7451 12.2042V16.6232C12.7451 17.0374 12.4093 17.3732 11.9951 17.3732C11.5809 17.3732 11.2451 17.0374 11.2451 16.6232V12.2042C11.2451 11.79 11.5809 11.4542 11.9951 11.4542Z"
                            fill="#616161" />
                        <path
                            d="M11.9951 7.70422C11.4428 7.70422 10.9951 8.15194 10.9951 8.70422C10.9951 9.25651 11.4428 9.70422 11.9951 9.70422H12.0051C12.5574 9.70422 13.0051 9.25651 13.0051 8.70422C13.0051 8.15194 12.5574 7.70422 12.0051 7.70422H11.9951Z"
                            fill="#616161" />
                        <path fill-rule="evenodd" clip-rule="evenodd"
                            d="M1.25 12C1.25 6.06254 6.06254 1.25 12 1.25C17.9363 1.25 22.75 6.06249 22.75 12C22.75 17.9364 17.9364 22.75 12 22.75C6.06249 22.75 1.25 17.9363 1.25 12ZM12 2.75C6.89097 2.75 2.75 6.89097 2.75 12C2.75 17.108 6.89102 21.25 12 21.25C17.108 21.25 21.25 17.1079 21.25 12C21.25 6.89102 17.108 2.75 12 2.75Z"
                            fill="#616161" />
                    </svg>
                </div>
                <div class="col-10">
                    <p class="font-15 mb-0 pl-2" id="want-to-know-where">
                        Where can I use Apple Pay?
                    </p>
                </div>
                <div class="col-1 d-flex justify-content-end">
                    <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none">
                        <path fill-rule="evenodd" clip-rule="evenodd"
                            d="M9.15506 16.8488C8.94831 16.6473 8.94831 16.3205 9.15506 16.1189L13.7219 11.6667L9.15506 7.21442C8.94831 7.01286 8.94831 6.68606 9.15506 6.4845C9.36181 6.28294 9.69701 6.28294 9.90376 6.4845L14.8449 11.3017C15.0517 11.5033 15.0517 11.8301 14.8449 12.0316L9.90376 16.8488C9.69701 17.0504 9.36181 17.0504 9.15506 16.8488Z"
                            fill="#C5C5C5" stroke="#C5C5C5" stroke-width="0.4" stroke-linecap="round"
                            stroke-linejoin="round" />
                    </svg>
                </div>
            </div>
        </div>
        <div class="mb-3 pb-3" style="border-bottom: 1px solid #dedede" data-toggle="modal"
            data-target="#modalWhatCard">
            <div class="row no-gutters d-flex align-items-center">
                <div class="col-1">
                    <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none">
                        <path
                            d="M11.9951 11.4542C12.4093 11.4542 12.7451 11.79 12.7451 12.2042V16.6232C12.7451 17.0374 12.4093 17.3732 11.9951 17.3732C11.5809 17.3732 11.2451 17.0374 11.2451 16.6232V12.2042C11.2451 11.79 11.5809 11.4542 11.9951 11.4542Z"
                            fill="#616161" />
                        <path
                            d="M11.9951 7.70422C11.4428 7.70422 10.9951 8.15194 10.9951 8.70422C10.9951 9.25651 11.4428 9.70422 11.9951 9.70422H12.0051C12.5574 9.70422 13.0051 9.25651 13.0051 8.70422C13.0051 8.15194 12.5574 7.70422 12.0051 7.70422H11.9951Z"
                            fill="#616161" />
                        <path fill-rule="evenodd" clip-rule="evenodd"
                            d="M1.25 12C1.25 6.06254 6.06254 1.25 12 1.25C17.9363 1.25 22.75 6.06249 22.75 12C22.75 17.9364 17.9364 22.75 12 22.75C6.06249 22.75 1.25 17.9363 1.25 12ZM12 2.75C6.89097 2.75 2.75 6.89097 2.75 12C2.75 17.108 6.89102 21.25 12 21.25C17.108 21.25 21.25 17.1079 21.25 12C21.25 6.89102 17.108 2.75 12 2.75Z"
                            fill="#616161" />
                    </svg>
                </div>
                <div class="col-10">
                    <p class="font-15 mb-0 pl-2" id="want-to-know-what-card">
                        What should I do if I lose my card?
                    </p>
                </div>
                <div class="col-1 d-flex justify-content-end">
                    <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none">
                        <path fill-rule="evenodd" clip-rule="evenodd"
                            d="M9.15506 16.8488C8.94831 16.6473 8.94831 16.3205 9.15506 16.1189L13.7219 11.6667L9.15506 7.21442C8.94831 7.01286 8.94831 6.68606 9.15506 6.4845C9.36181 6.28294 9.69701 6.28294 9.90376 6.4845L14.8449 11.3017C15.0517 11.5033 15.0517 11.8301 14.8449 12.0316L9.90376 16.8488C9.69701 17.0504 9.36181 17.0504 9.15506 16.8488Z"
                            fill="#C5C5C5" stroke="#C5C5C5" stroke-width="0.4" stroke-linecap="round"
                            stroke-linejoin="round" />
                    </svg>
                </div>
            </div>
        </div>
        <div class="mb-3 pb-3" style="border-bottom: 1px solid #dedede" data-toggle="modal"
            data-target="#modalWhatDevice">
            <div class="row no-gutters d-flex align-items-center">
                <div class="col-1">
                    <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none">
                        <path
                            d="M11.9951 11.4542C12.4093 11.4542 12.7451 11.79 12.7451 12.2042V16.6232C12.7451 17.0374 12.4093 17.3732 11.9951 17.3732C11.5809 17.3732 11.2451 17.0374 11.2451 16.6232V12.2042C11.2451 11.79 11.5809 11.4542 11.9951 11.4542Z"
                            fill="#616161" />
                        <path
                            d="M11.9951 7.70422C11.4428 7.70422 10.9951 8.15194 10.9951 8.70422C10.9951 9.25651 11.4428 9.70422 11.9951 9.70422H12.0051C12.5574 9.70422 13.0051 9.25651 13.0051 8.70422C13.0051 8.15194 12.5574 7.70422 12.0051 7.70422H11.9951Z"
                            fill="#616161" />
                        <path fill-rule="evenodd" clip-rule="evenodd"
                            d="M1.25 12C1.25 6.06254 6.06254 1.25 12 1.25C17.9363 1.25 22.75 6.06249 22.75 12C22.75 17.9364 17.9364 22.75 12 22.75C6.06249 22.75 1.25 17.9363 1.25 12ZM12 2.75C6.89097 2.75 2.75 6.89097 2.75 12C2.75 17.108 6.89102 21.25 12 21.25C17.108 21.25 21.25 17.1079 21.25 12C21.25 6.89102 17.108 2.75 12 2.75Z"
                            fill="#616161" />
                    </svg>
                </div>
                <div class="col-10">
                    <p class="font-15 mb-0 pl-2" id="want-to-know-what-device">
                        What should I do if I lose my device?
                    </p>
                </div>
                <div class="col-1 d-flex justify-content-end">
                    <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none">
                        <path fill-rule="evenodd" clip-rule="evenodd"
                            d="M9.15506 16.8488C8.94831 16.6473 8.94831 16.3205 9.15506 16.1189L13.7219 11.6667L9.15506 7.21442C8.94831 7.01286 8.94831 6.68606 9.15506 6.4845C9.36181 6.28294 9.69701 6.28294 9.90376 6.4845L14.8449 11.3017C15.0517 11.5033 15.0517 11.8301 14.8449 12.0316L9.90376 16.8488C9.69701 17.0504 9.36181 17.0504 9.15506 16.8488Z"
                            fill="#C5C5C5" stroke="#C5C5C5" stroke-width="0.4" stroke-linecap="round"
                            stroke-linejoin="round" />
                    </svg>
                </div>
            </div>
        </div>
    </div>

    <!-- Modal Supported Card-->
    <div class="modal fade" id="modalSupportedCard" tabindex="-1" role="dialog"
        aria-labelledby="modalSupportedCardLabel" aria-hidden="true">
        <div class="modal-dialog modal-dialog-centered" role="document">
            <div class="modal-content">
                <div class="modal-header">
                    <button type="button" class="close" data-dismiss="modal" aria-label="Close">
                        <span aria-hidden="true">&times;</span>
                    </button>
                </div>
                <div class="modal-body">
                    <h4 id="titleModalSupportCard">
                        Which types of card support Apple Pay?
                    </h4>
                    <p id="desModalSupportCardOne" style="color: #212121">
                        You can use Techcombank Visa Debit and Credit cards with Apple
                        Pay.
                    </p>
                    <p id="desModalSupportCardTwo" style="color: #212121">
                        To check if your card is eligible, look for the first 6 digits on
                        your card. If they are one of the following, your card is
                        supported:
                    </p>
                    <ul style="color: #212121">
                        <li>422150</li>
                        <li>478097</li>
                        <li>457353</li>
                        <li>403280</li>
                        <li>422076</li>
                        <li>422075</li>
                        <li>483931</li>
                    </ul>
                    <p id="desModalSupportCardThree" style="color: #212121">
                        We're expanding this list. If you don't find your card, check back
                        later.
                    </p>
                </div>
                <div class="modal-footer d-flex align-content-center">
                    <div class="hr-modal-footer"></div>
                </div>
            </div>
        </div>
    </div>

    <!-- Modal Supported Device -->
    <div class="modal fade" id="modalSupportedDevice" tabindex="-1" role="dialog"
        aria-labelledby="modalSupportedDeviceLabel" aria-hidden="true">
        <div class="modal-dialog modal-dialog-centered" role="document">
            <div class="modal-content">
                <div class="modal-header">
                    <button type="button" class="close" data-dismiss="modal" aria-label="Close">
                        <span aria-hidden="true">&times;</span>
                    </button>
                </div>
                <div class="modal-body">
                    <h4 id="titleModalSupportDevice">
                        Which types of device support Apple Pay?
                    </h4>
                    <p id="desModalSupportDeviceOne" style="color: #212121">
                        Apple Pay is supported by:
                    </p>
                    <ul style="color: #212121">
                        <li id="liSupportedDeviceFace">
                            iPhone or iPad with Touch/Face ID (except iPhone 5s)
                        </li>
                        <li id="liSupportedDeviceWatch">
                            Apple Watch (Series 1 and later)
                        </li>
                        <li id="liSupportedDeviceMac">Mac models with Touch ID</li>
                    </ul>
                    <a href="#" id="linkSupportedDevice">Learn more</a>
                </div>
                <div class="modal-footer d-flex align-content-center">
                    <div class="hr-modal-footer"></div>
                </div>
            </div>
        </div>
    </div>

    <!-- Modal Where -->
    <div class="modal fade" id="modalWhere" tabindex="-1" role="dialog" aria-labelledby="modalWhereLabel"
        aria-hidden="true">
        <div class="modal-dialog modal-dialog-centered" role="document">
            <div class="modal-content">
                <div class="modal-header">
                    <button type="button" class="close" data-dismiss="modal" aria-label="Close">
                        <span aria-hidden="true">&times;</span>
                    </button>
                </div>
                <div class="modal-body">
                    <h4 id="titleModalWhere">Where can I use Apple Pay?</h4>
                    <p id="desModalWhereOne" style="color: #212121">
                        With Apple Pay, you can leave your physical wallet at home. Just
                        use your iPhone, iPad or Apple Watch to pay at any store that
                        accepts contactless payments.
                    </p>
                    <p id="desModalWhereTwo" style="color: #212121">
                        More and more brands are supporting Apple Pay, so add your card to
                        stay ahead of this trend.
                    </p>
                    <a href="#" id="linkWhereModal">See supported stores</a>
                </div>
                <div class="modal-footer d-flex align-content-center">
                    <div class="hr-modal-footer"></div>
                </div>
            </div>
        </div>
    </div>

    <!-- Modal What Card -->
    <div class="modal fade" id="modalWhatCard" tabindex="-1" role="dialog" aria-labelledby="modalWhatCardLabel"
        aria-hidden="true">
        <div class="modal-dialog modal-dialog-centered" role="document">
            <div class="modal-content">
                <div class="modal-header">
                    <button type="button" class="close" data-dismiss="modal" aria-label="Close">
                        <span aria-hidden="true">&times;</span>
                    </button>
                </div>
                <div class="modal-body">
                    <h4 id="titleModalWhatCard">What should I do if I lose my card?</h4>
                    <p id="desModalWhatCardOne" style="color: #212121">
                        If you lose your card, contact us at 1800 588 822. We'll help you
                        lock the card to protect your information and money.
                    </p>
                </div>
                <div class="modal-footer d-flex align-content-center">
                    <div class="hr-modal-footer"></div>
                </div>
            </div>
        </div>
    </div>
    <!-- Modal What Device -->
    <div class="modal fade" id="modalWhatDevice" tabindex="-1" role="dialog" aria-labelledby="modalWhatDeviceLabel"
        aria-hidden="true">
        <div class="modal-dialog modal-dialog-centered" role="document">
            <div class="modal-content">
                <div class="modal-header">
                    <button type="button" class="close" data-dismiss="modal" aria-label="Close">
                        <span aria-hidden="true">&times;</span>
                    </button>
                </div>
                <div class="modal-body">
                    <h4 id="titleModalWhatDevice">
                        What should I do if I lose my device?
                    </h4>
                    <p id="desModalWhatDeviceOne" style="color: #212121">
                        If you lose your device or think it may have been stolen, sign in
                        to iCloud.com/Find or use Find My app on another Apple device that
                        you own to look for it on a map.
                    </p>

                    <p id="desModalWhatDeviceTwo" style="color: #212121">
                        To remotely lock your missing device and disable Apple Pay on it,
                        you can mark the device as lost on iCloud or the Find My app.
                    </p>

                    <p id="desModalWhatDeviceThree" style="color: #212121">
                        For direct support, please contact our Techcombank hotline 1800
                        588 822.
                    </p>
                    <a href="#" id="linkWhatDecice">Learn more</a>
                </div>
                <div class="modal-footer d-flex align-content-center">
                    <div class="hr-modal-footer"></div>
                </div>
            </div>
        </div>
    </div>
    <!-- Content JS -->
    <script>
        const queryString = window.location.search;
        const urlParams = new URLSearchParams(queryString);

        const welcomeSec = document.getElementById("welcomeSec");
        const btnSetupApplePay = document.getElementById("btn-setup-apple-pay");

        const encodeUrlAppleSupport = "https%3A%2F%2Fsupport.apple.com";
        // Apple Pay Supported device
        const viUrlSupportDevice = "&url=https%3A%2F%2Fsupport.apple.com%2Fvi-vn%2FHT208531";
        const enUrlSupportDevice = "&url=https%3A%2F%2Fsupport.apple.com%2Fen-us%2FHT201472";
        // If I lost my device
        const viLostDevice = "&url=https%3A%2F%2Fsupport.apple.com%2Fvi-vn%2FHT201472";
        const enLostDevice = "&url=https%3A%2F%2Fsupport.apple.com%2Fen-us%2FHT201472";

        // Element Language box welcome
        const welcomeIntro = document.getElementById("welcomeIntro");
        const welcomeTitle = document.getElementById("welcomeTitle");
        const boxSetupItem1 = document.getElementById("box-setup-item-1");
        const boxSetupItem2 = document.getElementById("box-setup-item-2");
        const boxSetupItem3 = document.getElementById("box-setup-item-3");

        // Element Language box what you will need
        const titleWhatYouNeed = document.getElementById("title-what-you-need");
        const desWwhatYyouNeed = document.getElementById("des-what-you-need");
        const whatYouNeedVisaCard = document.getElementById("what-you-need-visa-card");
        const desWhatYouNeedVisaCard = document.getElementById("des-what-you-need-visa-card");
        const whatYouNeedAppleDevice = document.getElementById("what-you-need-apple-device");
        const desWhatYouNeedAppleDevice = document.getElementById("des-what-you-need-device");

        // Element Language box let's started
        const titleLetStarted = document.getElementById("title-let-started");
        const desLetStarted = document.getElementById("des-let-started");

        // Element Language box easily
        const titleLetUse = document.getElementById("title-let-use");
        const desLetUse = document.getElementById("des-let-use");

        // Element language box want to know
        const titleWantToKnow = document.getElementById("title-want-to-know");
        const wantToKnowWhere = document.getElementById("want-to-know-where");
        const wantToKnowWhatCard = document.getElementById("want-to-know-what-card");
        const wantToKnowWhatDevice = document.getElementById("want-to-know-what-device");

        // Element language box select card slide
        const setupSelectCardTitle1 = document.getElementById("setup-select-card-title-1");
        const setupSelectCardDes1 = document.getElementById("setup-select-card-des-1");
        const setupSelectCardTitle2 = document.getElementById("setup-select-card-title-2");
        const setupSelectCardDes2 = document.getElementById("setup-select-card-des-2");
        const setupOpenAppleWallet1 = document.getElementById("setup-open-apple-wallet-1");
        const setupOpenWalletDes1 = document.getElementById("setup-open-wallet-des-1");
        const setupOpenAppleWallet2 = document.getElementById("setup-open-apple-wallet-2");
        const setupOpenWalletDes2 = document.getElementById("setup-open-wallet-des-2");
        const setupWithPhoneFaceIdTitle1 = document.getElementById("setup-with-phone-face-id-title-1");
        const setupWithPhoneFaceIdDes1 = document.getElementById("setup-with-phone-face-id-des-1");
        const setupWithPhoneTouchIdTitle2 = document.getElementById("setup-with-phone-touch-id-title-2");
        const setupWithPhoneTouchIdDes2 = document.getElementById("setup-with-phone-touch-id-des-2");
        const setupWithPhoneTouchIdTitle3 = document.getElementById("setup-with-phone-touch-id-title-3");
        const setupWithPhoneTouchIdDes3 = document.getElementById("setup-with-phone-touch-id-des-3");
        const setupWithPhoneTouchIdTitle1 = document.getElementById("setup-with-phone-touch-id-title-1");
        const setupWithPhoneTouchIdDes1 = document.getElementById("setup-with-phone-touch-id-des-1");
        const setupWithAppleWatchTitle1 = document.getElementById("setup-with-apple-watch-title-1");
        const setupWithAppleWatchDes1 = document.getElementById("setup-with-apple-watch-des-1");
        const setupWithAppleWatchTitle2 = document.getElementById("setup-with-apple-watch-title-2");
        const setupWithAppleWatchDes2 = document.getElementById("setup-with-apple-watch-des-2");
        const setupWithAppleWatchTitle3 = document.getElementById("setup-with-apple-watch-title-3");
        const setupWithAppleWatchDes3 = document.getElementById("setup-with-apple-watch-des-3");

        // Element language box popup
        const titleModalSupportCard = document.getElementById("titleModalSupportCard");
        const desModalSupportCardOne = document.getElementById("desModalSupportCardOne");
        const desModalSupportCardTwo = document.getElementById("desModalSupportCardTwo");
        const desModalSupportCardThree = document.getElementById("desModalSupportCardThree");
        const titleModalSupportDevice = document.getElementById("titleModalSupportDevice");
        const desModalSupportDeviceOne = document.getElementById("desModalSupportDeviceOne");
        const liSupportedDeviceFace = document.getElementById("liSupportedDeviceFace");
        const liSupportedDeviceWatch = document.getElementById("liSupportedDeviceWatch");
        const liSupportedDeviceMac = document.getElementById("liSupportedDeviceMac");
        const linkSupportedDevice = document.getElementById("linkSupportedDevice");
        const titleModalWhere = document.getElementById("titleModalWhere");
        const desModalWhereOne = document.getElementById("desModalWhereOne");
        const desModalWhereTwo = document.getElementById("desModalWhereTwo");
        const linkWhereModal = document.getElementById("linkWhereModal");
        const titleModalWhatCard = document.getElementById("titleModalWhatCard");
        const desModalWhatCardOne = document.getElementById("desModalWhatCardOne");
        const titleModalWhatDevice = document.getElementById("titleModalWhatDevice");
        const desModalWhatDeviceOne = document.getElementById("desModalWhatDeviceOne");
        const desModalWhatDeviceTwo = document.getElementById("desModalWhatDeviceTwo");
        const desModalWhatDeviceThree = document.getElementById("desModalWhatDeviceThree");
        const linkWhatDecice = document.getElementById("linkWhatDecice");

        const imgTouchId = document.getElementById("img-touch-id");
        const desTouchId = document.getElementById("des-touch-id");
        const imgFaceId = document.getElementById("img-face-id");
        const desFaceId = document.getElementById("des-face-id");

        // Handle external link: linkSupportedDevice linkWhereModal linkWhatDecice
        if (urlParams.has("lang") && urlParams.has("url-callback")) {
            const lang = urlParams.get("lang");
            const urlCallback = urlParams.get("url-callback");

            if (lang === "vi") {
                linkSupportedDevice.setAttribute("href", urlCallback + viUrlSupportDevice);
                linkWhereModal.setAttribute("href", urlCallback);
                linkWhatDecice.setAttribute("href", urlCallback + viLostDevice);
            } else {
                linkSupportedDevice.setAttribute("href", urlCallback + enUrlSupportDevice);
                linkWhereModal.setAttribute("href", urlCallback);
                linkWhatDecice.setAttribute("href", urlCallback + enLostDevice);
            }
        } else {
            linkSupportedDevice.setAttribute("href", urlCallback + enUrlSupportDevice);
            linkWhereModal.setAttribute("href", urlCallback);
            linkWhatDecice.setAttribute("href", urlCallback + enLostDevice);
        }


        if (urlParams.has("padding-top")) {
            const paddingTopVal = urlParams.get("padding-top");
            welcomeSec.style.paddingTop = paddingTopVal + "px";
        }

        if (
            urlParams.has("device") &&
            urlParams.has("lang") &&
            urlParams.has("callback")
        ) {
            const device = urlParams.get("device");
            const lang = urlParams.get("lang");

            const callback = urlParams.get("callback");
            const decodeCallback = decodeURIComponent(callback);
            btnSetupApplePay.setAttribute("href", decodeCallback);

            if (device === "2") {
                imgTouchId.classList.remove("d-block");
                imgTouchId.classList.add("d-none");
                desTouchId.classList.remove("d-block");
                desTouchId.classList.add("d-none");

                imgFaceId.classList.remove("d-none");
                imgFaceId.classList.add("d-block");
                desFaceId.classList.remove("d-none");
                desFaceId.classList.add("d-block");
            } else {
                imgFaceId.classList.remove("d-block");
                imgFaceId.classList.add("d-none");
                desFaceId.classList.remove("d-block");
                desFaceId.classList.add("d-none");

                imgTouchId.classList.remove("d-none");
                imgTouchId.classList.add("d-block");
                desTouchId.classList.remove("d-none");
                desTouchId.classList.add("d-block");
            }

            if (lang === "vi") {
                // Box welcome
                welcomeIntro.innerHTML = "Giới thiệu Apple Pay";
                welcomeTitle.innerHTML = "Biến iPhone của bạn trở thành thẻ Techcombank";
                boxSetupItem1.innerHTML = "Thiết lập chỉ trong vài giây";
                boxSetupItem2.innerHTML = "Thanh toán an toàn với Face ID và Touch ID";
                boxSetupItem3.innerHTML = "Bảo mật thông tin thẻ tuyệt đối";
                btnSetupApplePay.innerHTML = "Thiết lập Apple Pay";
                // Box What you will need
                titleWhatYouNeed.innerHTML = "Bạn sẽ cần gì?";
                desWwhatYyouNeed.innerHTML = "Để bắt đầu thiết lập Apple Pay, bạn sẽ cần:";
                whatYouNeedVisaCard.innerHTML = "Thẻ Techcombank Visa";
                desWhatYouNeedVisaCard.innerHTML = "Xem danh sách thẻ";
                whatYouNeedAppleDevice.innerHTML = "Thiết bị Apple tương thích";
                desWhatYouNeedAppleDevice.innerHTML = "Xem danh sách thiết bị";
                // Box let's started
                titleLetStarted.innerHTML = "Bắt đầu ngay nhé";
                desLetStarted.innerHTML = "Làm theo 1 trong 2 cách dưới đây để thêm thẻ trên Techcombank Mobile này hoặc Ví Apple";
                // Box easily
                titleLetUse.innerHTML = "Thanh toán an toàn và tiện lợi cùng Apple Pay";
                desLetUse.innerHTML = "Sau khi thiết lập, bạn có thể thanh toán bằng Apple Pay khi thấy một trong các biểu tượng sau:";
                // Box want to know
                titleWantToKnow.innerHTML = "Có thể bạn muốn biết";
                wantToKnowWhere.innerHTML = "Tôi có thể sử dụng Apple Pay ở đâu?";
                wantToKnowWhatCard.innerHTML = "Tôi nên làm gì khi bị mất thẻ?";
                wantToKnowWhatDevice.innerHTML = "Tôi nên làm gì khi mất thiết bị?";
                // Box select card silde
                setupSelectCardTitle1.innerHTML = "Chọn thẻ";
                setupSelectCardDes1.innerHTML = 'Ấn vào "Thiết lập Apple Pay" và chọn thẻ bạn muốn sử dụng với Apple Pay';
                setupSelectCardTitle2.innerHTML = "Làm theo hướng dẫn";
                setupSelectCardDes2.innerHTML = 'Chọn "Thêm vào Ví Apple" và làm theo hướng dẫn trên màn hình';
                setupOpenAppleWallet1.innerHTML = "Mở ứng dụng Ví";
                setupOpenWalletDes1.innerHTML = "Ấn vào dấu (+) ở góc trên bên phải màn hình để thêm thẻ mới";
                setupOpenAppleWallet2.innerHTML = "Làm theo hướng dẫn";
                setupOpenWalletDes2.innerHTML = "Quét hoặc nhập thông tin thẻ của bạn và làm theo hướng dẫn trên màn hình";
                setupWithPhoneFaceIdTitle1.innerHTML = "Ấn nút nguồn 2 lần";
                setupWithPhoneFaceIdDes1.innerHTML = "Và nhìn iPhone để xác thực khuôn mặt";
                setupWithPhoneTouchIdTitle2.innerHTML = "Chạm để thanh toán";
                setupWithPhoneTouchIdDes2.innerHTML = "Giữ cạnh trên của iPhone gần đầu đọc thẻ để thực hiện thanh toán";
                setupWithPhoneTouchIdTitle3.innerHTML = "Hoàn thành!";
                setupWithPhoneTouchIdDes3.innerHTML = "Khi dấu tích xuất hiện trên màn hình";
                setupWithPhoneTouchIdTitle1.innerHTML = "Ấn nút Home 2 lần";
                setupWithPhoneTouchIdDes1.innerHTML = "Apple Pay đã sẵn sàng sử dụng!";
                setupWithAppleWatchTitle1.innerHTML = "Ấn nút nguồn 2 lần";
                setupWithAppleWatchDes1.innerHTML = "Apple Pay đã sẵn sàng sử dụng!";
                setupWithAppleWatchTitle2.innerHTML = "Chạm để thanh toán";
                setupWithAppleWatchDes2.innerHTML = "Giữ Apple Watch gần đầu đọc thẻ để thực hiện thanh toán";
                setupWithAppleWatchTitle3.innerHTML = "Hoàn thành!";
                setupWithAppleWatchDes3.innerHTML = "Khi dấu tích xuất hiện trên màn hình";
                // Box popup
                titleModalSupportCard.innerHTML = "Tôi có thể sử dụng Apple Pay với loại thẻ nào?";
                desModalSupportCardOne.innerHTML = "Bạn có thể sử dụng cả thẻ tín dụng và ghi nợ Techcombank Visa với Apple Pay.";
                desModalSupportCardTwo.innerHTML = "Nếu 6 chữ số đầu tiên trên thẻ của bạn nằm trong danh sách dưới đây, thẻ của bạn đã đủ điều kiện sử dụng Apple Pay:";
                desModalSupportCardThree.innerHTML = "Danh sách vẫn đang được cập nhật. Nếu đầu thẻ của bạn chưa nằm trong danh sách trên, vui lòng kiểm tra lại sau.";
                titleModalSupportDevice.innerHTML = "Tôi có thể sử dụng Apple Pay trên thiết bị nào?";
                desModalSupportDeviceOne.innerHTML = "Apple Pay tương thích với:";
                liSupportedDeviceFace.innerHTML = "iPhone hoặc iPad có Touch/Face ID (ngoại trừ iPhone 5s)";
                liSupportedDeviceWatch.innerHTML = "Apple Watch (Series 1 trở lên)";
                liSupportedDeviceMac.innerHTML = "Các mẫu Macbook có Touch ID";
                linkSupportedDevice.innerHTML = "Tìm hiểu thêm";
                titleModalWhere.innerHTML = "Tôi có thể sử dụng Apple Pay ở đâu?";
                desModalWhereOne.innerHTML = "Với Apple Pay, bạn sẽ không cần mang ví theo mọi lúc mọi nơi nữa. Chỉ cần sử dụng iPhone, iPad hoặc Apple Watch để thanh toán tại bất kỳ cửa hàng nào hỗ trợ thanh toán không tiếp xúc.";
                desModalWhereTwo.innerHTML = "Ngày càng có nhiều thương hiệu hỗ trợ Apple Pay, nên bạn hãy thiết lập ngay để đón đầu xu hướng này nhé!";
                linkWhereModal.innerHTML = "Xem danh sách cửa hàng";
                titleModalWhatCard.innerHTML = "Tôi có thể sử dụng Apple Pay ở đâu?";
                desModalWhatCardOne.innerHTML = "Nếu mất thẻ, bạn hãy liên hệ với Techcombank theo số điện thoại 1800 588 822. Chúng tôi sẽ giúp bạn khóa thẻ để bảo vệ thông tin và tài sản cá nhân.";
                titleModalWhatDevice.innerHTML = "Tôi nên làm gì khi mất thiết bị?";
                desModalWhatDeviceOne.innerHTML = "Nếu bạn làm mất thiết bị hoặc nghi ngờ bị đánh cắp, hãy đăng nhập vào iCloud.com/Find hoặc sử dụng ứng dụng Tìm (Find My) trên một thiết bị Apple khác bạn sở hữu để định vị thiết bị đã mất trên bản đồ.";
                desModalWhatDeviceTwo.innerHTML = 'Để khóa thiết bị và tắt Apple Pay từ xa, bạn có thể đánh dấu thiết bị là "Bị mất" trên iCloud hoặc ứng dụng Tìm.';
                desModalWhatDeviceThree.innerHTML = "Để được hỗ trợ trực tiếp, vui lòng liên hệ hotline Techcombank 1800 588 822.";
                linkWhatDecice.innerHTML = "Tìm hiểu thêm";
            } else {
                // Box welcome
                welcomeIntro.innerHTML = "Introducing Apple Pay";
                welcomeTitle.innerHTML = "Turn your iPhone into your Techcombank card";
                boxSetupItem1.innerHTML = "Set up in seconds";
                boxSetupItem2.innerHTML = "Pay securely with Face ID or Touch ID";
                boxSetupItem3.innerHTML = "Card number never shared";
                btnSetupApplePay.innerHTML = "Set up Apple Pay";
                // Box What you will need
                titleWhatYouNeed.innerHTML = "What you’ll need";
                desWwhatYyouNeed.innerHTML = "To get started with Apple Pay, you will need";
                whatYouNeedVisaCard.innerHTML = "A Techcombank Visa Card";
                desWhatYouNeedVisaCard.innerHTML = "See supported cards";
                whatYouNeedAppleDevice.innerHTML = "A compatible Apple device";
                desWhatYouNeedAppleDevice.innerHTML = "See supported devices";
                // Box let's started
                titleLetStarted.innerHTML = "Let's get started!";
                desLetStarted.innerHTML = "Follow 1 of the 2 methods below to add your card through this app or Apple Wallet";
                // Box easily
                titleLetUse.innerHTML = "Use Apple Pay easily and securely";
                desLetUse.innerHTML = "After setting up Apple Pay, you can pay wherever you see one of these symbols:";
                // Box want to know
                titleWantToKnow.innerHTML = "You might want to know";
                wantToKnowWhere.innerHTML = "Where can I use Apple Pay?";
                wantToKnowWhatCard.innerHTML = "What should I do if I lose my card?";
                wantToKnowWhatDevice.innerHTML = "What should I do if I lose my device?";
                // Box select card silde
                setupSelectCardTitle1.innerHTML = "Select a card";
                setupSelectCardDes1.innerHTML = 'Tap on “Set up Apple Pay" and choose a card to use with Apple Pay';
                setupSelectCardTitle2.innerHTML = "Follow the instruction";
                setupSelectCardDes2.innerHTML = 'Tap Add to Apple Wallet and follow the on-screen instruction';
                setupOpenAppleWallet1.innerHTML = "Open Apple Wallet";
                setupOpenWalletDes1.innerHTML = "Tap the (+) sign at the top right corner to add your card";
                setupOpenAppleWallet2.innerHTML = "Follow the instruction";
                setupOpenWalletDes2.innerHTML = "Scan or enter your card information and follow the on-screen instruction";
                setupWithPhoneFaceIdTitle1.innerHTML = "Double-click the Side button";
                setupWithPhoneFaceIdDes1.innerHTML = "And glance at the screen to authenticate";
                setupWithPhoneTouchIdTitle2.innerHTML = "Tap to pay";
                setupWithPhoneTouchIdDes2.innerHTML = "Hold the top of your iPhone near the card reader";
                setupWithPhoneTouchIdTitle3.innerHTML = "And you're done!";
                setupWithPhoneTouchIdDes3.innerHTML = 'Wait for the “Done" checkmark and you are done';
                setupWithPhoneTouchIdTitle1.innerHTML = "Double-click the Home button";
                setupWithPhoneTouchIdDes1.innerHTML = "And it's ready to pay";
                setupWithAppleWatchTitle1.innerHTML = "Double-click the Side button";
                setupWithAppleWatchDes1.innerHTML = "And it's ready to pay";
                setupWithAppleWatchTitle2.innerHTML = "Tap to pay";
                setupWithAppleWatchDes2.innerHTML = "Hold your Apple Watch near the card reader";
                setupWithAppleWatchTitle3.innerHTML = "And you're done!";
                setupWithAppleWatchDes3.innerHTML = 'Wait for the “Done" checkmark and you are done';
                // Box popup
                titleModalSupportCard.innerHTML = "Which types of card support Apple Pay?";
                desModalSupportCardOne.innerHTML = "You can use Techcombank Visa Debit and Credit cards with Apple Pay.";
                desModalSupportCardTwo.innerHTML = "To check if your card is eligible, look for the first 6 digits on your card. If they are one of the following, your card is supported:";
                desModalSupportCardThree.innerHTML = "We're expanding this list. If you don't find your card, check back later.";
                titleModalSupportDevice.innerHTML = "Which types of device support Apple Pay?";
                desModalSupportDeviceOne.innerHTML = "Apple Pay is supported by:";
                liSupportedDeviceFace.innerHTML = "iPhone or iPad with Touch/Face ID (except iPhone 5s)";
                liSupportedDeviceWatch.innerHTML = "Apple Watch (Series 1 and later)";
                liSupportedDeviceMac.innerHTML = "MacBook models with Touch ID";
                linkSupportedDevice.innerHTML = "Learn more";
                titleModalWhere.innerHTML = "Where can I use Apple Pay?";
                desModalWhereOne.innerHTML = "With Apple Pay, you can leave your physical wallet at home. Just use your iPhone, iPad, or Apple Watch to pay at any store that accepts contactless payments.";
                desModalWhereTwo.innerHTML = "More and more brands are supporting Apple Pay, so add your card to stay ahead of this trend.";
                linkWhereModal.innerHTML = "See supported stores";
                titleModalWhatCard.innerHTML = "What should I do if I lose my card?";
                desModalWhatCardOne.innerHTML = "If you lose your card, contact us at 1800 588 822. We'll help you lock the card to protect your information and money.";
                titleModalWhatDevice.innerHTML = "What should I do if I lose my device?";
                desModalWhatDeviceOne.innerHTML = "If you lose your device or think it may have been stolen, sign in to iCloud.com/Find or use Find My app on another Apple device that you own to look for it on a map.";
                desModalWhatDeviceTwo.innerHTML = 'To remotely lock your missing device and disable Apple Pay on it, you can mark the device as lost on iCloud or the Find My app.';
                desModalWhatDeviceThree.innerHTML = "For direct support, please contact our Techcombank hotline 1800 588 822.";
                linkWhatDecice.innerHTML = "Learn more";
            }
        }

        // Handle collapse Setup Box
        const btnSetupTechcombank = document.getElementById("btn-techcombank");
        const btnSetupAppleWallet = document.getElementById("btn-apple-wallet");
        const wrapSlideTechcombank = document.getElementById("slide-techcombank");
        const wrapSlideAppleWallet =
            document.getElementById("silde-apple-wallet");

        function handleActiveBtnSetup(nameBtn) {
            if (nameBtn === "techcombank") {
                const checkClass = btnSetupTechcombank.classList.contains("active");
                if (!checkClass) {
                    btnSetupAppleWallet.classList.remove("active");
                    btnSetupTechcombank.classList.add("active");

                    wrapSlideAppleWallet.classList.remove("d-block");
                    wrapSlideAppleWallet.classList.add("d-none");

                    wrapSlideTechcombank.classList.remove("d-none");
                    wrapSlideTechcombank.classList.add("d-block");
                }
            } else {
                const checkClass = btnSetupAppleWallet.classList.contains("active");
                if (!checkClass) {
                    btnSetupTechcombank.classList.remove("active");
                    btnSetupAppleWallet.classList.add("active");

                    wrapSlideTechcombank.classList.remove("d-block");
                    wrapSlideTechcombank.classList.add("d-none");

                    wrapSlideAppleWallet.classList.remove("d-none");
                    wrapSlideAppleWallet.classList.add("d-block");
                }
            }
        }

        // Handle collapse Easily
        const btnEasilyTechcombank = document.getElementById("btn-techcombank-1");
        const btnEasilyAppleWallet =
            document.getElementById("btn-apple-wallet-1");
        const wrapSlideWithPhone = document.getElementById("slide-with-phone");
        const wrapSlideAppleWatch = document.getElementById(
            "slide-with-apple-watch"
        );

        function handleActiveBtnEasily(nameBtn) {
            if (nameBtn === "withPhone") {
                const checkClass = btnEasilyTechcombank.classList.contains("active");
                if (!checkClass) {
                    btnEasilyAppleWallet.classList.remove("active");
                    btnEasilyTechcombank.classList.add("active");

                    wrapSlideAppleWatch.classList.remove("d-block");
                    wrapSlideAppleWatch.classList.add("d-none");

                    wrapSlideWithPhone.classList.remove("d-none");
                    wrapSlideWithPhone.classList.add("d-block");
                }
            } else {
                const checkClass = btnEasilyAppleWallet.classList.contains("active");
                if (!checkClass) {
                    btnEasilyTechcombank.classList.remove("active");
                    btnEasilyAppleWallet.classList.add("active");

                    wrapSlideWithPhone.classList.remove("d-block");
                    wrapSlideWithPhone.classList.add("d-none");

                    wrapSlideAppleWatch.classList.remove("d-none");
                    wrapSlideAppleWatch.classList.add("d-block");
                }
            }
        }
    </script>

    <!-- Swiper JS -->
    <script>
        /**
         * Swiper 10.0.4
         * Most modern mobile touch slider and framework with hardware accelerated transitions
         * https://swiperjs.com
         *
         * Copyright 2014-2023 Vladimir Kharlampidi
         *
         * Released under the MIT License
         *
         * Released on: July 8, 2023
         */

        var Swiper = (function () {
            "use strict";

            /**
             * SSR Window 4.0.2
             * Better handling for window object in SSR environment
             * https://github.com/nolimits4web/ssr-window
             *
             * Copyright 2021, Vladimir Kharlampidi
             *
             * Licensed under MIT
             *
             * Released on: December 13, 2021
             */
            /* eslint-disable no-param-reassign */
            function isObject$1(obj) {
                return (
                    obj !== null &&
                    typeof obj === "object" &&
                    "constructor" in obj &&
                    obj.constructor === Object
                );
            }
            function extend$1(target, src) {
                if (target === void 0) {
                    target = {};
                }
                if (src === void 0) {
                    src = {};
                }
                Object.keys(src).forEach((key) => {
                    if (typeof target[key] === "undefined") target[key] = src[key];
                    else if (
                        isObject$1(src[key]) &&
                        isObject$1(target[key]) &&
                        Object.keys(src[key]).length > 0
                    ) {
                        extend$1(target[key], src[key]);
                    }
                });
            }
            const ssrDocument = {
                body: {},
                addEventListener() { },
                removeEventListener() { },
                activeElement: {
                    blur() { },
                    nodeName: "",
                },
                querySelector() {
                    return null;
                },
                querySelectorAll() {
                    return [];
                },
                getElementById() {
                    return null;
                },
                createEvent() {
                    return {
                        initEvent() { },
                    };
                },
                createElement() {
                    return {
                        children: [],
                        childNodes: [],
                        style: {},
                        setAttribute() { },
                        getElementsByTagName() {
                            return [];
                        },
                    };
                },
                createElementNS() {
                    return {};
                },
                importNode() {
                    return null;
                },
                location: {
                    hash: "",
                    host: "",
                    hostname: "",
                    href: "",
                    origin: "",
                    pathname: "",
                    protocol: "",
                    search: "",
                },
            };
            function getDocument() {
                const doc = typeof document !== "undefined" ? document : {};
                extend$1(doc, ssrDocument);
                return doc;
            }
            const ssrWindow = {
                document: ssrDocument,
                navigator: {
                    userAgent: "",
                },
                location: {
                    hash: "",
                    host: "",
                    hostname: "",
                    href: "",
                    origin: "",
                    pathname: "",
                    protocol: "",
                    search: "",
                },
                history: {
                    replaceState() { },
                    pushState() { },
                    go() { },
                    back() { },
                },
                CustomEvent: function CustomEvent() {
                    return this;
                },
                addEventListener() { },
                removeEventListener() { },
                getComputedStyle() {
                    return {
                        getPropertyValue() {
                            return "";
                        },
                    };
                },
                Image() { },
                Date() { },
                screen: {},
                setTimeout() { },
                clearTimeout() { },
                matchMedia() {
                    return {};
                },
                requestAnimationFrame(callback) {
                    if (typeof setTimeout === "undefined") {
                        callback();
                        return null;
                    }
                    return setTimeout(callback, 0);
                },
                cancelAnimationFrame(id) {
                    if (typeof setTimeout === "undefined") {
                        return;
                    }
                    clearTimeout(id);
                },
            };
            function getWindow() {
                const win = typeof window !== "undefined" ? window : {};
                extend$1(win, ssrWindow);
                return win;
            }

            function deleteProps(obj) {
                const object = obj;
                Object.keys(object).forEach((key) => {
                    try {
                        object[key] = null;
                    } catch (e) {
                        // no getter for object
                    }
                    try {
                        delete object[key];
                    } catch (e) {
                        // something got wrong
                    }
                });
            }
            function nextTick(callback, delay) {
                if (delay === void 0) {
                    delay = 0;
                }
                return setTimeout(callback, delay);
            }
            function now() {
                return Date.now();
            }
            function getComputedStyle$1(el) {
                const window = getWindow();
                let style;
                if (window.getComputedStyle) {
                    style = window.getComputedStyle(el, null);
                }
                if (!style && el.currentStyle) {
                    style = el.currentStyle;
                }
                if (!style) {
                    style = el.style;
                }
                return style;
            }
            function getTranslate(el, axis) {
                if (axis === void 0) {
                    axis = "x";
                }
                const window = getWindow();
                let matrix;
                let curTransform;
                let transformMatrix;
                const curStyle = getComputedStyle$1(el);
                if (window.WebKitCSSMatrix) {
                    curTransform = curStyle.transform || curStyle.webkitTransform;
                    if (curTransform.split(",").length > 6) {
                        curTransform = curTransform
                            .split(", ")
                            .map((a) => a.replace(",", "."))
                            .join(", ");
                    }
                    // Some old versions of Webkit choke when 'none' is passed; pass
                    // empty string instead in this case
                    transformMatrix = new window.WebKitCSSMatrix(
                        curTransform === "none" ? "" : curTransform
                    );
                } else {
                    transformMatrix =
                        curStyle.MozTransform ||
                        curStyle.OTransform ||
                        curStyle.MsTransform ||
                        curStyle.msTransform ||
                        curStyle.transform ||
                        curStyle
                            .getPropertyValue("transform")
                            .replace("translate(", "matrix(1, 0, 0, 1,");
                    matrix = transformMatrix.toString().split(",");
                }
                if (axis === "x") {
                    // Latest Chrome and webkits Fix
                    if (window.WebKitCSSMatrix) curTransform = transformMatrix.m41;
                    // Crazy IE10 Matrix
                    else if (matrix.length === 16)
                        curTransform = parseFloat(matrix[12]);
                    // Normal Browsers
                    else curTransform = parseFloat(matrix[4]);
                }
                if (axis === "y") {
                    // Latest Chrome and webkits Fix
                    if (window.WebKitCSSMatrix) curTransform = transformMatrix.m42;
                    // Crazy IE10 Matrix
                    else if (matrix.length === 16)
                        curTransform = parseFloat(matrix[13]);
                    // Normal Browsers
                    else curTransform = parseFloat(matrix[5]);
                }
                return curTransform || 0;
            }
            function isObject(o) {
                return (
                    typeof o === "object" &&
                    o !== null &&
                    o.constructor &&
                    Object.prototype.toString.call(o).slice(8, -1) === "Object"
                );
            }
            function isNode(node) {
                // eslint-disable-next-line
                if (
                    typeof window !== "undefined" &&
                    typeof window.HTMLElement !== "undefined"
                ) {
                    return node instanceof HTMLElement;
                }
                return node && (node.nodeType === 1 || node.nodeType === 11);
            }
            function extend() {
                const to = Object(arguments.length <= 0 ? undefined : arguments[0]);
                const noExtend = ["__proto__", "constructor", "prototype"];
                for (let i = 1; i < arguments.length; i += 1) {
                    const nextSource =
                        i < 0 || arguments.length <= i ? undefined : arguments[i];
                    if (
                        nextSource !== undefined &&
                        nextSource !== null &&
                        !isNode(nextSource)
                    ) {
                        const keysArray = Object.keys(Object(nextSource)).filter(
                            (key) => noExtend.indexOf(key) < 0
                        );
                        for (
                            let nextIndex = 0, len = keysArray.length;
                            nextIndex < len;
                            nextIndex += 1
                        ) {
                            const nextKey = keysArray[nextIndex];
                            const desc = Object.getOwnPropertyDescriptor(
                                nextSource,
                                nextKey
                            );
                            if (desc !== undefined && desc.enumerable) {
                                if (isObject(to[nextKey]) && isObject(nextSource[nextKey])) {
                                    if (nextSource[nextKey].__swiper__) {
                                        to[nextKey] = nextSource[nextKey];
                                    } else {
                                        extend(to[nextKey], nextSource[nextKey]);
                                    }
                                } else if (
                                    !isObject(to[nextKey]) &&
                                    isObject(nextSource[nextKey])
                                ) {
                                    to[nextKey] = {};
                                    if (nextSource[nextKey].__swiper__) {
                                        to[nextKey] = nextSource[nextKey];
                                    } else {
                                        extend(to[nextKey], nextSource[nextKey]);
                                    }
                                } else {
                                    to[nextKey] = nextSource[nextKey];
                                }
                            }
                        }
                    }
                }
                return to;
            }
            function setCSSProperty(el, varName, varValue) {
                el.style.setProperty(varName, varValue);
            }
            function animateCSSModeScroll(_ref) {
                let { swiper, targetPosition, side } = _ref;
                const window = getWindow();
                const startPosition = -swiper.translate;
                let startTime = null;
                let time;
                const duration = swiper.params.speed;
                swiper.wrapperEl.style.scrollSnapType = "none";
                window.cancelAnimationFrame(swiper.cssModeFrameID);
                const dir = targetPosition > startPosition ? "next" : "prev";
                const isOutOfBound = (current, target) => {
                    return (
                        (dir === "next" && current >= target) ||
                        (dir === "prev" && current <= target)
                    );
                };
                const animate = () => {
                    time = new Date().getTime();
                    if (startTime === null) {
                        startTime = time;
                    }
                    const progress = Math.max(
                        Math.min((time - startTime) / duration, 1),
                        0
                    );
                    const easeProgress = 0.5 - Math.cos(progress * Math.PI) / 2;
                    let currentPosition =
                        startPosition + easeProgress * (targetPosition - startPosition);
                    if (isOutOfBound(currentPosition, targetPosition)) {
                        currentPosition = targetPosition;
                    }
                    swiper.wrapperEl.scrollTo({
                        [side]: currentPosition,
                    });
                    if (isOutOfBound(currentPosition, targetPosition)) {
                        swiper.wrapperEl.style.overflow = "hidden";
                        swiper.wrapperEl.style.scrollSnapType = "";
                        setTimeout(() => {
                            swiper.wrapperEl.style.overflow = "";
                            swiper.wrapperEl.scrollTo({
                                [side]: currentPosition,
                            });
                        });
                        window.cancelAnimationFrame(swiper.cssModeFrameID);
                        return;
                    }
                    swiper.cssModeFrameID = window.requestAnimationFrame(animate);
                };
                animate();
            }
            function getSlideTransformEl(slideEl) {
                return (
                    slideEl.querySelector(".swiper-slide-transform") ||
                    (slideEl.shadowRoot &&
                        slideEl.shadowRoot.querySelector(".swiper-slide-transform")) ||
                    slideEl
                );
            }
            function elementChildren(element, selector) {
                if (selector === void 0) {
                    selector = "";
                }
                return [...element.children].filter((el) => el.matches(selector));
            }
            function createElement(tag, classes) {
                if (classes === void 0) {
                    classes = [];
                }
                const el = document.createElement(tag);
                el.classList.add(...(Array.isArray(classes) ? classes : [classes]));
                return el;
            }
            function elementOffset(el) {
                const window = getWindow();
                const document = getDocument();
                const box = el.getBoundingClientRect();
                const body = document.body;
                const clientTop = el.clientTop || body.clientTop || 0;
                const clientLeft = el.clientLeft || body.clientLeft || 0;
                const scrollTop = el === window ? window.scrollY : el.scrollTop;
                const scrollLeft = el === window ? window.scrollX : el.scrollLeft;
                return {
                    top: box.top + scrollTop - clientTop,
                    left: box.left + scrollLeft - clientLeft,
                };
            }
            function elementPrevAll(el, selector) {
                const prevEls = [];
                while (el.previousElementSibling) {
                    const prev = el.previousElementSibling; // eslint-disable-line
                    if (selector) {
                        if (prev.matches(selector)) prevEls.push(prev);
                    } else prevEls.push(prev);
                    el = prev;
                }
                return prevEls;
            }
            function elementNextAll(el, selector) {
                const nextEls = [];
                while (el.nextElementSibling) {
                    const next = el.nextElementSibling; // eslint-disable-line
                    if (selector) {
                        if (next.matches(selector)) nextEls.push(next);
                    } else nextEls.push(next);
                    el = next;
                }
                return nextEls;
            }
            function elementStyle(el, prop) {
                const window = getWindow();
                return window.getComputedStyle(el, null).getPropertyValue(prop);
            }
            function elementIndex(el) {
                let child = el;
                let i;
                if (child) {
                    i = 0;
                    // eslint-disable-next-line
                    while ((child = child.previousSibling) !== null) {
                        if (child.nodeType === 1) i += 1;
                    }
                    return i;
                }
                return undefined;
            }
            function elementParents(el, selector) {
                const parents = []; // eslint-disable-line
                let parent = el.parentElement; // eslint-disable-line
                while (parent) {
                    if (selector) {
                        if (parent.matches(selector)) parents.push(parent);
                    } else {
                        parents.push(parent);
                    }
                    parent = parent.parentElement;
                }
                return parents;
            }
            function elementTransitionEnd(el, callback) {
                function fireCallBack(e) {
                    if (e.target !== el) return;
                    callback.call(el, e);
                    el.removeEventListener("transitionend", fireCallBack);
                }
                if (callback) {
                    el.addEventListener("transitionend", fireCallBack);
                }
            }
            function elementOuterSize(el, size, includeMargins) {
                const window = getWindow();
                if (includeMargins) {
                    return (
                        el[size === "width" ? "offsetWidth" : "offsetHeight"] +
                        parseFloat(
                            window
                                .getComputedStyle(el, null)
                                .getPropertyValue(
                                    size === "width" ? "margin-right" : "margin-top"
                                )
                        ) +
                        parseFloat(
                            window
                                .getComputedStyle(el, null)
                                .getPropertyValue(
                                    size === "width" ? "margin-left" : "margin-bottom"
                                )
                        )
                    );
                }
                return el.offsetWidth;
            }

            let support;
            function calcSupport() {
                const window = getWindow();
                const document = getDocument();
                return {
                    smoothScroll:
                        document.documentElement &&
                        document.documentElement.style &&
                        "scrollBehavior" in document.documentElement.style,
                    touch: !!(
                        "ontouchstart" in window ||
                        (window.DocumentTouch && document instanceof window.DocumentTouch)
                    ),
                };
            }
            function getSupport() {
                if (!support) {
                    support = calcSupport();
                }
                return support;
            }

            let deviceCached;
            function calcDevice(_temp) {
                let { userAgent } = _temp === void 0 ? {} : _temp;
                const support = getSupport();
                const window = getWindow();
                const platform = window.navigator.platform;
                const ua = userAgent || window.navigator.userAgent;
                const device = {
                    ios: false,
                    android: false,
                };
                const screenWidth = window.screen.width;
                const screenHeight = window.screen.height;
                const android = ua.match(/(Android);?[\s\/]+([\d.]+)?/); // eslint-disable-line
                let ipad = ua.match(/(iPad).*OS\s([\d_]+)/);
                const ipod = ua.match(/(iPod)(.*OS\s([\d_]+))?/);
                const iphone = !ipad && ua.match(/(iPhone\sOS|iOS)\s([\d_]+)/);
                const windows = platform === "Win32";
                let macos = platform === "MacIntel";

                // iPadOs 13 fix
                const iPadScreens = [
                    "1024x1366",
                    "1366x1024",
                    "834x1194",
                    "1194x834",
                    "834x1112",
                    "1112x834",
                    "768x1024",
                    "1024x768",
                    "820x1180",
                    "1180x820",
                    "810x1080",
                    "1080x810",
                ];
                if (
                    !ipad &&
                    macos &&
                    support.touch &&
                    iPadScreens.indexOf(`${screenWidth}x${screenHeight}`) >= 0
                ) {
                    ipad = ua.match(/(Version)\/([\d.]+)/);
                    if (!ipad) ipad = [0, 1, "13_0_0"];
                    macos = false;
                }

                // Android
                if (android && !windows) {
                    device.os = "android";
                    device.android = true;
                }
                if (ipad || iphone || ipod) {
                    device.os = "ios";
                    device.ios = true;
                }

                // Export object
                return device;
            }
            function getDevice(overrides) {
                if (overrides === void 0) {
                    overrides = {};
                }
                if (!deviceCached) {
                    deviceCached = calcDevice(overrides);
                }
                return deviceCached;
            }

            let browser;
            function calcBrowser() {
                const window = getWindow();
                let needPerspectiveFix = false;
                function isSafari() {
                    const ua = window.navigator.userAgent.toLowerCase();
                    return (
                        ua.indexOf("safari") >= 0 &&
                        ua.indexOf("chrome") < 0 &&
                        ua.indexOf("android") < 0
                    );
                }
                if (isSafari()) {
                    const ua = String(window.navigator.userAgent);
                    if (ua.includes("Version/")) {
                        const [major, minor] = ua
                            .split("Version/")[1]
                            .split(" ")[0]
                            .split(".")
                            .map((num) => Number(num));
                        needPerspectiveFix = major < 16 || (major === 16 && minor < 2);
                    }
                }
                return {
                    isSafari: needPerspectiveFix || isSafari(),
                    needPerspectiveFix,
                    isWebView: /(iPhone|iPod|iPad).*AppleWebKit(?!.*Safari)/i.test(
                        window.navigator.userAgent
                    ),
                };
            }
            function getBrowser() {
                if (!browser) {
                    browser = calcBrowser();
                }
                return browser;
            }

            function Resize(_ref) {
                let { swiper, on, emit } = _ref;
                const window = getWindow();
                let observer = null;
                let animationFrame = null;
                const resizeHandler = () => {
                    if (!swiper || swiper.destroyed || !swiper.initialized) return;
                    emit("beforeResize");
                    emit("resize");
                };
                const createObserver = () => {
                    if (!swiper || swiper.destroyed || !swiper.initialized) return;
                    observer = new ResizeObserver((entries) => {
                        animationFrame = window.requestAnimationFrame(() => {
                            const { width, height } = swiper;
                            let newWidth = width;
                            let newHeight = height;
                            entries.forEach((_ref2) => {
                                let { contentBoxSize, contentRect, target } = _ref2;
                                if (target && target !== swiper.el) return;
                                newWidth = contentRect
                                    ? contentRect.width
                                    : (contentBoxSize[0] || contentBoxSize).inlineSize;
                                newHeight = contentRect
                                    ? contentRect.height
                                    : (contentBoxSize[0] || contentBoxSize).blockSize;
                            });
                            if (newWidth !== width || newHeight !== height) {
                                resizeHandler();
                            }
                        });
                    });
                    observer.observe(swiper.el);
                };
                const removeObserver = () => {
                    if (animationFrame) {
                        window.cancelAnimationFrame(animationFrame);
                    }
                    if (observer && observer.unobserve && swiper.el) {
                        observer.unobserve(swiper.el);
                        observer = null;
                    }
                };
                const orientationChangeHandler = () => {
                    if (!swiper || swiper.destroyed || !swiper.initialized) return;
                    emit("orientationchange");
                };
                on("init", () => {
                    if (
                        swiper.params.resizeObserver &&
                        typeof window.ResizeObserver !== "undefined"
                    ) {
                        createObserver();
                        return;
                    }
                    window.addEventListener("resize", resizeHandler);
                    window.addEventListener(
                        "orientationchange",
                        orientationChangeHandler
                    );
                });
                on("destroy", () => {
                    removeObserver();
                    window.removeEventListener("resize", resizeHandler);
                    window.removeEventListener(
                        "orientationchange",
                        orientationChangeHandler
                    );
                });
            }

            function Observer(_ref) {
                let { swiper, extendParams, on, emit } = _ref;
                const observers = [];
                const window = getWindow();
                const attach = function (target, options) {
                    if (options === void 0) {
                        options = {};
                    }
                    const ObserverFunc =
                        window.MutationObserver || window.WebkitMutationObserver;
                    const observer = new ObserverFunc((mutations) => {
                        // The observerUpdate event should only be triggered
                        // once despite the number of mutations.  Additional
                        // triggers are redundant and are very costly
                        if (swiper.__preventObserver__) return;
                        if (mutations.length === 1) {
                            emit("observerUpdate", mutations[0]);
                            return;
                        }
                        const observerUpdate = function observerUpdate() {
                            emit("observerUpdate", mutations[0]);
                        };
                        if (window.requestAnimationFrame) {
                            window.requestAnimationFrame(observerUpdate);
                        } else {
                            window.setTimeout(observerUpdate, 0);
                        }
                    });
                    observer.observe(target, {
                        attributes:
                            typeof options.attributes === "undefined"
                                ? true
                                : options.attributes,
                        childList:
                            typeof options.childList === "undefined"
                                ? true
                                : options.childList,
                        characterData:
                            typeof options.characterData === "undefined"
                                ? true
                                : options.characterData,
                    });
                    observers.push(observer);
                };
                const init = () => {
                    if (!swiper.params.observer) return;
                    if (swiper.params.observeParents) {
                        const containerParents = elementParents(swiper.el);
                        for (let i = 0; i < containerParents.length; i += 1) {
                            attach(containerParents[i]);
                        }
                    }
                    // Observe container
                    attach(swiper.el, {
                        childList: swiper.params.observeSlideChildren,
                    });

                    // Observe wrapper
                    attach(swiper.wrapperEl, {
                        attributes: false,
                    });
                };
                const destroy = () => {
                    observers.forEach((observer) => {
                        observer.disconnect();
                    });
                    observers.splice(0, observers.length);
                };
                extendParams({
                    observer: false,
                    observeParents: false,
                    observeSlideChildren: false,
                });
                on("init", init);
                on("destroy", destroy);
            }

            /* eslint-disable no-underscore-dangle */

            var eventsEmitter = {
                on(events, handler, priority) {
                    const self = this;
                    if (!self.eventsListeners || self.destroyed) return self;
                    if (typeof handler !== "function") return self;
                    const method = priority ? "unshift" : "push";
                    events.split(" ").forEach((event) => {
                        if (!self.eventsListeners[event])
                            self.eventsListeners[event] = [];
                        self.eventsListeners[event][method](handler);
                    });
                    return self;
                },
                once(events, handler, priority) {
                    const self = this;
                    if (!self.eventsListeners || self.destroyed) return self;
                    if (typeof handler !== "function") return self;
                    function onceHandler() {
                        self.off(events, onceHandler);
                        if (onceHandler.__emitterProxy) {
                            delete onceHandler.__emitterProxy;
                        }
                        for (
                            var _len = arguments.length, args = new Array(_len), _key = 0;
                            _key < _len;
                            _key++
                        ) {
                            args[_key] = arguments[_key];
                        }
                        handler.apply(self, args);
                    }
                    onceHandler.__emitterProxy = handler;
                    return self.on(events, onceHandler, priority);
                },
                onAny(handler, priority) {
                    const self = this;
                    if (!self.eventsListeners || self.destroyed) return self;
                    if (typeof handler !== "function") return self;
                    const method = priority ? "unshift" : "push";
                    if (self.eventsAnyListeners.indexOf(handler) < 0) {
                        self.eventsAnyListeners[method](handler);
                    }
                    return self;
                },
                offAny(handler) {
                    const self = this;
                    if (!self.eventsListeners || self.destroyed) return self;
                    if (!self.eventsAnyListeners) return self;
                    const index = self.eventsAnyListeners.indexOf(handler);
                    if (index >= 0) {
                        self.eventsAnyListeners.splice(index, 1);
                    }
                    return self;
                },
                off(events, handler) {
                    const self = this;
                    if (!self.eventsListeners || self.destroyed) return self;
                    if (!self.eventsListeners) return self;
                    events.split(" ").forEach((event) => {
                        if (typeof handler === "undefined") {
                            self.eventsListeners[event] = [];
                        } else if (self.eventsListeners[event]) {
                            self.eventsListeners[event].forEach((eventHandler, index) => {
                                if (
                                    eventHandler === handler ||
                                    (eventHandler.__emitterProxy &&
                                        eventHandler.__emitterProxy === handler)
                                ) {
                                    self.eventsListeners[event].splice(index, 1);
                                }
                            });
                        }
                    });
                    return self;
                },
                emit() {
                    const self = this;
                    if (!self.eventsListeners || self.destroyed) return self;
                    if (!self.eventsListeners) return self;
                    let events;
                    let data;
                    let context;
                    for (
                        var _len2 = arguments.length, args = new Array(_len2), _key2 = 0;
                        _key2 < _len2;
                        _key2++
                    ) {
                        args[_key2] = arguments[_key2];
                    }
                    if (typeof args[0] === "string" || Array.isArray(args[0])) {
                        events = args[0];
                        data = args.slice(1, args.length);
                        context = self;
                    } else {
                        events = args[0].events;
                        data = args[0].data;
                        context = args[0].context || self;
                    }
                    data.unshift(context);
                    const eventsArray = Array.isArray(events)
                        ? events
                        : events.split(" ");
                    eventsArray.forEach((event) => {
                        if (self.eventsAnyListeners && self.eventsAnyListeners.length) {
                            self.eventsAnyListeners.forEach((eventHandler) => {
                                eventHandler.apply(context, [event, ...data]);
                            });
                        }
                        if (self.eventsListeners && self.eventsListeners[event]) {
                            self.eventsListeners[event].forEach((eventHandler) => {
                                eventHandler.apply(context, data);
                            });
                        }
                    });
                    return self;
                },
            };

            function updateSize() {
                const swiper = this;
                let width;
                let height;
                const el = swiper.el;
                if (
                    typeof swiper.params.width !== "undefined" &&
                    swiper.params.width !== null
                ) {
                    width = swiper.params.width;
                } else {
                    width = el.clientWidth;
                }
                if (
                    typeof swiper.params.height !== "undefined" &&
                    swiper.params.height !== null
                ) {
                    height = swiper.params.height;
                } else {
                    height = el.clientHeight;
                }
                if (
                    (width === 0 && swiper.isHorizontal()) ||
                    (height === 0 && swiper.isVertical())
                ) {
                    return;
                }

                // Subtract paddings
                width =
                    width -
                    parseInt(elementStyle(el, "padding-left") || 0, 10) -
                    parseInt(elementStyle(el, "padding-right") || 0, 10);
                height =
                    height -
                    parseInt(elementStyle(el, "padding-top") || 0, 10) -
                    parseInt(elementStyle(el, "padding-bottom") || 0, 10);
                if (Number.isNaN(width)) width = 0;
                if (Number.isNaN(height)) height = 0;
                Object.assign(swiper, {
                    width,
                    height,
                    size: swiper.isHorizontal() ? width : height,
                });
            }

            function updateSlides() {
                const swiper = this;
                function getDirectionLabel(property) {
                    if (swiper.isHorizontal()) {
                        return property;
                    }
                    // prettier-ignore
                    return {
                        'width': 'height',
                        'margin-top': 'margin-left',
                        'margin-bottom ': 'margin-right',
                        'margin-left': 'margin-top',
                        'margin-right': 'margin-bottom',
                        'padding-left': 'padding-top',
                        'padding-right': 'padding-bottom',
                        'marginRight': 'marginBottom'
                    }[property];
                }
                function getDirectionPropertyValue(node, label) {
                    return parseFloat(
                        node.getPropertyValue(getDirectionLabel(label)) || 0
                    );
                }
                const params = swiper.params;
                const {
                    wrapperEl,
                    slidesEl,
                    size: swiperSize,
                    rtlTranslate: rtl,
                    wrongRTL,
                } = swiper;
                const isVirtual = swiper.virtual && params.virtual.enabled;
                const previousSlidesLength = isVirtual
                    ? swiper.virtual.slides.length
                    : swiper.slides.length;
                const slides = elementChildren(
                    slidesEl,
                    `.${swiper.params.slideClass}, swiper-slide`
                );
                const slidesLength = isVirtual
                    ? swiper.virtual.slides.length
                    : slides.length;
                let snapGrid = [];
                const slidesGrid = [];
                const slidesSizesGrid = [];
                let offsetBefore = params.slidesOffsetBefore;
                if (typeof offsetBefore === "function") {
                    offsetBefore = params.slidesOffsetBefore.call(swiper);
                }
                let offsetAfter = params.slidesOffsetAfter;
                if (typeof offsetAfter === "function") {
                    offsetAfter = params.slidesOffsetAfter.call(swiper);
                }
                const previousSnapGridLength = swiper.snapGrid.length;
                const previousSlidesGridLength = swiper.slidesGrid.length;
                let spaceBetween = params.spaceBetween;
                let slidePosition = -offsetBefore;
                let prevSlideSize = 0;
                let index = 0;
                if (typeof swiperSize === "undefined") {
                    return;
                }
                if (
                    typeof spaceBetween === "string" &&
                    spaceBetween.indexOf("%") >= 0
                ) {
                    spaceBetween =
                        (parseFloat(spaceBetween.replace("%", "")) / 100) * swiperSize;
                } else if (typeof spaceBetween === "string") {
                    spaceBetween = parseFloat(spaceBetween);
                }
                swiper.virtualSize = -spaceBetween;

                // reset margins
                slides.forEach((slideEl) => {
                    if (rtl) {
                        slideEl.style.marginLeft = "";
                    } else {
                        slideEl.style.marginRight = "";
                    }
                    slideEl.style.marginBottom = "";
                    slideEl.style.marginTop = "";
                });

                // reset cssMode offsets
                if (params.centeredSlides && params.cssMode) {
                    setCSSProperty(wrapperEl, "--swiper-centered-offset-before", "");
                    setCSSProperty(wrapperEl, "--swiper-centered-offset-after", "");
                }
                const gridEnabled =
                    params.grid && params.grid.rows > 1 && swiper.grid;
                if (gridEnabled) {
                    swiper.grid.initSlides(slidesLength);
                }

                // Calc slides
                let slideSize;
                const shouldResetSlideSize =
                    params.slidesPerView === "auto" &&
                    params.breakpoints &&
                    Object.keys(params.breakpoints).filter((key) => {
                        return (
                            typeof params.breakpoints[key].slidesPerView !== "undefined"
                        );
                    }).length > 0;
                for (let i = 0; i < slidesLength; i += 1) {
                    slideSize = 0;
                    let slide;
                    if (slides[i]) slide = slides[i];
                    if (gridEnabled) {
                        swiper.grid.updateSlide(
                            i,
                            slide,
                            slidesLength,
                            getDirectionLabel
                        );
                    }
                    if (slides[i] && elementStyle(slide, "display") === "none")
                        continue; // eslint-disable-line

                    if (params.slidesPerView === "auto") {
                        if (shouldResetSlideSize) {
                            slides[i].style[getDirectionLabel("width")] = ``;
                        }
                        const slideStyles = getComputedStyle(slide);
                        const currentTransform = slide.style.transform;
                        const currentWebKitTransform = slide.style.webkitTransform;
                        if (currentTransform) {
                            slide.style.transform = "none";
                        }
                        if (currentWebKitTransform) {
                            slide.style.webkitTransform = "none";
                        }
                        if (params.roundLengths) {
                            slideSize = swiper.isHorizontal()
                                ? elementOuterSize(slide, "width", true)
                                : elementOuterSize(slide, "height", true);
                        } else {
                            // eslint-disable-next-line
                            const width = getDirectionPropertyValue(slideStyles, "width");
                            const paddingLeft = getDirectionPropertyValue(
                                slideStyles,
                                "padding-left"
                            );
                            const paddingRight = getDirectionPropertyValue(
                                slideStyles,
                                "padding-right"
                            );
                            const marginLeft = getDirectionPropertyValue(
                                slideStyles,
                                "margin-left"
                            );
                            const marginRight = getDirectionPropertyValue(
                                slideStyles,
                                "margin-right"
                            );
                            const boxSizing = slideStyles.getPropertyValue("box-sizing");
                            if (boxSizing && boxSizing === "border-box") {
                                slideSize = width + marginLeft + marginRight;
                            } else {
                                const { clientWidth, offsetWidth } = slide;
                                slideSize =
                                    width +
                                    paddingLeft +
                                    paddingRight +
                                    marginLeft +
                                    marginRight +
                                    (offsetWidth - clientWidth);
                            }
                        }
                        if (currentTransform) {
                            slide.style.transform = currentTransform;
                        }
                        if (currentWebKitTransform) {
                            slide.style.webkitTransform = currentWebKitTransform;
                        }
                        if (params.roundLengths) slideSize = Math.floor(slideSize);
                    } else {
                        slideSize =
                            (swiperSize - (params.slidesPerView - 1) * spaceBetween) /
                            params.slidesPerView;
                        if (params.roundLengths) slideSize = Math.floor(slideSize);
                        if (slides[i]) {
                            slides[i].style[getDirectionLabel("width")] = `${slideSize}px`;
                        }
                    }
                    if (slides[i]) {
                        slides[i].swiperSlideSize = slideSize;
                    }
                    slidesSizesGrid.push(slideSize);
                    if (params.centeredSlides) {
                        slidePosition =
                            slidePosition +
                            slideSize / 2 +
                            prevSlideSize / 2 +
                            spaceBetween;
                        if (prevSlideSize === 0 && i !== 0)
                            slidePosition = slidePosition - swiperSize / 2 - spaceBetween;
                        if (i === 0)
                            slidePosition = slidePosition - swiperSize / 2 - spaceBetween;
                        if (Math.abs(slidePosition) < 1 / 1000) slidePosition = 0;
                        if (params.roundLengths)
                            slidePosition = Math.floor(slidePosition);
                        if (index % params.slidesPerGroup === 0)
                            snapGrid.push(slidePosition);
                        slidesGrid.push(slidePosition);
                    } else {
                        if (params.roundLengths)
                            slidePosition = Math.floor(slidePosition);
                        if (
                            (index - Math.min(swiper.params.slidesPerGroupSkip, index)) %
                            swiper.params.slidesPerGroup ===
                            0
                        )
                            snapGrid.push(slidePosition);
                        slidesGrid.push(slidePosition);
                        slidePosition = slidePosition + slideSize + spaceBetween;
                    }
                    swiper.virtualSize += slideSize + spaceBetween;
                    prevSlideSize = slideSize;
                    index += 1;
                }
                swiper.virtualSize =
                    Math.max(swiper.virtualSize, swiperSize) + offsetAfter;
                if (
                    rtl &&
                    wrongRTL &&
                    (params.effect === "slide" || params.effect === "coverflow")
                ) {
                    wrapperEl.style.width = `${swiper.virtualSize + spaceBetween}px`;
                }
                if (params.setWrapperSize) {
                    wrapperEl.style[getDirectionLabel("width")] = `${swiper.virtualSize + spaceBetween
                        }px`;
                }
                if (gridEnabled) {
                    swiper.grid.updateWrapperSize(
                        slideSize,
                        snapGrid,
                        getDirectionLabel
                    );
                }

                // Remove last grid elements depending on width
                if (!params.centeredSlides) {
                    const newSlidesGrid = [];
                    for (let i = 0; i < snapGrid.length; i += 1) {
                        let slidesGridItem = snapGrid[i];
                        if (params.roundLengths)
                            slidesGridItem = Math.floor(slidesGridItem);
                        if (snapGrid[i] <= swiper.virtualSize - swiperSize) {
                            newSlidesGrid.push(slidesGridItem);
                        }
                    }
                    snapGrid = newSlidesGrid;
                    if (
                        Math.floor(swiper.virtualSize - swiperSize) -
                        Math.floor(snapGrid[snapGrid.length - 1]) >
                        1
                    ) {
                        snapGrid.push(swiper.virtualSize - swiperSize);
                    }
                }
                if (isVirtual && params.loop) {
                    const size = slidesSizesGrid[0] + spaceBetween;
                    if (params.slidesPerGroup > 1) {
                        const groups = Math.ceil(
                            (swiper.virtual.slidesBefore + swiper.virtual.slidesAfter) /
                            params.slidesPerGroup
                        );
                        const groupSize = size * params.slidesPerGroup;
                        for (let i = 0; i < groups; i += 1) {
                            snapGrid.push(snapGrid[snapGrid.length - 1] + groupSize);
                        }
                    }
                    for (
                        let i = 0;
                        i < swiper.virtual.slidesBefore + swiper.virtual.slidesAfter;
                        i += 1
                    ) {
                        if (params.slidesPerGroup === 1) {
                            snapGrid.push(snapGrid[snapGrid.length - 1] + size);
                        }
                        slidesGrid.push(slidesGrid[slidesGrid.length - 1] + size);
                        swiper.virtualSize += size;
                    }
                }
                if (snapGrid.length === 0) snapGrid = [0];
                if (spaceBetween !== 0) {
                    const key =
                        swiper.isHorizontal() && rtl
                            ? "marginLeft"
                            : getDirectionLabel("marginRight");
                    slides
                        .filter((_, slideIndex) => {
                            if (!params.cssMode || params.loop) return true;
                            if (slideIndex === slides.length - 1) {
                                return false;
                            }
                            return true;
                        })
                        .forEach((slideEl) => {
                            slideEl.style[key] = `${spaceBetween}px`;
                        });
                }
                if (params.centeredSlides && params.centeredSlidesBounds) {
                    let allSlidesSize = 0;
                    slidesSizesGrid.forEach((slideSizeValue) => {
                        allSlidesSize += slideSizeValue + (spaceBetween || 0);
                    });
                    allSlidesSize -= spaceBetween;
                    const maxSnap = allSlidesSize - swiperSize;
                    snapGrid = snapGrid.map((snap) => {
                        if (snap <= 0) return -offsetBefore;
                        if (snap > maxSnap) return maxSnap + offsetAfter;
                        return snap;
                    });
                }
                if (params.centerInsufficientSlides) {
                    let allSlidesSize = 0;
                    slidesSizesGrid.forEach((slideSizeValue) => {
                        allSlidesSize += slideSizeValue + (spaceBetween || 0);
                    });
                    allSlidesSize -= spaceBetween;
                    if (allSlidesSize < swiperSize) {
                        const allSlidesOffset = (swiperSize - allSlidesSize) / 2;
                        snapGrid.forEach((snap, snapIndex) => {
                            snapGrid[snapIndex] = snap - allSlidesOffset;
                        });
                        slidesGrid.forEach((snap, snapIndex) => {
                            slidesGrid[snapIndex] = snap + allSlidesOffset;
                        });
                    }
                }
                Object.assign(swiper, {
                    slides,
                    snapGrid,
                    slidesGrid,
                    slidesSizesGrid,
                });
                if (
                    params.centeredSlides &&
                    params.cssMode &&
                    !params.centeredSlidesBounds
                ) {
                    setCSSProperty(
                        wrapperEl,
                        "--swiper-centered-offset-before",
                        `${-snapGrid[0]}px`
                    );
                    setCSSProperty(
                        wrapperEl,
                        "--swiper-centered-offset-after",
                        `${swiper.size / 2 -
                        slidesSizesGrid[slidesSizesGrid.length - 1] / 2
                        }px`
                    );
                    const addToSnapGrid = -swiper.snapGrid[0];
                    const addToSlidesGrid = -swiper.slidesGrid[0];
                    swiper.snapGrid = swiper.snapGrid.map((v) => v + addToSnapGrid);
                    swiper.slidesGrid = swiper.slidesGrid.map(
                        (v) => v + addToSlidesGrid
                    );
                }
                if (slidesLength !== previousSlidesLength) {
                    swiper.emit("slidesLengthChange");
                }
                if (snapGrid.length !== previousSnapGridLength) {
                    if (swiper.params.watchOverflow) swiper.checkOverflow();
                    swiper.emit("snapGridLengthChange");
                }
                if (slidesGrid.length !== previousSlidesGridLength) {
                    swiper.emit("slidesGridLengthChange");
                }
                if (params.watchSlidesProgress) {
                    swiper.updateSlidesOffset();
                }
                if (
                    !isVirtual &&
                    !params.cssMode &&
                    (params.effect === "slide" || params.effect === "fade")
                ) {
                    const backFaceHiddenClass = `${params.containerModifierClass}backface-hidden`;
                    const hasClassBackfaceClassAdded =
                        swiper.el.classList.contains(backFaceHiddenClass);
                    if (slidesLength <= params.maxBackfaceHiddenSlides) {
                        if (!hasClassBackfaceClassAdded)
                            swiper.el.classList.add(backFaceHiddenClass);
                    } else if (hasClassBackfaceClassAdded) {
                        swiper.el.classList.remove(backFaceHiddenClass);
                    }
                }
            }

            function updateAutoHeight(speed) {
                const swiper = this;
                const activeSlides = [];
                const isVirtual = swiper.virtual && swiper.params.virtual.enabled;
                let newHeight = 0;
                let i;
                if (typeof speed === "number") {
                    swiper.setTransition(speed);
                } else if (speed === true) {
                    swiper.setTransition(swiper.params.speed);
                }
                const getSlideByIndex = (index) => {
                    if (isVirtual) {
                        return swiper.slides[swiper.getSlideIndexByData(index)];
                    }
                    return swiper.slides[index];
                };
                // Find slides currently in view
                if (
                    swiper.params.slidesPerView !== "auto" &&
                    swiper.params.slidesPerView > 1
                ) {
                    if (swiper.params.centeredSlides) {
                        (swiper.visibleSlides || []).forEach((slide) => {
                            activeSlides.push(slide);
                        });
                    } else {
                        for (i = 0; i < Math.ceil(swiper.params.slidesPerView); i += 1) {
                            const index = swiper.activeIndex + i;
                            if (index > swiper.slides.length && !isVirtual) break;
                            activeSlides.push(getSlideByIndex(index));
                        }
                    }
                } else {
                    activeSlides.push(getSlideByIndex(swiper.activeIndex));
                }

                // Find new height from highest slide in view
                for (i = 0; i < activeSlides.length; i += 1) {
                    if (typeof activeSlides[i] !== "undefined") {
                        const height = activeSlides[i].offsetHeight;
                        newHeight = height > newHeight ? height : newHeight;
                    }
                }

                // Update Height
                if (newHeight || newHeight === 0)
                    swiper.wrapperEl.style.height = `${newHeight}px`;
            }

            function updateSlidesOffset() {
                const swiper = this;
                const slides = swiper.slides;
                // eslint-disable-next-line
                const minusOffset = swiper.isElement
                    ? swiper.isHorizontal()
                        ? swiper.wrapperEl.offsetLeft
                        : swiper.wrapperEl.offsetTop
                    : 0;
                for (let i = 0; i < slides.length; i += 1) {
                    slides[i].swiperSlideOffset =
                        (swiper.isHorizontal()
                            ? slides[i].offsetLeft
                            : slides[i].offsetTop) -
                        minusOffset -
                        swiper.cssOverflowAdjustment();
                }
            }

            function updateSlidesProgress(translate) {
                if (translate === void 0) {
                    translate = (this && this.translate) || 0;
                }
                const swiper = this;
                const params = swiper.params;
                const { slides, rtlTranslate: rtl, snapGrid } = swiper;
                if (slides.length === 0) return;
                if (typeof slides[0].swiperSlideOffset === "undefined")
                    swiper.updateSlidesOffset();
                let offsetCenter = -translate;
                if (rtl) offsetCenter = translate;

                // Visible Slides
                slides.forEach((slideEl) => {
                    slideEl.classList.remove(params.slideVisibleClass);
                });
                swiper.visibleSlidesIndexes = [];
                swiper.visibleSlides = [];
                let spaceBetween = params.spaceBetween;
                if (
                    typeof spaceBetween === "string" &&
                    spaceBetween.indexOf("%") >= 0
                ) {
                    spaceBetween =
                        (parseFloat(spaceBetween.replace("%", "")) / 100) * swiper.size;
                } else if (typeof spaceBetween === "string") {
                    spaceBetween = parseFloat(spaceBetween);
                }
                for (let i = 0; i < slides.length; i += 1) {
                    const slide = slides[i];
                    let slideOffset = slide.swiperSlideOffset;
                    if (params.cssMode && params.centeredSlides) {
                        slideOffset -= slides[0].swiperSlideOffset;
                    }
                    const slideProgress =
                        (offsetCenter +
                            (params.centeredSlides ? swiper.minTranslate() : 0) -
                            slideOffset) /
                        (slide.swiperSlideSize + spaceBetween);
                    const originalSlideProgress =
                        (offsetCenter -
                            snapGrid[0] +
                            (params.centeredSlides ? swiper.minTranslate() : 0) -
                            slideOffset) /
                        (slide.swiperSlideSize + spaceBetween);
                    const slideBefore = -(offsetCenter - slideOffset);
                    const slideAfter = slideBefore + swiper.slidesSizesGrid[i];
                    const isVisible =
                        (slideBefore >= 0 && slideBefore < swiper.size - 1) ||
                        (slideAfter > 1 && slideAfter <= swiper.size) ||
                        (slideBefore <= 0 && slideAfter >= swiper.size);
                    if (isVisible) {
                        swiper.visibleSlides.push(slide);
                        swiper.visibleSlidesIndexes.push(i);
                        slides[i].classList.add(params.slideVisibleClass);
                    }
                    slide.progress = rtl ? -slideProgress : slideProgress;
                    slide.originalProgress = rtl
                        ? -originalSlideProgress
                        : originalSlideProgress;
                }
            }

            function updateProgress(translate) {
                const swiper = this;
                if (typeof translate === "undefined") {
                    const multiplier = swiper.rtlTranslate ? -1 : 1;
                    // eslint-disable-next-line
                    translate =
                        (swiper && swiper.translate && swiper.translate * multiplier) ||
                        0;
                }
                const params = swiper.params;
                const translatesDiff = swiper.maxTranslate() - swiper.minTranslate();
                let { progress, isBeginning, isEnd, progressLoop } = swiper;
                const wasBeginning = isBeginning;
                const wasEnd = isEnd;
                if (translatesDiff === 0) {
                    progress = 0;
                    isBeginning = true;
                    isEnd = true;
                } else {
                    progress = (translate - swiper.minTranslate()) / translatesDiff;
                    const isBeginningRounded =
                        Math.abs(translate - swiper.minTranslate()) < 1;
                    const isEndRounded =
                        Math.abs(translate - swiper.maxTranslate()) < 1;
                    isBeginning = isBeginningRounded || progress <= 0;
                    isEnd = isEndRounded || progress >= 1;
                    if (isBeginningRounded) progress = 0;
                    if (isEndRounded) progress = 1;
                }
                if (params.loop) {
                    const firstSlideIndex = swiper.getSlideIndexByData(0);
                    const lastSlideIndex = swiper.getSlideIndexByData(
                        swiper.slides.length - 1
                    );
                    const firstSlideTranslate = swiper.slidesGrid[firstSlideIndex];
                    const lastSlideTranslate = swiper.slidesGrid[lastSlideIndex];
                    const translateMax =
                        swiper.slidesGrid[swiper.slidesGrid.length - 1];
                    const translateAbs = Math.abs(translate);
                    if (translateAbs >= firstSlideTranslate) {
                        progressLoop =
                            (translateAbs - firstSlideTranslate) / translateMax;
                    } else {
                        progressLoop =
                            (translateAbs + translateMax - lastSlideTranslate) /
                            translateMax;
                    }
                    if (progressLoop > 1) progressLoop -= 1;
                }
                Object.assign(swiper, {
                    progress,
                    progressLoop,
                    isBeginning,
                    isEnd,
                });
                if (
                    params.watchSlidesProgress ||
                    (params.centeredSlides && params.autoHeight)
                )
                    swiper.updateSlidesProgress(translate);
                if (isBeginning && !wasBeginning) {
                    swiper.emit("reachBeginning toEdge");
                }
                if (isEnd && !wasEnd) {
                    swiper.emit("reachEnd toEdge");
                }
                if ((wasBeginning && !isBeginning) || (wasEnd && !isEnd)) {
                    swiper.emit("fromEdge");
                }
                swiper.emit("progress", progress);
            }

            function updateSlidesClasses() {
                const swiper = this;
                const { slides, params, slidesEl, activeIndex } = swiper;
                const isVirtual = swiper.virtual && params.virtual.enabled;
                const getFilteredSlide = (selector) => {
                    return elementChildren(
                        slidesEl,
                        `.${params.slideClass}${selector}, swiper-slide${selector}`
                    )[0];
                };
                slides.forEach((slideEl) => {
                    slideEl.classList.remove(
                        params.slideActiveClass,
                        params.slideNextClass,
                        params.slidePrevClass
                    );
                });
                let activeSlide;
                if (isVirtual) {
                    if (params.loop) {
                        let slideIndex = activeIndex - swiper.virtual.slidesBefore;
                        if (slideIndex < 0)
                            slideIndex = swiper.virtual.slides.length + slideIndex;
                        if (slideIndex >= swiper.virtual.slides.length)
                            slideIndex -= swiper.virtual.slides.length;
                        activeSlide = getFilteredSlide(
                            `[data-swiper-slide-index="${slideIndex}"]`
                        );
                    } else {
                        activeSlide = getFilteredSlide(
                            `[data-swiper-slide-index="${activeIndex}"]`
                        );
                    }
                } else {
                    activeSlide = slides[activeIndex];
                }
                if (activeSlide) {
                    // Active classes
                    activeSlide.classList.add(params.slideActiveClass);

                    // Next Slide
                    let nextSlide = elementNextAll(
                        activeSlide,
                        `.${params.slideClass}, swiper-slide`
                    )[0];
                    if (params.loop && !nextSlide) {
                        nextSlide = slides[0];
                    }
                    if (nextSlide) {
                        nextSlide.classList.add(params.slideNextClass);
                    }
                    // Prev Slide
                    let prevSlide = elementPrevAll(
                        activeSlide,
                        `.${params.slideClass}, swiper-slide`
                    )[0];
                    if (params.loop && !prevSlide === 0) {
                        prevSlide = slides[slides.length - 1];
                    }
                    if (prevSlide) {
                        prevSlide.classList.add(params.slidePrevClass);
                    }
                }
                swiper.emitSlidesClasses();
            }

            const processLazyPreloader = (swiper, imageEl) => {
                if (!swiper || swiper.destroyed || !swiper.params) return;
                const slideSelector = () =>
                    swiper.isElement ? `swiper-slide` : `.${swiper.params.slideClass}`;
                const slideEl = imageEl.closest(slideSelector());
                if (slideEl) {
                    const lazyEl = slideEl.querySelector(
                        `.${swiper.params.lazyPreloaderClass}`
                    );
                    if (lazyEl) lazyEl.remove();
                }
            };
            const unlazy = (swiper, index) => {
                if (!swiper.slides[index]) return;
                const imageEl =
                    swiper.slides[index].querySelector('[loading="lazy"]');
                if (imageEl) imageEl.removeAttribute("loading");
            };
            const preload = (swiper) => {
                if (!swiper || swiper.destroyed || !swiper.params) return;
                let amount = swiper.params.lazyPreloadPrevNext;
                const len = swiper.slides.length;
                if (!len || !amount || amount < 0) return;
                amount = Math.min(amount, len);
                const slidesPerView =
                    swiper.params.slidesPerView === "auto"
                        ? swiper.slidesPerViewDynamic()
                        : Math.ceil(swiper.params.slidesPerView);
                const activeIndex = swiper.activeIndex;
                if (swiper.params.grid && swiper.params.grid.rows > 1) {
                    const activeColumn = activeIndex;
                    const preloadColumns = [activeColumn - amount];
                    preloadColumns.push(
                        ...Array.from({
                            length: amount,
                        }).map((_, i) => {
                            return activeColumn + slidesPerView + i;
                        })
                    );
                    swiper.slides.forEach((slideEl, i) => {
                        if (preloadColumns.includes(slideEl.column)) unlazy(swiper, i);
                    });
                    return;
                }
                const slideIndexLastInView = activeIndex + slidesPerView - 1;
                if (swiper.params.rewind || swiper.params.loop) {
                    for (
                        let i = activeIndex - amount;
                        i <= slideIndexLastInView + amount;
                        i += 1
                    ) {
                        const realIndex = ((i % len) + len) % len;
                        if (realIndex < activeIndex || realIndex > slideIndexLastInView)
                            unlazy(swiper, realIndex);
                    }
                } else {
                    for (
                        let i = Math.max(activeIndex - amount, 0);
                        i <= Math.min(slideIndexLastInView + amount, len - 1);
                        i += 1
                    ) {
                        if (
                            i !== activeIndex &&
                            (i > slideIndexLastInView || i < activeIndex)
                        ) {
                            unlazy(swiper, i);
                        }
                    }
                }
            };

            function getActiveIndexByTranslate(swiper) {
                const { slidesGrid, params } = swiper;
                const translate = swiper.rtlTranslate
                    ? swiper.translate
                    : -swiper.translate;
                let activeIndex;
                for (let i = 0; i < slidesGrid.length; i += 1) {
                    if (typeof slidesGrid[i + 1] !== "undefined") {
                        if (
                            translate >= slidesGrid[i] &&
                            translate <
                            slidesGrid[i + 1] - (slidesGrid[i + 1] - slidesGrid[i]) / 2
                        ) {
                            activeIndex = i;
                        } else if (
                            translate >= slidesGrid[i] &&
                            translate < slidesGrid[i + 1]
                        ) {
                            activeIndex = i + 1;
                        }
                    } else if (translate >= slidesGrid[i]) {
                        activeIndex = i;
                    }
                }
                // Normalize slideIndex
                if (params.normalizeSlideIndex) {
                    if (activeIndex < 0 || typeof activeIndex === "undefined")
                        activeIndex = 0;
                }
                return activeIndex;
            }
            function updateActiveIndex(newActiveIndex) {
                const swiper = this;
                const translate = swiper.rtlTranslate
                    ? swiper.translate
                    : -swiper.translate;
                const {
                    snapGrid,
                    params,
                    activeIndex: previousIndex,
                    realIndex: previousRealIndex,
                    snapIndex: previousSnapIndex,
                } = swiper;
                let activeIndex = newActiveIndex;
                let snapIndex;
                const getVirtualRealIndex = (aIndex) => {
                    let realIndex = aIndex - swiper.virtual.slidesBefore;
                    if (realIndex < 0) {
                        realIndex = swiper.virtual.slides.length + realIndex;
                    }
                    if (realIndex >= swiper.virtual.slides.length) {
                        realIndex -= swiper.virtual.slides.length;
                    }
                    return realIndex;
                };
                if (typeof activeIndex === "undefined") {
                    activeIndex = getActiveIndexByTranslate(swiper);
                }
                if (snapGrid.indexOf(translate) >= 0) {
                    snapIndex = snapGrid.indexOf(translate);
                } else {
                    const skip = Math.min(params.slidesPerGroupSkip, activeIndex);
                    snapIndex =
                        skip + Math.floor((activeIndex - skip) / params.slidesPerGroup);
                }
                if (snapIndex >= snapGrid.length) snapIndex = snapGrid.length - 1;
                if (activeIndex === previousIndex) {
                    if (snapIndex !== previousSnapIndex) {
                        swiper.snapIndex = snapIndex;
                        swiper.emit("snapIndexChange");
                    }
                    if (
                        swiper.params.loop &&
                        swiper.virtual &&
                        swiper.params.virtual.enabled
                    ) {
                        swiper.realIndex = getVirtualRealIndex(activeIndex);
                    }
                    return;
                }
                // Get real index
                let realIndex;
                if (swiper.virtual && params.virtual.enabled && params.loop) {
                    realIndex = getVirtualRealIndex(activeIndex);
                } else if (swiper.slides[activeIndex]) {
                    realIndex = parseInt(
                        swiper.slides[activeIndex].getAttribute(
                            "data-swiper-slide-index"
                        ) || activeIndex,
                        10
                    );
                } else {
                    realIndex = activeIndex;
                }
                Object.assign(swiper, {
                    previousSnapIndex,
                    snapIndex,
                    previousRealIndex,
                    realIndex,
                    previousIndex,
                    activeIndex,
                });
                if (swiper.initialized) {
                    preload(swiper);
                }
                swiper.emit("activeIndexChange");
                swiper.emit("snapIndexChange");
                if (previousRealIndex !== realIndex) {
                    swiper.emit("realIndexChange");
                }
                if (swiper.initialized || swiper.params.runCallbacksOnInit) {
                    swiper.emit("slideChange");
                }
            }

            function updateClickedSlide(e) {
                const swiper = this;
                const params = swiper.params;
                const slide = e.closest(`.${params.slideClass}, swiper-slide`);
                let slideFound = false;
                let slideIndex;
                if (slide) {
                    for (let i = 0; i < swiper.slides.length; i += 1) {
                        if (swiper.slides[i] === slide) {
                            slideFound = true;
                            slideIndex = i;
                            break;
                        }
                    }
                }
                if (slide && slideFound) {
                    swiper.clickedSlide = slide;
                    if (swiper.virtual && swiper.params.virtual.enabled) {
                        swiper.clickedIndex = parseInt(
                            slide.getAttribute("data-swiper-slide-index"),
                            10
                        );
                    } else {
                        swiper.clickedIndex = slideIndex;
                    }
                } else {
                    swiper.clickedSlide = undefined;
                    swiper.clickedIndex = undefined;
                    return;
                }
                if (
                    params.slideToClickedSlide &&
                    swiper.clickedIndex !== undefined &&
                    swiper.clickedIndex !== swiper.activeIndex
                ) {
                    swiper.slideToClickedSlide();
                }
            }

            var update = {
                updateSize,
                updateSlides,
                updateAutoHeight,
                updateSlidesOffset,
                updateSlidesProgress,
                updateProgress,
                updateSlidesClasses,
                updateActiveIndex,
                updateClickedSlide,
            };

            function getSwiperTranslate(axis) {
                if (axis === void 0) {
                    axis = this.isHorizontal() ? "x" : "y";
                }
                const swiper = this;
                const { params, rtlTranslate: rtl, translate, wrapperEl } = swiper;
                if (params.virtualTranslate) {
                    return rtl ? -translate : translate;
                }
                if (params.cssMode) {
                    return translate;
                }
                let currentTranslate = getTranslate(wrapperEl, axis);
                currentTranslate += swiper.cssOverflowAdjustment();
                if (rtl) currentTranslate = -currentTranslate;
                return currentTranslate || 0;
            }

            function setTranslate(translate, byController) {
                const swiper = this;
                const { rtlTranslate: rtl, params, wrapperEl, progress } = swiper;
                let x = 0;
                let y = 0;
                const z = 0;
                if (swiper.isHorizontal()) {
                    x = rtl ? -translate : translate;
                } else {
                    y = translate;
                }
                if (params.roundLengths) {
                    x = Math.floor(x);
                    y = Math.floor(y);
                }
                swiper.previousTranslate = swiper.translate;
                swiper.translate = swiper.isHorizontal() ? x : y;
                if (params.cssMode) {
                    wrapperEl[swiper.isHorizontal() ? "scrollLeft" : "scrollTop"] =
                        swiper.isHorizontal() ? -x : -y;
                } else if (!params.virtualTranslate) {
                    if (swiper.isHorizontal()) {
                        x -= swiper.cssOverflowAdjustment();
                    } else {
                        y -= swiper.cssOverflowAdjustment();
                    }
                    wrapperEl.style.transform = `translate3d(${x}px, ${y}px, ${z}px)`;
                }

                // Check if we need to update progress
                let newProgress;
                const translatesDiff = swiper.maxTranslate() - swiper.minTranslate();
                if (translatesDiff === 0) {
                    newProgress = 0;
                } else {
                    newProgress = (translate - swiper.minTranslate()) / translatesDiff;
                }
                if (newProgress !== progress) {
                    swiper.updateProgress(translate);
                }
                swiper.emit("setTranslate", swiper.translate, byController);
            }

            function minTranslate() {
                return -this.snapGrid[0];
            }

            function maxTranslate() {
                return -this.snapGrid[this.snapGrid.length - 1];
            }

            function translateTo(
                translate,
                speed,
                runCallbacks,
                translateBounds,
                internal
            ) {
                if (translate === void 0) {
                    translate = 0;
                }
                if (speed === void 0) {
                    speed = this.params.speed;
                }
                if (runCallbacks === void 0) {
                    runCallbacks = true;
                }
                if (translateBounds === void 0) {
                    translateBounds = true;
                }
                const swiper = this;
                const { params, wrapperEl } = swiper;
                if (swiper.animating && params.preventInteractionOnTransition) {
                    return false;
                }
                const minTranslate = swiper.minTranslate();
                const maxTranslate = swiper.maxTranslate();
                let newTranslate;
                if (translateBounds && translate > minTranslate)
                    newTranslate = minTranslate;
                else if (translateBounds && translate < maxTranslate)
                    newTranslate = maxTranslate;
                else newTranslate = translate;

                // Update progress
                swiper.updateProgress(newTranslate);
                if (params.cssMode) {
                    const isH = swiper.isHorizontal();
                    if (speed === 0) {
                        wrapperEl[isH ? "scrollLeft" : "scrollTop"] = -newTranslate;
                    } else {
                        if (!swiper.support.smoothScroll) {
                            animateCSSModeScroll({
                                swiper,
                                targetPosition: -newTranslate,
                                side: isH ? "left" : "top",
                            });
                            return true;
                        }
                        wrapperEl.scrollTo({
                            [isH ? "left" : "top"]: -newTranslate,
                            behavior: "smooth",
                        });
                    }
                    return true;
                }
                if (speed === 0) {
                    swiper.setTransition(0);
                    swiper.setTranslate(newTranslate);
                    if (runCallbacks) {
                        swiper.emit("beforeTransitionStart", speed, internal);
                        swiper.emit("transitionEnd");
                    }
                } else {
                    swiper.setTransition(speed);
                    swiper.setTranslate(newTranslate);
                    if (runCallbacks) {
                        swiper.emit("beforeTransitionStart", speed, internal);
                        swiper.emit("transitionStart");
                    }
                    if (!swiper.animating) {
                        swiper.animating = true;
                        if (!swiper.onTranslateToWrapperTransitionEnd) {
                            swiper.onTranslateToWrapperTransitionEnd =
                                function transitionEnd(e) {
                                    if (!swiper || swiper.destroyed) return;
                                    if (e.target !== this) return;
                                    swiper.wrapperEl.removeEventListener(
                                        "transitionend",
                                        swiper.onTranslateToWrapperTransitionEnd
                                    );
                                    swiper.onTranslateToWrapperTransitionEnd = null;
                                    delete swiper.onTranslateToWrapperTransitionEnd;
                                    if (runCallbacks) {
                                        swiper.emit("transitionEnd");
                                    }
                                };
                        }
                        swiper.wrapperEl.addEventListener(
                            "transitionend",
                            swiper.onTranslateToWrapperTransitionEnd
                        );
                    }
                }
                return true;
            }

            var translate = {
                getTranslate: getSwiperTranslate,
                setTranslate,
                minTranslate,
                maxTranslate,
                translateTo,
            };

            function setTransition(duration, byController) {
                const swiper = this;
                if (!swiper.params.cssMode) {
                    swiper.wrapperEl.style.transitionDuration = `${duration}ms`;
                }
                swiper.emit("setTransition", duration, byController);
            }

            function transitionEmit(_ref) {
                let { swiper, runCallbacks, direction, step } = _ref;
                const { activeIndex, previousIndex } = swiper;
                let dir = direction;
                if (!dir) {
                    if (activeIndex > previousIndex) dir = "next";
                    else if (activeIndex < previousIndex) dir = "prev";
                    else dir = "reset";
                }
                swiper.emit(`transition${step}`);
                if (runCallbacks && activeIndex !== previousIndex) {
                    if (dir === "reset") {
                        swiper.emit(`slideResetTransition${step}`);
                        return;
                    }
                    swiper.emit(`slideChangeTransition${step}`);
                    if (dir === "next") {
                        swiper.emit(`slideNextTransition${step}`);
                    } else {
                        swiper.emit(`slidePrevTransition${step}`);
                    }
                }
            }

            function transitionStart(runCallbacks, direction) {
                if (runCallbacks === void 0) {
                    runCallbacks = true;
                }
                const swiper = this;
                const { params } = swiper;
                if (params.cssMode) return;
                if (params.autoHeight) {
                    swiper.updateAutoHeight();
                }
                transitionEmit({
                    swiper,
                    runCallbacks,
                    direction,
                    step: "Start",
                });
            }

            function transitionEnd(runCallbacks, direction) {
                if (runCallbacks === void 0) {
                    runCallbacks = true;
                }
                const swiper = this;
                const { params } = swiper;
                swiper.animating = false;
                if (params.cssMode) return;
                swiper.setTransition(0);
                transitionEmit({
                    swiper,
                    runCallbacks,
                    direction,
                    step: "End",
                });
            }

            var transition = {
                setTransition,
                transitionStart,
                transitionEnd,
            };

            function slideTo(index, speed, runCallbacks, internal, initial) {
                if (index === void 0) {
                    index = 0;
                }
                if (speed === void 0) {
                    speed = this.params.speed;
                }
                if (runCallbacks === void 0) {
                    runCallbacks = true;
                }
                if (typeof index === "string") {
                    index = parseInt(index, 10);
                }
                const swiper = this;
                let slideIndex = index;
                if (slideIndex < 0) slideIndex = 0;
                const {
                    params,
                    snapGrid,
                    slidesGrid,
                    previousIndex,
                    activeIndex,
                    rtlTranslate: rtl,
                    wrapperEl,
                    enabled,
                } = swiper;
                if (
                    (swiper.animating && params.preventInteractionOnTransition) ||
                    (!enabled && !internal && !initial)
                ) {
                    return false;
                }
                const skip = Math.min(swiper.params.slidesPerGroupSkip, slideIndex);
                let snapIndex =
                    skip +
                    Math.floor((slideIndex - skip) / swiper.params.slidesPerGroup);
                if (snapIndex >= snapGrid.length) snapIndex = snapGrid.length - 1;
                const translate = -snapGrid[snapIndex];
                // Normalize slideIndex
                if (params.normalizeSlideIndex) {
                    for (let i = 0; i < slidesGrid.length; i += 1) {
                        const normalizedTranslate = -Math.floor(translate * 100);
                        const normalizedGrid = Math.floor(slidesGrid[i] * 100);
                        const normalizedGridNext = Math.floor(slidesGrid[i + 1] * 100);
                        if (typeof slidesGrid[i + 1] !== "undefined") {
                            if (
                                normalizedTranslate >= normalizedGrid &&
                                normalizedTranslate <
                                normalizedGridNext -
                                (normalizedGridNext - normalizedGrid) / 2
                            ) {
                                slideIndex = i;
                            } else if (
                                normalizedTranslate >= normalizedGrid &&
                                normalizedTranslate < normalizedGridNext
                            ) {
                                slideIndex = i + 1;
                            }
                        } else if (normalizedTranslate >= normalizedGrid) {
                            slideIndex = i;
                        }
                    }
                }
                // Directions locks
                if (swiper.initialized && slideIndex !== activeIndex) {
                    if (
                        !swiper.allowSlideNext &&
                        (rtl
                            ? translate > swiper.translate &&
                            translate > swiper.minTranslate()
                            : translate < swiper.translate &&
                            translate < swiper.minTranslate())
                    ) {
                        return false;
                    }
                    if (
                        !swiper.allowSlidePrev &&
                        translate > swiper.translate &&
                        translate > swiper.maxTranslate()
                    ) {
                        if ((activeIndex || 0) !== slideIndex) {
                            return false;
                        }
                    }
                }
                if (slideIndex !== (previousIndex || 0) && runCallbacks) {
                    swiper.emit("beforeSlideChangeStart");
                }

                // Update progress
                swiper.updateProgress(translate);
                let direction;
                if (slideIndex > activeIndex) direction = "next";
                else if (slideIndex < activeIndex) direction = "prev";
                else direction = "reset";

                // Update Index
                if (
                    (rtl && -translate === swiper.translate) ||
                    (!rtl && translate === swiper.translate)
                ) {
                    swiper.updateActiveIndex(slideIndex);
                    // Update Height
                    if (params.autoHeight) {
                        swiper.updateAutoHeight();
                    }
                    swiper.updateSlidesClasses();
                    if (params.effect !== "slide") {
                        swiper.setTranslate(translate);
                    }
                    if (direction !== "reset") {
                        swiper.transitionStart(runCallbacks, direction);
                        swiper.transitionEnd(runCallbacks, direction);
                    }
                    return false;
                }
                if (params.cssMode) {
                    const isH = swiper.isHorizontal();
                    const t = rtl ? translate : -translate;
                    if (speed === 0) {
                        const isVirtual = swiper.virtual && swiper.params.virtual.enabled;
                        if (isVirtual) {
                            swiper.wrapperEl.style.scrollSnapType = "none";
                            swiper._immediateVirtual = true;
                        }
                        if (
                            isVirtual &&
                            !swiper._cssModeVirtualInitialSet &&
                            swiper.params.initialSlide > 0
                        ) {
                            swiper._cssModeVirtualInitialSet = true;
                            requestAnimationFrame(() => {
                                wrapperEl[isH ? "scrollLeft" : "scrollTop"] = t;
                            });
                        } else {
                            wrapperEl[isH ? "scrollLeft" : "scrollTop"] = t;
                        }
                        if (isVirtual) {
                            requestAnimationFrame(() => {
                                swiper.wrapperEl.style.scrollSnapType = "";
                                swiper._immediateVirtual = false;
                            });
                        }
                    } else {
                        if (!swiper.support.smoothScroll) {
                            animateCSSModeScroll({
                                swiper,
                                targetPosition: t,
                                side: isH ? "left" : "top",
                            });
                            return true;
                        }
                        wrapperEl.scrollTo({
                            [isH ? "left" : "top"]: t,
                            behavior: "smooth",
                        });
                    }
                    return true;
                }
                swiper.setTransition(speed);
                swiper.setTranslate(translate);
                swiper.updateActiveIndex(slideIndex);
                swiper.updateSlidesClasses();
                swiper.emit("beforeTransitionStart", speed, internal);
                swiper.transitionStart(runCallbacks, direction);
                if (speed === 0) {
                    swiper.transitionEnd(runCallbacks, direction);
                } else if (!swiper.animating) {
                    swiper.animating = true;
                    if (!swiper.onSlideToWrapperTransitionEnd) {
                        swiper.onSlideToWrapperTransitionEnd = function transitionEnd(e) {
                            if (!swiper || swiper.destroyed) return;
                            if (e.target !== this) return;
                            swiper.wrapperEl.removeEventListener(
                                "transitionend",
                                swiper.onSlideToWrapperTransitionEnd
                            );
                            swiper.onSlideToWrapperTransitionEnd = null;
                            delete swiper.onSlideToWrapperTransitionEnd;
                            swiper.transitionEnd(runCallbacks, direction);
                        };
                    }
                    swiper.wrapperEl.addEventListener(
                        "transitionend",
                        swiper.onSlideToWrapperTransitionEnd
                    );
                }
                return true;
            }

            function slideToLoop(index, speed, runCallbacks, internal) {
                if (index === void 0) {
                    index = 0;
                }
                if (speed === void 0) {
                    speed = this.params.speed;
                }
                if (runCallbacks === void 0) {
                    runCallbacks = true;
                }
                if (typeof index === "string") {
                    const indexAsNumber = parseInt(index, 10);
                    index = indexAsNumber;
                }
                const swiper = this;
                let newIndex = index;
                if (swiper.params.loop) {
                    if (swiper.virtual && swiper.params.virtual.enabled) {
                        // eslint-disable-next-line
                        newIndex = newIndex + swiper.virtual.slidesBefore;
                    } else {
                        newIndex = swiper.getSlideIndexByData(newIndex);
                    }
                }
                return swiper.slideTo(newIndex, speed, runCallbacks, internal);
            }

            /* eslint no-unused-vars: "off" */
            function slideNext(speed, runCallbacks, internal) {
                if (speed === void 0) {
                    speed = this.params.speed;
                }
                if (runCallbacks === void 0) {
                    runCallbacks = true;
                }
                const swiper = this;
                const { enabled, params, animating } = swiper;
                if (!enabled) return swiper;
                let perGroup = params.slidesPerGroup;
                if (
                    params.slidesPerView === "auto" &&
                    params.slidesPerGroup === 1 &&
                    params.slidesPerGroupAuto
                ) {
                    perGroup = Math.max(
                        swiper.slidesPerViewDynamic("current", true),
                        1
                    );
                }
                const increment =
                    swiper.activeIndex < params.slidesPerGroupSkip ? 1 : perGroup;
                const isVirtual = swiper.virtual && params.virtual.enabled;
                if (params.loop) {
                    if (animating && !isVirtual && params.loopPreventsSliding)
                        return false;
                    swiper.loopFix({
                        direction: "next",
                    });
                    // eslint-disable-next-line
                    swiper._clientLeft = swiper.wrapperEl.clientLeft;
                }
                if (params.rewind && swiper.isEnd) {
                    return swiper.slideTo(0, speed, runCallbacks, internal);
                }
                return swiper.slideTo(
                    swiper.activeIndex + increment,
                    speed,
                    runCallbacks,
                    internal
                );
            }

            /* eslint no-unused-vars: "off" */
            function slidePrev(speed, runCallbacks, internal) {
                if (speed === void 0) {
                    speed = this.params.speed;
                }
                if (runCallbacks === void 0) {
                    runCallbacks = true;
                }
                const swiper = this;
                const {
                    params,
                    snapGrid,
                    slidesGrid,
                    rtlTranslate,
                    enabled,
                    animating,
                } = swiper;
                if (!enabled) return swiper;
                const isVirtual = swiper.virtual && params.virtual.enabled;
                if (params.loop) {
                    if (animating && !isVirtual && params.loopPreventsSliding)
                        return false;
                    swiper.loopFix({
                        direction: "prev",
                    });
                    // eslint-disable-next-line
                    swiper._clientLeft = swiper.wrapperEl.clientLeft;
                }
                const translate = rtlTranslate ? swiper.translate : -swiper.translate;
                function normalize(val) {
                    if (val < 0) return -Math.floor(Math.abs(val));
                    return Math.floor(val);
                }
                const normalizedTranslate = normalize(translate);
                const normalizedSnapGrid = snapGrid.map((val) => normalize(val));
                let prevSnap =
                    snapGrid[normalizedSnapGrid.indexOf(normalizedTranslate) - 1];
                if (typeof prevSnap === "undefined" && params.cssMode) {
                    let prevSnapIndex;
                    snapGrid.forEach((snap, snapIndex) => {
                        if (normalizedTranslate >= snap) {
                            // prevSnap = snap;
                            prevSnapIndex = snapIndex;
                        }
                    });
                    if (typeof prevSnapIndex !== "undefined") {
                        prevSnap =
                            snapGrid[prevSnapIndex > 0 ? prevSnapIndex - 1 : prevSnapIndex];
                    }
                }
                let prevIndex = 0;
                if (typeof prevSnap !== "undefined") {
                    prevIndex = slidesGrid.indexOf(prevSnap);
                    if (prevIndex < 0) prevIndex = swiper.activeIndex - 1;
                    if (
                        params.slidesPerView === "auto" &&
                        params.slidesPerGroup === 1 &&
                        params.slidesPerGroupAuto
                    ) {
                        prevIndex =
                            prevIndex - swiper.slidesPerViewDynamic("previous", true) + 1;
                        prevIndex = Math.max(prevIndex, 0);
                    }
                }
                if (params.rewind && swiper.isBeginning) {
                    const lastIndex =
                        swiper.params.virtual &&
                            swiper.params.virtual.enabled &&
                            swiper.virtual
                            ? swiper.virtual.slides.length - 1
                            : swiper.slides.length - 1;
                    return swiper.slideTo(lastIndex, speed, runCallbacks, internal);
                }
                return swiper.slideTo(prevIndex, speed, runCallbacks, internal);
            }

            /* eslint no-unused-vars: "off" */
            function slideReset(speed, runCallbacks, internal) {
                if (speed === void 0) {
                    speed = this.params.speed;
                }
                if (runCallbacks === void 0) {
                    runCallbacks = true;
                }
                const swiper = this;
                return swiper.slideTo(
                    swiper.activeIndex,
                    speed,
                    runCallbacks,
                    internal
                );
            }

            /* eslint no-unused-vars: "off" */
            function slideToClosest(speed, runCallbacks, internal, threshold) {
                if (speed === void 0) {
                    speed = this.params.speed;
                }
                if (runCallbacks === void 0) {
                    runCallbacks = true;
                }
                if (threshold === void 0) {
                    threshold = 0.5;
                }
                const swiper = this;
                let index = swiper.activeIndex;
                const skip = Math.min(swiper.params.slidesPerGroupSkip, index);
                const snapIndex =
                    skip + Math.floor((index - skip) / swiper.params.slidesPerGroup);
                const translate = swiper.rtlTranslate
                    ? swiper.translate
                    : -swiper.translate;
                if (translate >= swiper.snapGrid[snapIndex]) {
                    // The current translate is on or after the current snap index, so the choice
                    // is between the current index and the one after it.
                    const currentSnap = swiper.snapGrid[snapIndex];
                    const nextSnap = swiper.snapGrid[snapIndex + 1];
                    if (
                        translate - currentSnap >
                        (nextSnap - currentSnap) * threshold
                    ) {
                        index += swiper.params.slidesPerGroup;
                    }
                } else {
                    // The current translate is before the current snap index, so the choice
                    // is between the current index and the one before it.
                    const prevSnap = swiper.snapGrid[snapIndex - 1];
                    const currentSnap = swiper.snapGrid[snapIndex];
                    if (translate - prevSnap <= (currentSnap - prevSnap) * threshold) {
                        index -= swiper.params.slidesPerGroup;
                    }
                }
                index = Math.max(index, 0);
                index = Math.min(index, swiper.slidesGrid.length - 1);
                return swiper.slideTo(index, speed, runCallbacks, internal);
            }

            function slideToClickedSlide() {
                const swiper = this;
                const { params, slidesEl } = swiper;
                const slidesPerView =
                    params.slidesPerView === "auto"
                        ? swiper.slidesPerViewDynamic()
                        : params.slidesPerView;
                let slideToIndex = swiper.clickedIndex;
                let realIndex;
                const slideSelector = swiper.isElement
                    ? `swiper-slide`
                    : `.${params.slideClass}`;
                if (params.loop) {
                    if (swiper.animating) return;
                    realIndex = parseInt(
                        swiper.clickedSlide.getAttribute("data-swiper-slide-index"),
                        10
                    );
                    if (params.centeredSlides) {
                        if (
                            slideToIndex < swiper.loopedSlides - slidesPerView / 2 ||
                            slideToIndex >
                            swiper.slides.length - swiper.loopedSlides + slidesPerView / 2
                        ) {
                            swiper.loopFix();
                            slideToIndex = swiper.getSlideIndex(
                                elementChildren(
                                    slidesEl,
                                    `${slideSelector}[data-swiper-slide-index="${realIndex}"]`
                                )[0]
                            );
                            nextTick(() => {
                                swiper.slideTo(slideToIndex);
                            });
                        } else {
                            swiper.slideTo(slideToIndex);
                        }
                    } else if (slideToIndex > swiper.slides.length - slidesPerView) {
                        swiper.loopFix();
                        slideToIndex = swiper.getSlideIndex(
                            elementChildren(
                                slidesEl,
                                `${slideSelector}[data-swiper-slide-index="${realIndex}"]`
                            )[0]
                        );
                        nextTick(() => {
                            swiper.slideTo(slideToIndex);
                        });
                    } else {
                        swiper.slideTo(slideToIndex);
                    }
                } else {
                    swiper.slideTo(slideToIndex);
                }
            }

            var slide = {
                slideTo,
                slideToLoop,
                slideNext,
                slidePrev,
                slideReset,
                slideToClosest,
                slideToClickedSlide,
            };

            function loopCreate(slideRealIndex) {
                const swiper = this;
                const { params, slidesEl } = swiper;
                if (!params.loop || (swiper.virtual && swiper.params.virtual.enabled))
                    return;
                const slides = elementChildren(
                    slidesEl,
                    `.${params.slideClass}, swiper-slide`
                );
                slides.forEach((el, index) => {
                    el.setAttribute("data-swiper-slide-index", index);
                });
                swiper.loopFix({
                    slideRealIndex,
                    direction: params.centeredSlides ? undefined : "next",
                });
            }

            function loopFix(_temp) {
                let {
                    slideRealIndex,
                    slideTo = true,
                    direction,
                    setTranslate,
                    activeSlideIndex,
                    byController,
                    byMousewheel,
                } = _temp === void 0 ? {} : _temp;
                const swiper = this;
                if (!swiper.params.loop) return;
                swiper.emit("beforeLoopFix");
                const { slides, allowSlidePrev, allowSlideNext, slidesEl, params } =
                    swiper;
                swiper.allowSlidePrev = true;
                swiper.allowSlideNext = true;
                if (swiper.virtual && params.virtual.enabled) {
                    if (slideTo) {
                        if (!params.centeredSlides && swiper.snapIndex === 0) {
                            swiper.slideTo(swiper.virtual.slides.length, 0, false, true);
                        } else if (
                            params.centeredSlides &&
                            swiper.snapIndex < params.slidesPerView
                        ) {
                            swiper.slideTo(
                                swiper.virtual.slides.length + swiper.snapIndex,
                                0,
                                false,
                                true
                            );
                        } else if (swiper.snapIndex === swiper.snapGrid.length - 1) {
                            swiper.slideTo(swiper.virtual.slidesBefore, 0, false, true);
                        }
                    }
                    swiper.allowSlidePrev = allowSlidePrev;
                    swiper.allowSlideNext = allowSlideNext;
                    swiper.emit("loopFix");
                    return;
                }
                const slidesPerView =
                    params.slidesPerView === "auto"
                        ? swiper.slidesPerViewDynamic()
                        : Math.ceil(parseFloat(params.slidesPerView, 10));
                let loopedSlides = params.loopedSlides || slidesPerView;
                if (loopedSlides % params.slidesPerGroup !== 0) {
                    loopedSlides +=
                        params.slidesPerGroup - (loopedSlides % params.slidesPerGroup);
                }
                swiper.loopedSlides = loopedSlides;
                const prependSlidesIndexes = [];
                const appendSlidesIndexes = [];
                let activeIndex = swiper.activeIndex;
                if (typeof activeSlideIndex === "undefined") {
                    activeSlideIndex = swiper.getSlideIndex(
                        swiper.slides.filter((el) =>
                            el.classList.contains(params.slideActiveClass)
                        )[0]
                    );
                } else {
                    activeIndex = activeSlideIndex;
                }
                const isNext = direction === "next" || !direction;
                const isPrev = direction === "prev" || !direction;
                let slidesPrepended = 0;
                let slidesAppended = 0;
                // prepend last slides before start
                if (activeSlideIndex < loopedSlides) {
                    slidesPrepended = Math.max(
                        loopedSlides - activeSlideIndex,
                        params.slidesPerGroup
                    );
                    for (let i = 0; i < loopedSlides - activeSlideIndex; i += 1) {
                        const index = i - Math.floor(i / slides.length) * slides.length;
                        prependSlidesIndexes.push(slides.length - index - 1);
                    }
                } else if (
                    activeSlideIndex /* + slidesPerView */ >
                    swiper.slides.length - loopedSlides * 2
                ) {
                    slidesAppended = Math.max(
                        activeSlideIndex - (swiper.slides.length - loopedSlides * 2),
                        params.slidesPerGroup
                    );
                    for (let i = 0; i < slidesAppended; i += 1) {
                        const index = i - Math.floor(i / slides.length) * slides.length;
                        appendSlidesIndexes.push(index);
                    }
                }
                if (isPrev) {
                    prependSlidesIndexes.forEach((index) => {
                        swiper.slides[index].swiperLoopMoveDOM = true;
                        slidesEl.prepend(swiper.slides[index]);
                        swiper.slides[index].swiperLoopMoveDOM = false;
                    });
                }
                if (isNext) {
                    appendSlidesIndexes.forEach((index) => {
                        swiper.slides[index].swiperLoopMoveDOM = true;
                        slidesEl.append(swiper.slides[index]);
                        swiper.slides[index].swiperLoopMoveDOM = false;
                    });
                }
                swiper.recalcSlides();
                if (params.slidesPerView === "auto") {
                    swiper.updateSlides();
                }
                if (params.watchSlidesProgress) {
                    swiper.updateSlidesOffset();
                }
                if (slideTo) {
                    if (prependSlidesIndexes.length > 0 && isPrev) {
                        if (typeof slideRealIndex === "undefined") {
                            const currentSlideTranslate = swiper.slidesGrid[activeIndex];
                            const newSlideTranslate =
                                swiper.slidesGrid[activeIndex + slidesPrepended];
                            const diff = newSlideTranslate - currentSlideTranslate;
                            if (byMousewheel) {
                                swiper.setTranslate(swiper.translate - diff);
                            } else {
                                swiper.slideTo(activeIndex + slidesPrepended, 0, false, true);
                                if (setTranslate) {
                                    swiper.touches[
                                        swiper.isHorizontal() ? "startX" : "startY"
                                    ] += diff;
                                }
                            }
                        } else {
                            if (setTranslate) {
                                swiper.slideToLoop(slideRealIndex, 0, false, true);
                            }
                        }
                    } else if (appendSlidesIndexes.length > 0 && isNext) {
                        if (typeof slideRealIndex === "undefined") {
                            const currentSlideTranslate = swiper.slidesGrid[activeIndex];
                            const newSlideTranslate =
                                swiper.slidesGrid[activeIndex - slidesAppended];
                            const diff = newSlideTranslate - currentSlideTranslate;
                            if (byMousewheel) {
                                swiper.setTranslate(swiper.translate - diff);
                            } else {
                                swiper.slideTo(activeIndex - slidesAppended, 0, false, true);
                                if (setTranslate) {
                                    swiper.touches[
                                        swiper.isHorizontal() ? "startX" : "startY"
                                    ] += diff;
                                }
                            }
                        } else {
                            swiper.slideToLoop(slideRealIndex, 0, false, true);
                        }
                    }
                }
                swiper.allowSlidePrev = allowSlidePrev;
                swiper.allowSlideNext = allowSlideNext;
                if (swiper.controller && swiper.controller.control && !byController) {
                    const loopParams = {
                        slideRealIndex,
                        slideTo: false,
                        direction,
                        setTranslate,
                        activeSlideIndex,
                        byController: true,
                    };
                    if (Array.isArray(swiper.controller.control)) {
                        swiper.controller.control.forEach((c) => {
                            if (!c.destroyed && c.params.loop) c.loopFix(loopParams);
                        });
                    } else if (
                        swiper.controller.control instanceof swiper.constructor &&
                        swiper.controller.control.params.loop
                    ) {
                        swiper.controller.control.loopFix(loopParams);
                    }
                }
                swiper.emit("loopFix");
            }

            function loopDestroy() {
                const swiper = this;
                const { params, slidesEl } = swiper;
                if (!params.loop || (swiper.virtual && swiper.params.virtual.enabled))
                    return;
                swiper.recalcSlides();
                const newSlidesOrder = [];
                swiper.slides.forEach((slideEl) => {
                    const index =
                        typeof slideEl.swiperSlideIndex === "undefined"
                            ? slideEl.getAttribute("data-swiper-slide-index") * 1
                            : slideEl.swiperSlideIndex;
                    newSlidesOrder[index] = slideEl;
                });
                swiper.slides.forEach((slideEl) => {
                    slideEl.removeAttribute("data-swiper-slide-index");
                });
                newSlidesOrder.forEach((slideEl) => {
                    slidesEl.append(slideEl);
                });
                swiper.recalcSlides();
                swiper.slideTo(swiper.realIndex, 0);
            }

            var loop = {
                loopCreate,
                loopFix,
                loopDestroy,
            };

            function setGrabCursor(moving) {
                const swiper = this;
                if (
                    !swiper.params.simulateTouch ||
                    (swiper.params.watchOverflow && swiper.isLocked) ||
                    swiper.params.cssMode
                )
                    return;
                const el =
                    swiper.params.touchEventsTarget === "container"
                        ? swiper.el
                        : swiper.wrapperEl;
                if (swiper.isElement) {
                    swiper.__preventObserver__ = true;
                }
                el.style.cursor = "move";
                el.style.cursor = moving ? "grabbing" : "grab";
                if (swiper.isElement) {
                    requestAnimationFrame(() => {
                        swiper.__preventObserver__ = false;
                    });
                }
            }

            function unsetGrabCursor() {
                const swiper = this;
                if (
                    (swiper.params.watchOverflow && swiper.isLocked) ||
                    swiper.params.cssMode
                ) {
                    return;
                }
                if (swiper.isElement) {
                    swiper.__preventObserver__ = true;
                }
                swiper[
                    swiper.params.touchEventsTarget === "container" ? "el" : "wrapperEl"
                ].style.cursor = "";
                if (swiper.isElement) {
                    requestAnimationFrame(() => {
                        swiper.__preventObserver__ = false;
                    });
                }
            }

            var grabCursor = {
                setGrabCursor,
                unsetGrabCursor,
            };

            // Modified from https://stackoverflow.com/questions/54520554/custom-element-getrootnode-closest-function-crossing-multiple-parent-shadowd
            function closestElement(selector, base) {
                if (base === void 0) {
                    base = this;
                }
                function __closestFrom(el) {
                    if (!el || el === getDocument() || el === getWindow()) return null;
                    if (el.assignedSlot) el = el.assignedSlot;
                    const found = el.closest(selector);
                    if (!found && !el.getRootNode) {
                        return null;
                    }
                    return found || __closestFrom(el.getRootNode().host);
                }
                return __closestFrom(base);
            }
            function onTouchStart(event) {
                const swiper = this;
                const document = getDocument();
                const window = getWindow();
                const data = swiper.touchEventsData;
                data.evCache.push(event);
                const { params, touches, enabled } = swiper;
                if (!enabled) return;
                if (!params.simulateTouch && event.pointerType === "mouse") return;
                if (swiper.animating && params.preventInteractionOnTransition) {
                    return;
                }
                if (!swiper.animating && params.cssMode && params.loop) {
                    swiper.loopFix();
                }
                let e = event;
                if (e.originalEvent) e = e.originalEvent;
                let targetEl = e.target;
                if (params.touchEventsTarget === "wrapper") {
                    if (!swiper.wrapperEl.contains(targetEl)) return;
                }
                if ("which" in e && e.which === 3) return;
                if ("button" in e && e.button > 0) return;
                if (data.isTouched && data.isMoved) return;

                // change target el for shadow root component
                const swipingClassHasValue =
                    !!params.noSwipingClass && params.noSwipingClass !== "";
                // eslint-disable-next-line
                const eventPath = event.composedPath
                    ? event.composedPath()
                    : event.path;
                if (
                    swipingClassHasValue &&
                    e.target &&
                    e.target.shadowRoot &&
                    eventPath
                ) {
                    targetEl = eventPath[0];
                }
                const noSwipingSelector = params.noSwipingSelector
                    ? params.noSwipingSelector
                    : `.${params.noSwipingClass}`;
                const isTargetShadow = !!(e.target && e.target.shadowRoot);

                // use closestElement for shadow root element to get the actual closest for nested shadow root element
                if (
                    params.noSwiping &&
                    (isTargetShadow
                        ? closestElement(noSwipingSelector, targetEl)
                        : targetEl.closest(noSwipingSelector))
                ) {
                    swiper.allowClick = true;
                    return;
                }
                if (params.swipeHandler) {
                    if (!targetEl.closest(params.swipeHandler)) return;
                }
                touches.currentX = e.pageX;
                touches.currentY = e.pageY;
                const startX = touches.currentX;
                const startY = touches.currentY;

                // Do NOT start if iOS edge swipe is detected. Otherwise iOS app cannot swipe-to-go-back anymore

                const edgeSwipeDetection =
                    params.edgeSwipeDetection || params.iOSEdgeSwipeDetection;
                const edgeSwipeThreshold =
                    params.edgeSwipeThreshold || params.iOSEdgeSwipeThreshold;
                if (
                    edgeSwipeDetection &&
                    (startX <= edgeSwipeThreshold ||
                        startX >= window.innerWidth - edgeSwipeThreshold)
                ) {
                    if (edgeSwipeDetection === "prevent") {
                        event.preventDefault();
                    } else {
                        return;
                    }
                }
                Object.assign(data, {
                    isTouched: true,
                    isMoved: false,
                    allowTouchCallbacks: true,
                    isScrolling: undefined,
                    startMoving: undefined,
                });
                touches.startX = startX;
                touches.startY = startY;
                data.touchStartTime = now();
                swiper.allowClick = true;
                swiper.updateSize();
                swiper.swipeDirection = undefined;
                if (params.threshold > 0) data.allowThresholdMove = false;
                let preventDefault = true;
                if (targetEl.matches(data.focusableElements)) {
                    preventDefault = false;
                    if (targetEl.nodeName === "SELECT") {
                        data.isTouched = false;
                    }
                }
                if (
                    document.activeElement &&
                    document.activeElement.matches(data.focusableElements) &&
                    document.activeElement !== targetEl
                ) {
                    document.activeElement.blur();
                }
                const shouldPreventDefault =
                    preventDefault &&
                    swiper.allowTouchMove &&
                    params.touchStartPreventDefault;
                if (
                    (params.touchStartForcePreventDefault || shouldPreventDefault) &&
                    !targetEl.isContentEditable
                ) {
                    e.preventDefault();
                }
                if (
                    params.freeMode &&
                    params.freeMode.enabled &&
                    swiper.freeMode &&
                    swiper.animating &&
                    !params.cssMode
                ) {
                    swiper.freeMode.onTouchStart();
                }
                swiper.emit("touchStart", e);
            }

            function onTouchMove(event) {
                const document = getDocument();
                const swiper = this;
                const data = swiper.touchEventsData;
                const { params, touches, rtlTranslate: rtl, enabled } = swiper;
                if (!enabled) return;
                if (!params.simulateTouch && event.pointerType === "mouse") return;
                let e = event;
                if (e.originalEvent) e = e.originalEvent;
                if (!data.isTouched) {
                    if (data.startMoving && data.isScrolling) {
                        swiper.emit("touchMoveOpposite", e);
                    }
                    return;
                }
                const pointerIndex = data.evCache.findIndex(
                    (cachedEv) => cachedEv.pointerId === e.pointerId
                );
                if (pointerIndex >= 0) data.evCache[pointerIndex] = e;
                const targetTouch = data.evCache.length > 1 ? data.evCache[0] : e;
                const pageX = targetTouch.pageX;
                const pageY = targetTouch.pageY;
                if (e.preventedByNestedSwiper) {
                    touches.startX = pageX;
                    touches.startY = pageY;
                    return;
                }
                if (!swiper.allowTouchMove) {
                    if (!e.target.matches(data.focusableElements)) {
                        swiper.allowClick = false;
                    }
                    if (data.isTouched) {
                        Object.assign(touches, {
                            startX: pageX,
                            startY: pageY,
                            prevX: swiper.touches.currentX,
                            prevY: swiper.touches.currentY,
                            currentX: pageX,
                            currentY: pageY,
                        });
                        data.touchStartTime = now();
                    }
                    return;
                }
                if (params.touchReleaseOnEdges && !params.loop) {
                    if (swiper.isVertical()) {
                        // Vertical
                        if (
                            (pageY < touches.startY &&
                                swiper.translate <= swiper.maxTranslate()) ||
                            (pageY > touches.startY &&
                                swiper.translate >= swiper.minTranslate())
                        ) {
                            data.isTouched = false;
                            data.isMoved = false;
                            return;
                        }
                    } else if (
                        (pageX < touches.startX &&
                            swiper.translate <= swiper.maxTranslate()) ||
                        (pageX > touches.startX &&
                            swiper.translate >= swiper.minTranslate())
                    ) {
                        return;
                    }
                }
                if (document.activeElement) {
                    if (
                        e.target === document.activeElement &&
                        e.target.matches(data.focusableElements)
                    ) {
                        data.isMoved = true;
                        swiper.allowClick = false;
                        return;
                    }
                }
                if (data.allowTouchCallbacks) {
                    swiper.emit("touchMove", e);
                }
                if (e.targetTouches && e.targetTouches.length > 1) return;
                touches.currentX = pageX;
                touches.currentY = pageY;
                const diffX = touches.currentX - touches.startX;
                const diffY = touches.currentY - touches.startY;
                if (
                    swiper.params.threshold &&
                    Math.sqrt(diffX ** 2 + diffY ** 2) < swiper.params.threshold
                )
                    return;
                if (typeof data.isScrolling === "undefined") {
                    let touchAngle;
                    if (
                        (swiper.isHorizontal() && touches.currentY === touches.startY) ||
                        (swiper.isVertical() && touches.currentX === touches.startX)
                    ) {
                        data.isScrolling = false;
                    } else {
                        // eslint-disable-next-line
                        if (diffX * diffX + diffY * diffY >= 25) {
                            touchAngle =
                                (Math.atan2(Math.abs(diffY), Math.abs(diffX)) * 180) /
                                Math.PI;
                            data.isScrolling = swiper.isHorizontal()
                                ? touchAngle > params.touchAngle
                                : 90 - touchAngle > params.touchAngle;
                        }
                    }
                }
                if (data.isScrolling) {
                    swiper.emit("touchMoveOpposite", e);
                }
                if (typeof data.startMoving === "undefined") {
                    if (
                        touches.currentX !== touches.startX ||
                        touches.currentY !== touches.startY
                    ) {
                        data.startMoving = true;
                    }
                }
                if (
                    data.isScrolling ||
                    (swiper.zoom &&
                        swiper.params.zoom &&
                        swiper.params.zoom.enabled &&
                        data.evCache.length > 1)
                ) {
                    data.isTouched = false;
                    return;
                }
                if (!data.startMoving) {
                    return;
                }
                swiper.allowClick = false;
                if (!params.cssMode && e.cancelable) {
                    e.preventDefault();
                }
                if (params.touchMoveStopPropagation && !params.nested) {
                    e.stopPropagation();
                }
                let diff = swiper.isHorizontal() ? diffX : diffY;
                let touchesDiff = swiper.isHorizontal()
                    ? touches.currentX - touches.previousX
                    : touches.currentY - touches.previousY;
                if (params.oneWayMovement) {
                    diff = Math.abs(diff) * (rtl ? 1 : -1);
                    touchesDiff = Math.abs(touchesDiff) * (rtl ? 1 : -1);
                }
                touches.diff = diff;
                diff *= params.touchRatio;
                if (rtl) {
                    diff = -diff;
                    touchesDiff = -touchesDiff;
                }
                const prevTouchesDirection = swiper.touchesDirection;
                swiper.swipeDirection = diff > 0 ? "prev" : "next";
                swiper.touchesDirection = touchesDiff > 0 ? "prev" : "next";
                const isLoop = swiper.params.loop && !params.cssMode;
                if (!data.isMoved) {
                    if (isLoop) {
                        swiper.loopFix({
                            direction: swiper.swipeDirection,
                        });
                    }
                    data.startTranslate = swiper.getTranslate();
                    swiper.setTransition(0);
                    if (swiper.animating) {
                        const evt = new window.CustomEvent("transitionend", {
                            bubbles: true,
                            cancelable: true,
                        });
                        swiper.wrapperEl.dispatchEvent(evt);
                    }
                    data.allowMomentumBounce = false;
                    // Grab Cursor
                    if (
                        params.grabCursor &&
                        (swiper.allowSlideNext === true || swiper.allowSlidePrev === true)
                    ) {
                        swiper.setGrabCursor(true);
                    }
                    swiper.emit("sliderFirstMove", e);
                }
                let loopFixed;
                if (
                    data.isMoved &&
                    prevTouchesDirection !== swiper.touchesDirection &&
                    isLoop &&
                    Math.abs(diff) >= 1
                ) {
                    // need another loop fix
                    swiper.loopFix({
                        direction: swiper.swipeDirection,
                        setTranslate: true,
                    });
                    loopFixed = true;
                }
                swiper.emit("sliderMove", e);
                data.isMoved = true;
                data.currentTranslate = diff + data.startTranslate;
                let disableParentSwiper = true;
                let resistanceRatio = params.resistanceRatio;
                if (params.touchReleaseOnEdges) {
                    resistanceRatio = 0;
                }
                if (diff > 0) {
                    if (
                        isLoop &&
                        !loopFixed &&
                        data.currentTranslate >
                        (params.centeredSlides
                            ? swiper.minTranslate() - swiper.size / 2
                            : swiper.minTranslate())
                    ) {
                        swiper.loopFix({
                            direction: "prev",
                            setTranslate: true,
                            activeSlideIndex: 0,
                        });
                    }
                    if (data.currentTranslate > swiper.minTranslate()) {
                        disableParentSwiper = false;
                        if (params.resistance) {
                            data.currentTranslate =
                                swiper.minTranslate() -
                                1 +
                                (-swiper.minTranslate() + data.startTranslate + diff) **
                                resistanceRatio;
                        }
                    }
                } else if (diff < 0) {
                    if (
                        isLoop &&
                        !loopFixed &&
                        data.currentTranslate <
                        (params.centeredSlides
                            ? swiper.maxTranslate() + swiper.size / 2
                            : swiper.maxTranslate())
                    ) {
                        swiper.loopFix({
                            direction: "next",
                            setTranslate: true,
                            activeSlideIndex:
                                swiper.slides.length -
                                (params.slidesPerView === "auto"
                                    ? swiper.slidesPerViewDynamic()
                                    : Math.ceil(parseFloat(params.slidesPerView, 10))),
                        });
                    }
                    if (data.currentTranslate < swiper.maxTranslate()) {
                        disableParentSwiper = false;
                        if (params.resistance) {
                            data.currentTranslate =
                                swiper.maxTranslate() +
                                1 -
                                (swiper.maxTranslate() - data.startTranslate - diff) **
                                resistanceRatio;
                        }
                    }
                }
                if (disableParentSwiper) {
                    e.preventedByNestedSwiper = true;
                }

                // Directions locks
                if (
                    !swiper.allowSlideNext &&
                    swiper.swipeDirection === "next" &&
                    data.currentTranslate < data.startTranslate
                ) {
                    data.currentTranslate = data.startTranslate;
                }
                if (
                    !swiper.allowSlidePrev &&
                    swiper.swipeDirection === "prev" &&
                    data.currentTranslate > data.startTranslate
                ) {
                    data.currentTranslate = data.startTranslate;
                }
                if (!swiper.allowSlidePrev && !swiper.allowSlideNext) {
                    data.currentTranslate = data.startTranslate;
                }

                // Threshold
                if (params.threshold > 0) {
                    if (Math.abs(diff) > params.threshold || data.allowThresholdMove) {
                        if (!data.allowThresholdMove) {
                            data.allowThresholdMove = true;
                            touches.startX = touches.currentX;
                            touches.startY = touches.currentY;
                            data.currentTranslate = data.startTranslate;
                            touches.diff = swiper.isHorizontal()
                                ? touches.currentX - touches.startX
                                : touches.currentY - touches.startY;
                            return;
                        }
                    } else {
                        data.currentTranslate = data.startTranslate;
                        return;
                    }
                }
                if (!params.followFinger || params.cssMode) return;

                // Update active index in free mode
                if (
                    (params.freeMode && params.freeMode.enabled && swiper.freeMode) ||
                    params.watchSlidesProgress
                ) {
                    swiper.updateActiveIndex();
                    swiper.updateSlidesClasses();
                }
                if (params.freeMode && params.freeMode.enabled && swiper.freeMode) {
                    swiper.freeMode.onTouchMove();
                }
                // Update progress
                swiper.updateProgress(data.currentTranslate);
                // Update translate
                swiper.setTranslate(data.currentTranslate);
            }

            function onTouchEnd(event) {
                const swiper = this;
                const data = swiper.touchEventsData;
                const pointerIndex = data.evCache.findIndex(
                    (cachedEv) => cachedEv.pointerId === event.pointerId
                );
                if (pointerIndex >= 0) {
                    data.evCache.splice(pointerIndex, 1);
                }
                if (
                    ["pointercancel", "pointerout", "pointerleave"].includes(event.type)
                ) {
                    const proceed =
                        event.type === "pointercancel" &&
                        (swiper.browser.isSafari || swiper.browser.isWebView);
                    if (!proceed) {
                        return;
                    }
                }
                const {
                    params,
                    touches,
                    rtlTranslate: rtl,
                    slidesGrid,
                    enabled,
                } = swiper;
                if (!enabled) return;
                if (!params.simulateTouch && event.pointerType === "mouse") return;
                let e = event;
                if (e.originalEvent) e = e.originalEvent;
                if (data.allowTouchCallbacks) {
                    swiper.emit("touchEnd", e);
                }
                data.allowTouchCallbacks = false;
                if (!data.isTouched) {
                    if (data.isMoved && params.grabCursor) {
                        swiper.setGrabCursor(false);
                    }
                    data.isMoved = false;
                    data.startMoving = false;
                    return;
                }
                // Return Grab Cursor
                if (
                    params.grabCursor &&
                    data.isMoved &&
                    data.isTouched &&
                    (swiper.allowSlideNext === true || swiper.allowSlidePrev === true)
                ) {
                    swiper.setGrabCursor(false);
                }

                // Time diff
                const touchEndTime = now();
                const timeDiff = touchEndTime - data.touchStartTime;

                // Tap, doubleTap, Click
                if (swiper.allowClick) {
                    const pathTree = e.path || (e.composedPath && e.composedPath());
                    swiper.updateClickedSlide((pathTree && pathTree[0]) || e.target);
                    swiper.emit("tap click", e);
                    if (timeDiff < 300 && touchEndTime - data.lastClickTime < 300) {
                        swiper.emit("doubleTap doubleClick", e);
                    }
                }
                data.lastClickTime = now();
                nextTick(() => {
                    if (!swiper.destroyed) swiper.allowClick = true;
                });
                if (
                    !data.isTouched ||
                    !data.isMoved ||
                    !swiper.swipeDirection ||
                    touches.diff === 0 ||
                    data.currentTranslate === data.startTranslate
                ) {
                    data.isTouched = false;
                    data.isMoved = false;
                    data.startMoving = false;
                    return;
                }
                data.isTouched = false;
                data.isMoved = false;
                data.startMoving = false;
                let currentPos;
                if (params.followFinger) {
                    currentPos = rtl ? swiper.translate : -swiper.translate;
                } else {
                    currentPos = -data.currentTranslate;
                }
                if (params.cssMode) {
                    return;
                }
                if (params.freeMode && params.freeMode.enabled) {
                    swiper.freeMode.onTouchEnd({
                        currentPos,
                    });
                    return;
                }

                // Find current slide
                let stopIndex = 0;
                let groupSize = swiper.slidesSizesGrid[0];
                for (
                    let i = 0;
                    i < slidesGrid.length;
                    i += i < params.slidesPerGroupSkip ? 1 : params.slidesPerGroup
                ) {
                    const increment =
                        i < params.slidesPerGroupSkip - 1 ? 1 : params.slidesPerGroup;
                    if (typeof slidesGrid[i + increment] !== "undefined") {
                        if (
                            currentPos >= slidesGrid[i] &&
                            currentPos < slidesGrid[i + increment]
                        ) {
                            stopIndex = i;
                            groupSize = slidesGrid[i + increment] - slidesGrid[i];
                        }
                    } else if (currentPos >= slidesGrid[i]) {
                        stopIndex = i;
                        groupSize =
                            slidesGrid[slidesGrid.length - 1] -
                            slidesGrid[slidesGrid.length - 2];
                    }
                }
                let rewindFirstIndex = null;
                let rewindLastIndex = null;
                if (params.rewind) {
                    if (swiper.isBeginning) {
                        rewindLastIndex =
                            params.virtual && params.virtual.enabled && swiper.virtual
                                ? swiper.virtual.slides.length - 1
                                : swiper.slides.length - 1;
                    } else if (swiper.isEnd) {
                        rewindFirstIndex = 0;
                    }
                }
                // Find current slide size
                const ratio = (currentPos - slidesGrid[stopIndex]) / groupSize;
                const increment =
                    stopIndex < params.slidesPerGroupSkip - 1
                        ? 1
                        : params.slidesPerGroup;
                if (timeDiff > params.longSwipesMs) {
                    // Long touches
                    if (!params.longSwipes) {
                        swiper.slideTo(swiper.activeIndex);
                        return;
                    }
                    if (swiper.swipeDirection === "next") {
                        if (ratio >= params.longSwipesRatio)
                            swiper.slideTo(
                                params.rewind && swiper.isEnd
                                    ? rewindFirstIndex
                                    : stopIndex + increment
                            );
                        else swiper.slideTo(stopIndex);
                    }
                    if (swiper.swipeDirection === "prev") {
                        if (ratio > 1 - params.longSwipesRatio) {
                            swiper.slideTo(stopIndex + increment);
                        } else if (
                            rewindLastIndex !== null &&
                            ratio < 0 &&
                            Math.abs(ratio) > params.longSwipesRatio
                        ) {
                            swiper.slideTo(rewindLastIndex);
                        } else {
                            swiper.slideTo(stopIndex);
                        }
                    }
                } else {
                    // Short swipes
                    if (!params.shortSwipes) {
                        swiper.slideTo(swiper.activeIndex);
                        return;
                    }
                    const isNavButtonTarget =
                        swiper.navigation &&
                        (e.target === swiper.navigation.nextEl ||
                            e.target === swiper.navigation.prevEl);
                    if (!isNavButtonTarget) {
                        if (swiper.swipeDirection === "next") {
                            swiper.slideTo(
                                rewindFirstIndex !== null
                                    ? rewindFirstIndex
                                    : stopIndex + increment
                            );
                        }
                        if (swiper.swipeDirection === "prev") {
                            swiper.slideTo(
                                rewindLastIndex !== null ? rewindLastIndex : stopIndex
                            );
                        }
                    } else if (e.target === swiper.navigation.nextEl) {
                        swiper.slideTo(stopIndex + increment);
                    } else {
                        swiper.slideTo(stopIndex);
                    }
                }
            }

            function onResize() {
                const swiper = this;
                const { params, el } = swiper;
                if (el && el.offsetWidth === 0) return;

                // Breakpoints
                if (params.breakpoints) {
                    swiper.setBreakpoint();
                }

                // Save locks
                const { allowSlideNext, allowSlidePrev, snapGrid } = swiper;
                const isVirtual = swiper.virtual && swiper.params.virtual.enabled;

                // Disable locks on resize
                swiper.allowSlideNext = true;
                swiper.allowSlidePrev = true;
                swiper.updateSize();
                swiper.updateSlides();
                swiper.updateSlidesClasses();
                const isVirtualLoop = isVirtual && params.loop;
                if (
                    (params.slidesPerView === "auto" || params.slidesPerView > 1) &&
                    swiper.isEnd &&
                    !swiper.isBeginning &&
                    !swiper.params.centeredSlides &&
                    !isVirtualLoop
                ) {
                    swiper.slideTo(swiper.slides.length - 1, 0, false, true);
                } else {
                    if (swiper.params.loop && !isVirtual) {
                        swiper.slideToLoop(swiper.realIndex, 0, false, true);
                    } else {
                        swiper.slideTo(swiper.activeIndex, 0, false, true);
                    }
                }
                if (
                    swiper.autoplay &&
                    swiper.autoplay.running &&
                    swiper.autoplay.paused
                ) {
                    clearTimeout(swiper.autoplay.resizeTimeout);
                    swiper.autoplay.resizeTimeout = setTimeout(() => {
                        if (
                            swiper.autoplay &&
                            swiper.autoplay.running &&
                            swiper.autoplay.paused
                        ) {
                            swiper.autoplay.resume();
                        }
                    }, 500);
                }
                // Return locks after resize
                swiper.allowSlidePrev = allowSlidePrev;
                swiper.allowSlideNext = allowSlideNext;
                if (swiper.params.watchOverflow && snapGrid !== swiper.snapGrid) {
                    swiper.checkOverflow();
                }
            }

            function onClick(e) {
                const swiper = this;
                if (!swiper.enabled) return;
                if (!swiper.allowClick) {
                    if (swiper.params.preventClicks) e.preventDefault();
                    if (swiper.params.preventClicksPropagation && swiper.animating) {
                        e.stopPropagation();
                        e.stopImmediatePropagation();
                    }
                }
            }

            function onScroll() {
                const swiper = this;
                const { wrapperEl, rtlTranslate, enabled } = swiper;
                if (!enabled) return;
                swiper.previousTranslate = swiper.translate;
                if (swiper.isHorizontal()) {
                    swiper.translate = -wrapperEl.scrollLeft;
                } else {
                    swiper.translate = -wrapperEl.scrollTop;
                }
                // eslint-disable-next-line
                if (swiper.translate === 0) swiper.translate = 0;
                swiper.updateActiveIndex();
                swiper.updateSlidesClasses();
                let newProgress;
                const translatesDiff = swiper.maxTranslate() - swiper.minTranslate();
                if (translatesDiff === 0) {
                    newProgress = 0;
                } else {
                    newProgress =
                        (swiper.translate - swiper.minTranslate()) / translatesDiff;
                }
                if (newProgress !== swiper.progress) {
                    swiper.updateProgress(
                        rtlTranslate ? -swiper.translate : swiper.translate
                    );
                }
                swiper.emit("setTranslate", swiper.translate, false);
            }

            function onLoad(e) {
                const swiper = this;
                processLazyPreloader(swiper, e.target);
                if (
                    swiper.params.cssMode ||
                    (swiper.params.slidesPerView !== "auto" &&
                        !swiper.params.autoHeight)
                ) {
                    return;
                }
                swiper.update();
            }

            let dummyEventAttached = false;
            function dummyEventListener() { }
            const events = (swiper, method) => {
                const document = getDocument();
                const { params, el, wrapperEl, device } = swiper;
                const capture = !!params.nested;
                const domMethod =
                    method === "on" ? "addEventListener" : "removeEventListener";
                const swiperMethod = method;

                // Touch Events
                el[domMethod]("pointerdown", swiper.onTouchStart, {
                    passive: false,
                });
                document[domMethod]("pointermove", swiper.onTouchMove, {
                    passive: false,
                    capture,
                });
                document[domMethod]("pointerup", swiper.onTouchEnd, {
                    passive: true,
                });
                document[domMethod]("pointercancel", swiper.onTouchEnd, {
                    passive: true,
                });
                document[domMethod]("pointerout", swiper.onTouchEnd, {
                    passive: true,
                });
                document[domMethod]("pointerleave", swiper.onTouchEnd, {
                    passive: true,
                });

                // Prevent Links Clicks
                if (params.preventClicks || params.preventClicksPropagation) {
                    el[domMethod]("click", swiper.onClick, true);
                }
                if (params.cssMode) {
                    wrapperEl[domMethod]("scroll", swiper.onScroll);
                }

                // Resize handler
                if (params.updateOnWindowResize) {
                    swiper[swiperMethod](
                        device.ios || device.android
                            ? "resize orientationchange observerUpdate"
                            : "resize observerUpdate",
                        onResize,
                        true
                    );
                } else {
                    swiper[swiperMethod]("observerUpdate", onResize, true);
                }

                // Images loader
                el[domMethod]("load", swiper.onLoad, {
                    capture: true,
                });
            };
            function attachEvents() {
                const swiper = this;
                const document = getDocument();
                const { params } = swiper;
                swiper.onTouchStart = onTouchStart.bind(swiper);
                swiper.onTouchMove = onTouchMove.bind(swiper);
                swiper.onTouchEnd = onTouchEnd.bind(swiper);
                if (params.cssMode) {
                    swiper.onScroll = onScroll.bind(swiper);
                }
                swiper.onClick = onClick.bind(swiper);
                swiper.onLoad = onLoad.bind(swiper);
                if (!dummyEventAttached) {
                    document.addEventListener("touchstart", dummyEventListener);
                    dummyEventAttached = true;
                }
                events(swiper, "on");
            }
            function detachEvents() {
                const swiper = this;
                events(swiper, "off");
            }
            var events$1 = {
                attachEvents,
                detachEvents,
            };

            const isGridEnabled = (swiper, params) => {
                return swiper.grid && params.grid && params.grid.rows > 1;
            };
            function setBreakpoint() {
                const swiper = this;
                const { realIndex, initialized, params, el } = swiper;
                const breakpoints = params.breakpoints;
                if (
                    !breakpoints ||
                    (breakpoints && Object.keys(breakpoints).length === 0)
                )
                    return;

                // Get breakpoint for window width and update parameters
                const breakpoint = swiper.getBreakpoint(
                    breakpoints,
                    swiper.params.breakpointsBase,
                    swiper.el
                );
                if (!breakpoint || swiper.currentBreakpoint === breakpoint) return;
                const breakpointOnlyParams =
                    breakpoint in breakpoints ? breakpoints[breakpoint] : undefined;
                const breakpointParams =
                    breakpointOnlyParams || swiper.originalParams;
                const wasMultiRow = isGridEnabled(swiper, params);
                const isMultiRow = isGridEnabled(swiper, breakpointParams);
                const wasEnabled = params.enabled;
                if (wasMultiRow && !isMultiRow) {
                    el.classList.remove(
                        `${params.containerModifierClass}grid`,
                        `${params.containerModifierClass}grid-column`
                    );
                    swiper.emitContainerClasses();
                } else if (!wasMultiRow && isMultiRow) {
                    el.classList.add(`${params.containerModifierClass}grid`);
                    if (
                        (breakpointParams.grid.fill &&
                            breakpointParams.grid.fill === "column") ||
                        (!breakpointParams.grid.fill && params.grid.fill === "column")
                    ) {
                        el.classList.add(`${params.containerModifierClass}grid-column`);
                    }
                    swiper.emitContainerClasses();
                }

                // Toggle navigation, pagination, scrollbar
                ["navigation", "pagination", "scrollbar"].forEach((prop) => {
                    if (typeof breakpointParams[prop] === "undefined") return;
                    const wasModuleEnabled = params[prop] && params[prop].enabled;
                    const isModuleEnabled =
                        breakpointParams[prop] && breakpointParams[prop].enabled;
                    if (wasModuleEnabled && !isModuleEnabled) {
                        swiper[prop].disable();
                    }
                    if (!wasModuleEnabled && isModuleEnabled) {
                        swiper[prop].enable();
                    }
                });
                const directionChanged =
                    breakpointParams.direction &&
                    breakpointParams.direction !== params.direction;
                const needsReLoop =
                    params.loop &&
                    (breakpointParams.slidesPerView !== params.slidesPerView ||
                        directionChanged);
                if (directionChanged && initialized) {
                    swiper.changeDirection();
                }
                extend(swiper.params, breakpointParams);
                const isEnabled = swiper.params.enabled;
                Object.assign(swiper, {
                    allowTouchMove: swiper.params.allowTouchMove,
                    allowSlideNext: swiper.params.allowSlideNext,
                    allowSlidePrev: swiper.params.allowSlidePrev,
                });
                if (wasEnabled && !isEnabled) {
                    swiper.disable();
                } else if (!wasEnabled && isEnabled) {
                    swiper.enable();
                }
                swiper.currentBreakpoint = breakpoint;
                swiper.emit("_beforeBreakpoint", breakpointParams);
                if (needsReLoop && initialized) {
                    swiper.loopDestroy();
                    swiper.loopCreate(realIndex);
                    swiper.updateSlides();
                }
                swiper.emit("breakpoint", breakpointParams);
            }

            function getBreakpoint(breakpoints, base, containerEl) {
                if (base === void 0) {
                    base = "window";
                }
                if (!breakpoints || (base === "container" && !containerEl))
                    return undefined;
                let breakpoint = false;
                const window = getWindow();
                const currentHeight =
                    base === "window" ? window.innerHeight : containerEl.clientHeight;
                const points = Object.keys(breakpoints).map((point) => {
                    if (typeof point === "string" && point.indexOf("@") === 0) {
                        const minRatio = parseFloat(point.substr(1));
                        const value = currentHeight * minRatio;
                        return {
                            value,
                            point,
                        };
                    }
                    return {
                        value: point,
                        point,
                    };
                });
                points.sort((a, b) => parseInt(a.value, 10) - parseInt(b.value, 10));
                for (let i = 0; i < points.length; i += 1) {
                    const { point, value } = points[i];
                    if (base === "window") {
                        if (window.matchMedia(`(min-width: ${value}px)`).matches) {
                            breakpoint = point;
                        }
                    } else if (value <= containerEl.clientWidth) {
                        breakpoint = point;
                    }
                }
                return breakpoint || "max";
            }

            var breakpoints = {
                setBreakpoint,
                getBreakpoint,
            };

            function prepareClasses(entries, prefix) {
                const resultClasses = [];
                entries.forEach((item) => {
                    if (typeof item === "object") {
                        Object.keys(item).forEach((classNames) => {
                            if (item[classNames]) {
                                resultClasses.push(prefix + classNames);
                            }
                        });
                    } else if (typeof item === "string") {
                        resultClasses.push(prefix + item);
                    }
                });
                return resultClasses;
            }
            function addClasses() {
                const swiper = this;
                const { classNames, params, rtl, el, device } = swiper;
                // prettier-ignore
                const suffixes = prepareClasses(['initialized', params.direction, {
                    'free-mode': swiper.params.freeMode && params.freeMode.enabled
                }, {
                        'autoheight': params.autoHeight
                    }, {
                        'rtl': rtl
                    }, {
                        'grid': params.grid && params.grid.rows > 1
                    }, {
                        'grid-column': params.grid && params.grid.rows > 1 && params.grid.fill === 'column'
                    }, {
                        'android': device.android
                    }, {
                        'ios': device.ios
                    }, {
                        'css-mode': params.cssMode
                    }, {
                        'centered': params.cssMode && params.centeredSlides
                    }, {
                        'watch-progress': params.watchSlidesProgress
                    }], params.containerModifierClass);
                classNames.push(...suffixes);
                el.classList.add(...classNames);
                swiper.emitContainerClasses();
            }

            function removeClasses() {
                const swiper = this;
                const { el, classNames } = swiper;
                el.classList.remove(...classNames);
                swiper.emitContainerClasses();
            }

            var classes = {
                addClasses,
                removeClasses,
            };

            function checkOverflow() {
                const swiper = this;
                const { isLocked: wasLocked, params } = swiper;
                const { slidesOffsetBefore } = params;
                if (slidesOffsetBefore) {
                    const lastSlideIndex = swiper.slides.length - 1;
                    const lastSlideRightEdge =
                        swiper.slidesGrid[lastSlideIndex] +
                        swiper.slidesSizesGrid[lastSlideIndex] +
                        slidesOffsetBefore * 2;
                    swiper.isLocked = swiper.size > lastSlideRightEdge;
                } else {
                    swiper.isLocked = swiper.snapGrid.length === 1;
                }
                if (params.allowSlideNext === true) {
                    swiper.allowSlideNext = !swiper.isLocked;
                }
                if (params.allowSlidePrev === true) {
                    swiper.allowSlidePrev = !swiper.isLocked;
                }
                if (wasLocked && wasLocked !== swiper.isLocked) {
                    swiper.isEnd = false;
                }
                if (wasLocked !== swiper.isLocked) {
                    swiper.emit(swiper.isLocked ? "lock" : "unlock");
                }
            }
            var checkOverflow$1 = {
                checkOverflow,
            };

            var defaults = {
                init: true,
                direction: "horizontal",
                oneWayMovement: false,
                touchEventsTarget: "wrapper",
                initialSlide: 0,
                speed: 300,
                cssMode: false,
                updateOnWindowResize: true,
                resizeObserver: true,
                nested: false,
                createElements: false,
                enabled: true,
                focusableElements:
                    "input, select, option, textarea, button, video, label",
                // Overrides
                width: null,
                height: null,
                //
                preventInteractionOnTransition: false,
                // ssr
                userAgent: null,
                url: null,
                // To support iOS's swipe-to-go-back gesture (when being used in-app).
                edgeSwipeDetection: false,
                edgeSwipeThreshold: 20,
                // Autoheight
                autoHeight: false,
                // Set wrapper width
                setWrapperSize: false,
                // Virtual Translate
                virtualTranslate: false,
                // Effects
                effect: "slide",
                // 'slide' or 'fade' or 'cube' or 'coverflow' or 'flip'

                // Breakpoints
                breakpoints: undefined,
                breakpointsBase: "window",
                // Slides grid
                spaceBetween: 0,
                slidesPerView: 1,
                slidesPerGroup: 1,
                slidesPerGroupSkip: 0,
                slidesPerGroupAuto: false,
                centeredSlides: false,
                centeredSlidesBounds: false,
                slidesOffsetBefore: 0,
                // in px
                slidesOffsetAfter: 0,
                // in px
                normalizeSlideIndex: true,
                centerInsufficientSlides: false,
                // Disable swiper and hide navigation when container not overflow
                watchOverflow: true,
                // Round length
                roundLengths: false,
                // Touches
                touchRatio: 1,
                touchAngle: 45,
                simulateTouch: true,
                shortSwipes: true,
                longSwipes: true,
                longSwipesRatio: 0.5,
                longSwipesMs: 300,
                followFinger: true,
                allowTouchMove: true,
                threshold: 5,
                touchMoveStopPropagation: false,
                touchStartPreventDefault: true,
                touchStartForcePreventDefault: false,
                touchReleaseOnEdges: false,
                // Unique Navigation Elements
                uniqueNavElements: true,
                // Resistance
                resistance: true,
                resistanceRatio: 0.85,
                // Progress
                watchSlidesProgress: false,
                // Cursor
                grabCursor: false,
                // Clicks
                preventClicks: true,
                preventClicksPropagation: true,
                slideToClickedSlide: false,
                // loop
                loop: false,
                loopedSlides: null,
                loopPreventsSliding: true,
                // rewind
                rewind: false,
                // Swiping/no swiping
                allowSlidePrev: true,
                allowSlideNext: true,
                swipeHandler: null,
                // '.swipe-handler',
                noSwiping: true,
                noSwipingClass: "swiper-no-swiping",
                noSwipingSelector: null,
                // Passive Listeners
                passiveListeners: true,
                maxBackfaceHiddenSlides: 10,
                // NS
                containerModifierClass: "swiper-",
                // NEW
                slideClass: "swiper-slide",
                slideActiveClass: "swiper-slide-active",
                slideVisibleClass: "swiper-slide-visible",
                slideNextClass: "swiper-slide-next",
                slidePrevClass: "swiper-slide-prev",
                wrapperClass: "swiper-wrapper",
                lazyPreloaderClass: "swiper-lazy-preloader",
                lazyPreloadPrevNext: 0,
                // Callbacks
                runCallbacksOnInit: true,
                // Internals
                _emitClasses: false,
            };

            function moduleExtendParams(params, allModulesParams) {
                return function extendParams(obj) {
                    if (obj === void 0) {
                        obj = {};
                    }
                    const moduleParamName = Object.keys(obj)[0];
                    const moduleParams = obj[moduleParamName];
                    if (typeof moduleParams !== "object" || moduleParams === null) {
                        extend(allModulesParams, obj);
                        return;
                    }
                    if (
                        ["navigation", "pagination", "scrollbar"].indexOf(
                            moduleParamName
                        ) >= 0 &&
                        params[moduleParamName] === true
                    ) {
                        params[moduleParamName] = {
                            auto: true,
                        };
                    }
                    if (!(moduleParamName in params && "enabled" in moduleParams)) {
                        extend(allModulesParams, obj);
                        return;
                    }
                    if (params[moduleParamName] === true) {
                        params[moduleParamName] = {
                            enabled: true,
                        };
                    }
                    if (
                        typeof params[moduleParamName] === "object" &&
                        !("enabled" in params[moduleParamName])
                    ) {
                        params[moduleParamName].enabled = true;
                    }
                    if (!params[moduleParamName])
                        params[moduleParamName] = {
                            enabled: false,
                        };
                    extend(allModulesParams, obj);
                };
            }

            /* eslint no-param-reassign: "off" */
            const prototypes = {
                eventsEmitter,
                update,
                translate,
                transition,
                slide,
                loop,
                grabCursor,
                events: events$1,
                breakpoints,
                checkOverflow: checkOverflow$1,
                classes,
            };
            const extendedDefaults = {};
            class Swiper {
                constructor() {
                    let el;
                    let params;
                    for (
                        var _len = arguments.length, args = new Array(_len), _key = 0;
                        _key < _len;
                        _key++
                    ) {
                        args[_key] = arguments[_key];
                    }
                    if (
                        args.length === 1 &&
                        args[0].constructor &&
                        Object.prototype.toString.call(args[0]).slice(8, -1) === "Object"
                    ) {
                        params = args[0];
                    } else {
                        [el, params] = args;
                    }
                    if (!params) params = {};
                    params = extend({}, params);
                    if (el && !params.el) params.el = el;
                    const document = getDocument();
                    if (
                        params.el &&
                        typeof params.el === "string" &&
                        document.querySelectorAll(params.el).length > 1
                    ) {
                        const swipers = [];
                        document.querySelectorAll(params.el).forEach((containerEl) => {
                            const newParams = extend({}, params, {
                                el: containerEl,
                            });
                            swipers.push(new Swiper(newParams));
                        });
                        // eslint-disable-next-line no-constructor-return
                        return swipers;
                    }

                    // Swiper Instance
                    const swiper = this;
                    swiper.__swiper__ = true;
                    swiper.support = getSupport();
                    swiper.device = getDevice({
                        userAgent: params.userAgent,
                    });
                    swiper.browser = getBrowser();
                    swiper.eventsListeners = {};
                    swiper.eventsAnyListeners = [];
                    swiper.modules = [...swiper.__modules__];
                    if (params.modules && Array.isArray(params.modules)) {
                        swiper.modules.push(...params.modules);
                    }
                    const allModulesParams = {};
                    swiper.modules.forEach((mod) => {
                        mod({
                            params,
                            swiper,
                            extendParams: moduleExtendParams(params, allModulesParams),
                            on: swiper.on.bind(swiper),
                            once: swiper.once.bind(swiper),
                            off: swiper.off.bind(swiper),
                            emit: swiper.emit.bind(swiper),
                        });
                    });

                    // Extend defaults with modules params
                    const swiperParams = extend({}, defaults, allModulesParams);

                    // Extend defaults with passed params
                    swiper.params = extend({}, swiperParams, extendedDefaults, params);
                    swiper.originalParams = extend({}, swiper.params);
                    swiper.passedParams = extend({}, params);

                    // add event listeners
                    if (swiper.params && swiper.params.on) {
                        Object.keys(swiper.params.on).forEach((eventName) => {
                            swiper.on(eventName, swiper.params.on[eventName]);
                        });
                    }
                    if (swiper.params && swiper.params.onAny) {
                        swiper.onAny(swiper.params.onAny);
                    }

                    // Extend Swiper
                    Object.assign(swiper, {
                        enabled: swiper.params.enabled,
                        el,
                        // Classes
                        classNames: [],
                        // Slides
                        slides: [],
                        slidesGrid: [],
                        snapGrid: [],
                        slidesSizesGrid: [],
                        // isDirection
                        isHorizontal() {
                            return swiper.params.direction === "horizontal";
                        },
                        isVertical() {
                            return swiper.params.direction === "vertical";
                        },
                        // Indexes
                        activeIndex: 0,
                        realIndex: 0,
                        //
                        isBeginning: true,
                        isEnd: false,
                        // Props
                        translate: 0,
                        previousTranslate: 0,
                        progress: 0,
                        velocity: 0,
                        animating: false,
                        cssOverflowAdjustment() {
                            // Returns 0 unless `translate` is > 2**23
                            // Should be subtracted from css values to prevent overflow
                            return Math.trunc(this.translate / 2 ** 23) * 2 ** 23;
                        },
                        // Locks
                        allowSlideNext: swiper.params.allowSlideNext,
                        allowSlidePrev: swiper.params.allowSlidePrev,
                        // Touch Events
                        touchEventsData: {
                            isTouched: undefined,
                            isMoved: undefined,
                            allowTouchCallbacks: undefined,
                            touchStartTime: undefined,
                            isScrolling: undefined,
                            currentTranslate: undefined,
                            startTranslate: undefined,
                            allowThresholdMove: undefined,
                            // Form elements to match
                            focusableElements: swiper.params.focusableElements,
                            // Last click time
                            lastClickTime: 0,
                            clickTimeout: undefined,
                            // Velocities
                            velocities: [],
                            allowMomentumBounce: undefined,
                            startMoving: undefined,
                            evCache: [],
                        },
                        // Clicks
                        allowClick: true,
                        // Touches
                        allowTouchMove: swiper.params.allowTouchMove,
                        touches: {
                            startX: 0,
                            startY: 0,
                            currentX: 0,
                            currentY: 0,
                            diff: 0,
                        },
                        // Images
                        imagesToLoad: [],
                        imagesLoaded: 0,
                    });
                    swiper.emit("_swiper");

                    // Init
                    if (swiper.params.init) {
                        swiper.init();
                    }

                    // Return app instance
                    // eslint-disable-next-line no-constructor-return
                    return swiper;
                }
                getSlideIndex(slideEl) {
                    const { slidesEl, params } = this;
                    const slides = elementChildren(
                        slidesEl,
                        `.${params.slideClass}, swiper-slide`
                    );
                    const firstSlideIndex = elementIndex(slides[0]);
                    return elementIndex(slideEl) - firstSlideIndex;
                }
                getSlideIndexByData(index) {
                    return this.getSlideIndex(
                        this.slides.filter(
                            (slideEl) =>
                                slideEl.getAttribute("data-swiper-slide-index") * 1 === index
                        )[0]
                    );
                }
                recalcSlides() {
                    const swiper = this;
                    const { slidesEl, params } = swiper;
                    swiper.slides = elementChildren(
                        slidesEl,
                        `.${params.slideClass}, swiper-slide`
                    );
                }
                enable() {
                    const swiper = this;
                    if (swiper.enabled) return;
                    swiper.enabled = true;
                    if (swiper.params.grabCursor) {
                        swiper.setGrabCursor();
                    }
                    swiper.emit("enable");
                }
                disable() {
                    const swiper = this;
                    if (!swiper.enabled) return;
                    swiper.enabled = false;
                    if (swiper.params.grabCursor) {
                        swiper.unsetGrabCursor();
                    }
                    swiper.emit("disable");
                }
                setProgress(progress, speed) {
                    const swiper = this;
                    progress = Math.min(Math.max(progress, 0), 1);
                    const min = swiper.minTranslate();
                    const max = swiper.maxTranslate();
                    const current = (max - min) * progress + min;
                    swiper.translateTo(
                        current,
                        typeof speed === "undefined" ? 0 : speed
                    );
                    swiper.updateActiveIndex();
                    swiper.updateSlidesClasses();
                }
                emitContainerClasses() {
                    const swiper = this;
                    if (!swiper.params._emitClasses || !swiper.el) return;
                    const cls = swiper.el.className.split(" ").filter((className) => {
                        return (
                            className.indexOf("swiper") === 0 ||
                            className.indexOf(swiper.params.containerModifierClass) === 0
                        );
                    });
                    swiper.emit("_containerClasses", cls.join(" "));
                }
                getSlideClasses(slideEl) {
                    const swiper = this;
                    if (swiper.destroyed) return "";
                    return slideEl.className
                        .split(" ")
                        .filter((className) => {
                            return (
                                className.indexOf("swiper-slide") === 0 ||
                                className.indexOf(swiper.params.slideClass) === 0
                            );
                        })
                        .join(" ");
                }
                emitSlidesClasses() {
                    const swiper = this;
                    if (!swiper.params._emitClasses || !swiper.el) return;
                    const updates = [];
                    swiper.slides.forEach((slideEl) => {
                        const classNames = swiper.getSlideClasses(slideEl);
                        updates.push({
                            slideEl,
                            classNames,
                        });
                        swiper.emit("_slideClass", slideEl, classNames);
                    });
                    swiper.emit("_slideClasses", updates);
                }
                slidesPerViewDynamic(view, exact) {
                    if (view === void 0) {
                        view = "current";
                    }
                    if (exact === void 0) {
                        exact = false;
                    }
                    const swiper = this;
                    const {
                        params,
                        slides,
                        slidesGrid,
                        slidesSizesGrid,
                        size: swiperSize,
                        activeIndex,
                    } = swiper;
                    let spv = 1;
                    if (params.centeredSlides) {
                        let slideSize = slides[activeIndex]
                            ? slides[activeIndex].swiperSlideSize
                            : 0;
                        let breakLoop;
                        for (let i = activeIndex + 1; i < slides.length; i += 1) {
                            if (slides[i] && !breakLoop) {
                                slideSize += slides[i].swiperSlideSize;
                                spv += 1;
                                if (slideSize > swiperSize) breakLoop = true;
                            }
                        }
                        for (let i = activeIndex - 1; i >= 0; i -= 1) {
                            if (slides[i] && !breakLoop) {
                                slideSize += slides[i].swiperSlideSize;
                                spv += 1;
                                if (slideSize > swiperSize) breakLoop = true;
                            }
                        }
                    } else {
                        // eslint-disable-next-line
                        if (view === "current") {
                            for (let i = activeIndex + 1; i < slides.length; i += 1) {
                                const slideInView = exact
                                    ? slidesGrid[i] +
                                    slidesSizesGrid[i] -
                                    slidesGrid[activeIndex] <
                                    swiperSize
                                    : slidesGrid[i] - slidesGrid[activeIndex] < swiperSize;
                                if (slideInView) {
                                    spv += 1;
                                }
                            }
                        } else {
                            // previous
                            for (let i = activeIndex - 1; i >= 0; i -= 1) {
                                const slideInView =
                                    slidesGrid[activeIndex] - slidesGrid[i] < swiperSize;
                                if (slideInView) {
                                    spv += 1;
                                }
                            }
                        }
                    }
                    return spv;
                }
                update() {
                    const swiper = this;
                    if (!swiper || swiper.destroyed) return;
                    const { snapGrid, params } = swiper;
                    // Breakpoints
                    if (params.breakpoints) {
                        swiper.setBreakpoint();
                    }
                    [...swiper.el.querySelectorAll('[loading="lazy"]')].forEach(
                        (imageEl) => {
                            if (imageEl.complete) {
                                processLazyPreloader(swiper, imageEl);
                            }
                        }
                    );
                    swiper.updateSize();
                    swiper.updateSlides();
                    swiper.updateProgress();
                    swiper.updateSlidesClasses();
                    function setTranslate() {
                        const translateValue = swiper.rtlTranslate
                            ? swiper.translate * -1
                            : swiper.translate;
                        const newTranslate = Math.min(
                            Math.max(translateValue, swiper.maxTranslate()),
                            swiper.minTranslate()
                        );
                        swiper.setTranslate(newTranslate);
                        swiper.updateActiveIndex();
                        swiper.updateSlidesClasses();
                    }
                    let translated;
                    if (params.freeMode && params.freeMode.enabled && !params.cssMode) {
                        setTranslate();
                        if (params.autoHeight) {
                            swiper.updateAutoHeight();
                        }
                    } else {
                        if (
                            (params.slidesPerView === "auto" || params.slidesPerView > 1) &&
                            swiper.isEnd &&
                            !params.centeredSlides
                        ) {
                            const slides =
                                swiper.virtual && params.virtual.enabled
                                    ? swiper.virtual.slides
                                    : swiper.slides;
                            translated = swiper.slideTo(slides.length - 1, 0, false, true);
                        } else {
                            translated = swiper.slideTo(swiper.activeIndex, 0, false, true);
                        }
                        if (!translated) {
                            setTranslate();
                        }
                    }
                    if (params.watchOverflow && snapGrid !== swiper.snapGrid) {
                        swiper.checkOverflow();
                    }
                    swiper.emit("update");
                }
                changeDirection(newDirection, needUpdate) {
                    if (needUpdate === void 0) {
                        needUpdate = true;
                    }
                    const swiper = this;
                    const currentDirection = swiper.params.direction;
                    if (!newDirection) {
                        // eslint-disable-next-line
                        newDirection =
                            currentDirection === "horizontal" ? "vertical" : "horizontal";
                    }
                    if (
                        newDirection === currentDirection ||
                        (newDirection !== "horizontal" && newDirection !== "vertical")
                    ) {
                        return swiper;
                    }
                    swiper.el.classList.remove(
                        `${swiper.params.containerModifierClass}${currentDirection}`
                    );
                    swiper.el.classList.add(
                        `${swiper.params.containerModifierClass}${newDirection}`
                    );
                    swiper.emitContainerClasses();
                    swiper.params.direction = newDirection;
                    swiper.slides.forEach((slideEl) => {
                        if (newDirection === "vertical") {
                            slideEl.style.width = "";
                        } else {
                            slideEl.style.height = "";
                        }
                    });
                    swiper.emit("changeDirection");
                    if (needUpdate) swiper.update();
                    return swiper;
                }
                changeLanguageDirection(direction) {
                    const swiper = this;
                    if (
                        (swiper.rtl && direction === "rtl") ||
                        (!swiper.rtl && direction === "ltr")
                    )
                        return;
                    swiper.rtl = direction === "rtl";
                    swiper.rtlTranslate =
                        swiper.params.direction === "horizontal" && swiper.rtl;
                    if (swiper.rtl) {
                        swiper.el.classList.add(
                            `${swiper.params.containerModifierClass}rtl`
                        );
                        swiper.el.dir = "rtl";
                    } else {
                        swiper.el.classList.remove(
                            `${swiper.params.containerModifierClass}rtl`
                        );
                        swiper.el.dir = "ltr";
                    }
                    swiper.update();
                }
                mount(element) {
                    const swiper = this;
                    if (swiper.mounted) return true;

                    // Find el
                    let el = element || swiper.params.el;
                    if (typeof el === "string") {
                        el = document.querySelector(el);
                    }
                    if (!el) {
                        return false;
                    }
                    el.swiper = swiper;
                    if (el.parentNode && el.parentNode.host) {
                        swiper.isElement = true;
                    }
                    const getWrapperSelector = () => {
                        return `.${(swiper.params.wrapperClass || "")
                            .trim()
                            .split(" ")
                            .join(".")}`;
                    };
                    const getWrapper = () => {
                        if (el && el.shadowRoot && el.shadowRoot.querySelector) {
                            const res = el.shadowRoot.querySelector(getWrapperSelector());
                            // Children needs to return slot items
                            return res;
                        }
                        return elementChildren(el, getWrapperSelector())[0];
                    };
                    // Find Wrapper
                    let wrapperEl = getWrapper();
                    if (!wrapperEl && swiper.params.createElements) {
                        wrapperEl = createElement("div", swiper.params.wrapperClass);
                        el.append(wrapperEl);
                        elementChildren(el, `.${swiper.params.slideClass}`).forEach(
                            (slideEl) => {
                                wrapperEl.append(slideEl);
                            }
                        );
                    }
                    Object.assign(swiper, {
                        el,
                        wrapperEl,
                        slidesEl: swiper.isElement ? el.parentNode.host : wrapperEl,
                        hostEl: swiper.isElement ? el.parentNode.host : el,
                        mounted: true,
                        // RTL
                        rtl:
                            el.dir.toLowerCase() === "rtl" ||
                            elementStyle(el, "direction") === "rtl",
                        rtlTranslate:
                            swiper.params.direction === "horizontal" &&
                            (el.dir.toLowerCase() === "rtl" ||
                                elementStyle(el, "direction") === "rtl"),
                        wrongRTL: elementStyle(wrapperEl, "display") === "-webkit-box",
                    });
                    return true;
                }
                init(el) {
                    const swiper = this;
                    if (swiper.initialized) return swiper;
                    const mounted = swiper.mount(el);
                    if (mounted === false) return swiper;
                    swiper.emit("beforeInit");

                    // Set breakpoint
                    if (swiper.params.breakpoints) {
                        swiper.setBreakpoint();
                    }

                    // Add Classes
                    swiper.addClasses();

                    // Update size
                    swiper.updateSize();

                    // Update slides
                    swiper.updateSlides();
                    if (swiper.params.watchOverflow) {
                        swiper.checkOverflow();
                    }

                    // Set Grab Cursor
                    if (swiper.params.grabCursor && swiper.enabled) {
                        swiper.setGrabCursor();
                    }

                    // Slide To Initial Slide
                    if (
                        swiper.params.loop &&
                        swiper.virtual &&
                        swiper.params.virtual.enabled
                    ) {
                        swiper.slideTo(
                            swiper.params.initialSlide + swiper.virtual.slidesBefore,
                            0,
                            swiper.params.runCallbacksOnInit,
                            false,
                            true
                        );
                    } else {
                        swiper.slideTo(
                            swiper.params.initialSlide,
                            0,
                            swiper.params.runCallbacksOnInit,
                            false,
                            true
                        );
                    }

                    // Create loop
                    if (swiper.params.loop) {
                        swiper.loopCreate();
                    }

                    // Attach events
                    swiper.attachEvents();
                    [...swiper.el.querySelectorAll('[loading="lazy"]')].forEach(
                        (imageEl) => {
                            if (imageEl.complete) {
                                processLazyPreloader(swiper, imageEl);
                            } else {
                                imageEl.addEventListener("load", (e) => {
                                    processLazyPreloader(swiper, e.target);
                                });
                            }
                        }
                    );
                    preload(swiper);

                    // Init Flag
                    swiper.initialized = true;
                    preload(swiper);

                    // Emit
                    swiper.emit("init");
                    swiper.emit("afterInit");
                    return swiper;
                }
                destroy(deleteInstance, cleanStyles) {
                    if (deleteInstance === void 0) {
                        deleteInstance = true;
                    }
                    if (cleanStyles === void 0) {
                        cleanStyles = true;
                    }
                    const swiper = this;
                    const { params, el, wrapperEl, slides } = swiper;
                    if (typeof swiper.params === "undefined" || swiper.destroyed) {
                        return null;
                    }
                    swiper.emit("beforeDestroy");

                    // Init Flag
                    swiper.initialized = false;

                    // Detach events
                    swiper.detachEvents();

                    // Destroy loop
                    if (params.loop) {
                        swiper.loopDestroy();
                    }

                    // Cleanup styles
                    if (cleanStyles) {
                        swiper.removeClasses();
                        el.removeAttribute("style");
                        wrapperEl.removeAttribute("style");
                        if (slides && slides.length) {
                            slides.forEach((slideEl) => {
                                slideEl.classList.remove(
                                    params.slideVisibleClass,
                                    params.slideActiveClass,
                                    params.slideNextClass,
                                    params.slidePrevClass
                                );
                                slideEl.removeAttribute("style");
                                slideEl.removeAttribute("data-swiper-slide-index");
                            });
                        }
                    }
                    swiper.emit("destroy");

                    // Detach emitter events
                    Object.keys(swiper.eventsListeners).forEach((eventName) => {
                        swiper.off(eventName);
                    });
                    if (deleteInstance !== false) {
                        swiper.el.swiper = null;
                        deleteProps(swiper);
                    }
                    swiper.destroyed = true;
                    return null;
                }
                static extendDefaults(newDefaults) {
                    extend(extendedDefaults, newDefaults);
                }
                static get extendedDefaults() {
                    return extendedDefaults;
                }
                static get defaults() {
                    return defaults;
                }
                static installModule(mod) {
                    if (!Swiper.prototype.__modules__)
                        Swiper.prototype.__modules__ = [];
                    const modules = Swiper.prototype.__modules__;
                    if (typeof mod === "function" && modules.indexOf(mod) < 0) {
                        modules.push(mod);
                    }
                }
                static use(module) {
                    if (Array.isArray(module)) {
                        module.forEach((m) => Swiper.installModule(m));
                        return Swiper;
                    }
                    Swiper.installModule(module);
                    return Swiper;
                }
            }
            Object.keys(prototypes).forEach((prototypeGroup) => {
                Object.keys(prototypes[prototypeGroup]).forEach((protoMethod) => {
                    Swiper.prototype[protoMethod] =
                        prototypes[prototypeGroup][protoMethod];
                });
            });
            Swiper.use([Resize, Observer]);

            function Virtual(_ref) {
                let { swiper, extendParams, on, emit } = _ref;
                extendParams({
                    virtual: {
                        enabled: false,
                        slides: [],
                        cache: true,
                        renderSlide: null,
                        renderExternal: null,
                        renderExternalUpdate: true,
                        addSlidesBefore: 0,
                        addSlidesAfter: 0,
                    },
                });
                let cssModeTimeout;
                const document = getDocument();
                swiper.virtual = {
                    cache: {},
                    from: undefined,
                    to: undefined,
                    slides: [],
                    offset: 0,
                    slidesGrid: [],
                };
                const tempDOM = document.createElement("div");
                function renderSlide(slide, index) {
                    const params = swiper.params.virtual;
                    if (params.cache && swiper.virtual.cache[index]) {
                        return swiper.virtual.cache[index];
                    }
                    // eslint-disable-next-line
                    let slideEl;
                    if (params.renderSlide) {
                        slideEl = params.renderSlide.call(swiper, slide, index);
                        if (typeof slideEl === "string") {
                            tempDOM.innerHTML = slideEl;
                            slideEl = tempDOM.children[0];
                        }
                    } else if (swiper.isElement) {
                        slideEl = createElement("swiper-slide");
                    } else {
                        slideEl = createElement("div", swiper.params.slideClass);
                    }
                    slideEl.setAttribute("data-swiper-slide-index", index);
                    if (!params.renderSlide) {
                        slideEl.innerHTML = slide;
                    }
                    if (params.cache) swiper.virtual.cache[index] = slideEl;
                    return slideEl;
                }
                function update(force) {
                    const {
                        slidesPerView,
                        slidesPerGroup,
                        centeredSlides,
                        loop: isLoop,
                    } = swiper.params;
                    const { addSlidesBefore, addSlidesAfter } = swiper.params.virtual;
                    const {
                        from: previousFrom,
                        to: previousTo,
                        slides,
                        slidesGrid: previousSlidesGrid,
                        offset: previousOffset,
                    } = swiper.virtual;
                    if (!swiper.params.cssMode) {
                        swiper.updateActiveIndex();
                    }
                    const activeIndex = swiper.activeIndex || 0;
                    let offsetProp;
                    if (swiper.rtlTranslate) offsetProp = "right";
                    else offsetProp = swiper.isHorizontal() ? "left" : "top";
                    let slidesAfter;
                    let slidesBefore;
                    if (centeredSlides) {
                        slidesAfter =
                            Math.floor(slidesPerView / 2) + slidesPerGroup + addSlidesAfter;
                        slidesBefore =
                            Math.floor(slidesPerView / 2) +
                            slidesPerGroup +
                            addSlidesBefore;
                    } else {
                        slidesAfter =
                            slidesPerView + (slidesPerGroup - 1) + addSlidesAfter;
                        slidesBefore =
                            (isLoop ? slidesPerView : slidesPerGroup) + addSlidesBefore;
                    }
                    let from = activeIndex - slidesBefore;
                    let to = activeIndex + slidesAfter;
                    if (!isLoop) {
                        from = Math.max(from, 0);
                        to = Math.min(to, slides.length - 1);
                    }
                    let offset =
                        (swiper.slidesGrid[from] || 0) - (swiper.slidesGrid[0] || 0);
                    if (isLoop && activeIndex >= slidesBefore) {
                        from -= slidesBefore;
                        if (!centeredSlides) offset += swiper.slidesGrid[0];
                    } else if (isLoop && activeIndex < slidesBefore) {
                        from = -slidesBefore;
                        if (centeredSlides) offset += swiper.slidesGrid[0];
                    }
                    Object.assign(swiper.virtual, {
                        from,
                        to,
                        offset,
                        slidesGrid: swiper.slidesGrid,
                        slidesBefore,
                        slidesAfter,
                    });
                    function onRendered() {
                        swiper.updateSlides();
                        swiper.updateProgress();
                        swiper.updateSlidesClasses();
                        emit("virtualUpdate");
                    }
                    if (previousFrom === from && previousTo === to && !force) {
                        if (
                            swiper.slidesGrid !== previousSlidesGrid &&
                            offset !== previousOffset
                        ) {
                            swiper.slides.forEach((slideEl) => {
                                slideEl.style[offsetProp] = `${offset - Math.abs(swiper.cssOverflowAdjustment())
                                    }px`;
                            });
                        }
                        swiper.updateProgress();
                        emit("virtualUpdate");
                        return;
                    }
                    if (swiper.params.virtual.renderExternal) {
                        swiper.params.virtual.renderExternal.call(swiper, {
                            offset,
                            from,
                            to,
                            slides: (function getSlides() {
                                const slidesToRender = [];
                                for (let i = from; i <= to; i += 1) {
                                    slidesToRender.push(slides[i]);
                                }
                                return slidesToRender;
                            })(),
                        });
                        if (swiper.params.virtual.renderExternalUpdate) {
                            onRendered();
                        } else {
                            emit("virtualUpdate");
                        }
                        return;
                    }
                    const prependIndexes = [];
                    const appendIndexes = [];
                    const getSlideIndex = (index) => {
                        let slideIndex = index;
                        if (index < 0) {
                            slideIndex = slides.length + index;
                        } else if (slideIndex >= slides.length) {
                            // eslint-disable-next-line
                            slideIndex = slideIndex - slides.length;
                        }
                        return slideIndex;
                    };
                    if (force) {
                        swiper.slidesEl
                            .querySelectorAll(`.${swiper.params.slideClass}, swiper-slide`)
                            .forEach((slideEl) => {
                                slideEl.remove();
                            });
                    } else {
                        for (let i = previousFrom; i <= previousTo; i += 1) {
                            if (i < from || i > to) {
                                const slideIndex = getSlideIndex(i);
                                swiper.slidesEl
                                    .querySelectorAll(
                                        `.${swiper.params.slideClass}[data-swiper-slide-index="${slideIndex}"], swiper-slide[data-swiper-slide-index="${slideIndex}"]`
                                    )
                                    .forEach((slideEl) => {
                                        slideEl.remove();
                                    });
                            }
                        }
                    }
                    const loopFrom = isLoop ? -slides.length : 0;
                    const loopTo = isLoop ? slides.length * 2 : slides.length;
                    for (let i = loopFrom; i < loopTo; i += 1) {
                        if (i >= from && i <= to) {
                            const slideIndex = getSlideIndex(i);
                            if (typeof previousTo === "undefined" || force) {
                                appendIndexes.push(slideIndex);
                            } else {
                                if (i > previousTo) appendIndexes.push(slideIndex);
                                if (i < previousFrom) prependIndexes.push(slideIndex);
                            }
                        }
                    }
                    appendIndexes.forEach((index) => {
                        swiper.slidesEl.append(renderSlide(slides[index], index));
                    });
                    if (isLoop) {
                        for (let i = prependIndexes.length - 1; i >= 0; i -= 1) {
                            const index = prependIndexes[i];
                            swiper.slidesEl.prepend(renderSlide(slides[index], index));
                        }
                    } else {
                        prependIndexes.sort((a, b) => b - a);
                        prependIndexes.forEach((index) => {
                            swiper.slidesEl.prepend(renderSlide(slides[index], index));
                        });
                    }
                    elementChildren(
                        swiper.slidesEl,
                        ".swiper-slide, swiper-slide"
                    ).forEach((slideEl) => {
                        slideEl.style[offsetProp] = `${offset - Math.abs(swiper.cssOverflowAdjustment())
                            }px`;
                    });
                    onRendered();
                }
                function appendSlide(slides) {
                    if (typeof slides === "object" && "length" in slides) {
                        for (let i = 0; i < slides.length; i += 1) {
                            if (slides[i]) swiper.virtual.slides.push(slides[i]);
                        }
                    } else {
                        swiper.virtual.slides.push(slides);
                    }
                    update(true);
                }
                function prependSlide(slides) {
                    const activeIndex = swiper.activeIndex;
                    let newActiveIndex = activeIndex + 1;
                    let numberOfNewSlides = 1;
                    if (Array.isArray(slides)) {
                        for (let i = 0; i < slides.length; i += 1) {
                            if (slides[i]) swiper.virtual.slides.unshift(slides[i]);
                        }
                        newActiveIndex = activeIndex + slides.length;
                        numberOfNewSlides = slides.length;
                    } else {
                        swiper.virtual.slides.unshift(slides);
                    }
                    if (swiper.params.virtual.cache) {
                        const cache = swiper.virtual.cache;
                        const newCache = {};
                        Object.keys(cache).forEach((cachedIndex) => {
                            const cachedEl = cache[cachedIndex];
                            const cachedElIndex = cachedEl.getAttribute(
                                "data-swiper-slide-index"
                            );
                            if (cachedElIndex) {
                                cachedEl.setAttribute(
                                    "data-swiper-slide-index",
                                    parseInt(cachedElIndex, 10) + numberOfNewSlides
                                );
                            }
                            newCache[parseInt(cachedIndex, 10) + numberOfNewSlides] =
                                cachedEl;
                        });
                        swiper.virtual.cache = newCache;
                    }
                    update(true);
                    swiper.slideTo(newActiveIndex, 0);
                }
                function removeSlide(slidesIndexes) {
                    if (typeof slidesIndexes === "undefined" || slidesIndexes === null)
                        return;
                    let activeIndex = swiper.activeIndex;
                    if (Array.isArray(slidesIndexes)) {
                        for (let i = slidesIndexes.length - 1; i >= 0; i -= 1) {
                            swiper.virtual.slides.splice(slidesIndexes[i], 1);
                            if (swiper.params.virtual.cache) {
                                delete swiper.virtual.cache[slidesIndexes[i]];
                            }
                            if (slidesIndexes[i] < activeIndex) activeIndex -= 1;
                            activeIndex = Math.max(activeIndex, 0);
                        }
                    } else {
                        swiper.virtual.slides.splice(slidesIndexes, 1);
                        if (swiper.params.virtual.cache) {
                            delete swiper.virtual.cache[slidesIndexes];
                        }
                        if (slidesIndexes < activeIndex) activeIndex -= 1;
                        activeIndex = Math.max(activeIndex, 0);
                    }
                    update(true);
                    swiper.slideTo(activeIndex, 0);
                }
                function removeAllSlides() {
                    swiper.virtual.slides = [];
                    if (swiper.params.virtual.cache) {
                        swiper.virtual.cache = {};
                    }
                    update(true);
                    swiper.slideTo(0, 0);
                }
                on("beforeInit", () => {
                    if (!swiper.params.virtual.enabled) return;
                    let domSlidesAssigned;
                    if (typeof swiper.passedParams.virtual.slides === "undefined") {
                        const slides = [...swiper.slidesEl.children].filter((el) =>
                            el.matches(`.${swiper.params.slideClass}, swiper-slide`)
                        );
                        if (slides && slides.length) {
                            swiper.virtual.slides = [...slides];
                            domSlidesAssigned = true;
                            slides.forEach((slideEl, slideIndex) => {
                                slideEl.setAttribute("data-swiper-slide-index", slideIndex);
                                swiper.virtual.cache[slideIndex] = slideEl;
                                slideEl.remove();
                            });
                        }
                    }
                    if (!domSlidesAssigned) {
                        swiper.virtual.slides = swiper.params.virtual.slides;
                    }
                    swiper.classNames.push(
                        `${swiper.params.containerModifierClass}virtual`
                    );
                    swiper.params.watchSlidesProgress = true;
                    swiper.originalParams.watchSlidesProgress = true;
                    if (!swiper.params.initialSlide) {
                        update();
                    }
                });
                on("setTranslate", () => {
                    if (!swiper.params.virtual.enabled) return;
                    if (swiper.params.cssMode && !swiper._immediateVirtual) {
                        clearTimeout(cssModeTimeout);
                        cssModeTimeout = setTimeout(() => {
                            update();
                        }, 100);
                    } else {
                        update();
                    }
                });
                on("init update resize", () => {
                    if (!swiper.params.virtual.enabled) return;
                    if (swiper.params.cssMode) {
                        setCSSProperty(
                            swiper.wrapperEl,
                            "--swiper-virtual-size",
                            `${swiper.virtualSize}px`
                        );
                    }
                });
                Object.assign(swiper.virtual, {
                    appendSlide,
                    prependSlide,
                    removeSlide,
                    removeAllSlides,
                    update,
                });
            }

            /* eslint-disable consistent-return */
            function Keyboard(_ref) {
                let { swiper, extendParams, on, emit } = _ref;
                const document = getDocument();
                const window = getWindow();
                swiper.keyboard = {
                    enabled: false,
                };
                extendParams({
                    keyboard: {
                        enabled: false,
                        onlyInViewport: true,
                        pageUpDown: true,
                    },
                });
                function handle(event) {
                    if (!swiper.enabled) return;
                    const { rtlTranslate: rtl } = swiper;
                    let e = event;
                    if (e.originalEvent) e = e.originalEvent; // jquery fix
                    const kc = e.keyCode || e.charCode;
                    const pageUpDown = swiper.params.keyboard.pageUpDown;
                    const isPageUp = pageUpDown && kc === 33;
                    const isPageDown = pageUpDown && kc === 34;
                    const isArrowLeft = kc === 37;
                    const isArrowRight = kc === 39;
                    const isArrowUp = kc === 38;
                    const isArrowDown = kc === 40;
                    // Directions locks
                    if (
                        !swiper.allowSlideNext &&
                        ((swiper.isHorizontal() && isArrowRight) ||
                            (swiper.isVertical() && isArrowDown) ||
                            isPageDown)
                    ) {
                        return false;
                    }
                    if (
                        !swiper.allowSlidePrev &&
                        ((swiper.isHorizontal() && isArrowLeft) ||
                            (swiper.isVertical() && isArrowUp) ||
                            isPageUp)
                    ) {
                        return false;
                    }
                    if (e.shiftKey || e.altKey || e.ctrlKey || e.metaKey) {
                        return undefined;
                    }
                    if (
                        document.activeElement &&
                        document.activeElement.nodeName &&
                        (document.activeElement.nodeName.toLowerCase() === "input" ||
                            document.activeElement.nodeName.toLowerCase() === "textarea")
                    ) {
                        return undefined;
                    }
                    if (
                        swiper.params.keyboard.onlyInViewport &&
                        (isPageUp ||
                            isPageDown ||
                            isArrowLeft ||
                            isArrowRight ||
                            isArrowUp ||
                            isArrowDown)
                    ) {
                        let inView = false;
                        // Check that swiper should be inside of visible area of window
                        if (
                            elementParents(
                                swiper.el,
                                `.${swiper.params.slideClass}, swiper-slide`
                            ).length > 0 &&
                            elementParents(swiper.el, `.${swiper.params.slideActiveClass}`)
                                .length === 0
                        ) {
                            return undefined;
                        }
                        const el = swiper.el;
                        const swiperWidth = el.clientWidth;
                        const swiperHeight = el.clientHeight;
                        const windowWidth = window.innerWidth;
                        const windowHeight = window.innerHeight;
                        const swiperOffset = elementOffset(el);
                        if (rtl) swiperOffset.left -= el.scrollLeft;
                        const swiperCoord = [
                            [swiperOffset.left, swiperOffset.top],
                            [swiperOffset.left + swiperWidth, swiperOffset.top],
                            [swiperOffset.left, swiperOffset.top + swiperHeight],
                            [
                                swiperOffset.left + swiperWidth,
                                swiperOffset.top + swiperHeight,
                            ],
                        ];
                        for (let i = 0; i < swiperCoord.length; i += 1) {
                            const point = swiperCoord[i];
                            if (
                                point[0] >= 0 &&
                                point[0] <= windowWidth &&
                                point[1] >= 0 &&
                                point[1] <= windowHeight
                            ) {
                                if (point[0] === 0 && point[1] === 0) continue; // eslint-disable-line
                                inView = true;
                            }
                        }
                        if (!inView) return undefined;
                    }
                    if (swiper.isHorizontal()) {
                        if (isPageUp || isPageDown || isArrowLeft || isArrowRight) {
                            if (e.preventDefault) e.preventDefault();
                            else e.returnValue = false;
                        }
                        if (
                            ((isPageDown || isArrowRight) && !rtl) ||
                            ((isPageUp || isArrowLeft) && rtl)
                        )
                            swiper.slideNext();
                        if (
                            ((isPageUp || isArrowLeft) && !rtl) ||
                            ((isPageDown || isArrowRight) && rtl)
                        )
                            swiper.slidePrev();
                    } else {
                        if (isPageUp || isPageDown || isArrowUp || isArrowDown) {
                            if (e.preventDefault) e.preventDefault();
                            else e.returnValue = false;
                        }
                        if (isPageDown || isArrowDown) swiper.slideNext();
                        if (isPageUp || isArrowUp) swiper.slidePrev();
                    }
                    emit("keyPress", kc);
                    return undefined;
                }
                function enable() {
                    if (swiper.keyboard.enabled) return;
                    document.addEventListener("keydown", handle);
                    swiper.keyboard.enabled = true;
                }
                function disable() {
                    if (!swiper.keyboard.enabled) return;
                    document.removeEventListener("keydown", handle);
                    swiper.keyboard.enabled = false;
                }
                on("init", () => {
                    if (swiper.params.keyboard.enabled) {
                        enable();
                    }
                });
                on("destroy", () => {
                    if (swiper.keyboard.enabled) {
                        disable();
                    }
                });
                Object.assign(swiper.keyboard, {
                    enable,
                    disable,
                });
            }

            /* eslint-disable consistent-return */
            function Mousewheel(_ref) {
                let { swiper, extendParams, on, emit } = _ref;
                const window = getWindow();
                extendParams({
                    mousewheel: {
                        enabled: false,
                        releaseOnEdges: false,
                        invert: false,
                        forceToAxis: false,
                        sensitivity: 1,
                        eventsTarget: "container",
                        thresholdDelta: null,
                        thresholdTime: null,
                        noMousewheelClass: "swiper-no-mousewheel",
                    },
                });
                swiper.mousewheel = {
                    enabled: false,
                };
                let timeout;
                let lastScrollTime = now();
                let lastEventBeforeSnap;
                const recentWheelEvents = [];
                function normalize(e) {
                    // Reasonable defaults
                    const PIXEL_STEP = 10;
                    const LINE_HEIGHT = 40;
                    const PAGE_HEIGHT = 800;
                    let sX = 0;
                    let sY = 0; // spinX, spinY
                    let pX = 0;
                    let pY = 0; // pixelX, pixelY

                    // Legacy
                    if ("detail" in e) {
                        sY = e.detail;
                    }
                    if ("wheelDelta" in e) {
                        sY = -e.wheelDelta / 120;
                    }
                    if ("wheelDeltaY" in e) {
                        sY = -e.wheelDeltaY / 120;
                    }
                    if ("wheelDeltaX" in e) {
                        sX = -e.wheelDeltaX / 120;
                    }

                    // side scrolling on FF with DOMMouseScroll
                    if ("axis" in e && e.axis === e.HORIZONTAL_AXIS) {
                        sX = sY;
                        sY = 0;
                    }
                    pX = sX * PIXEL_STEP;
                    pY = sY * PIXEL_STEP;
                    if ("deltaY" in e) {
                        pY = e.deltaY;
                    }
                    if ("deltaX" in e) {
                        pX = e.deltaX;
                    }
                    if (e.shiftKey && !pX) {
                        // if user scrolls with shift he wants horizontal scroll
                        pX = pY;
                        pY = 0;
                    }
                    if ((pX || pY) && e.deltaMode) {
                        if (e.deltaMode === 1) {
                            // delta in LINE units
                            pX *= LINE_HEIGHT;
                            pY *= LINE_HEIGHT;
                        } else {
                            // delta in PAGE units
                            pX *= PAGE_HEIGHT;
                            pY *= PAGE_HEIGHT;
                        }
                    }

                    // Fall-back if spin cannot be determined
                    if (pX && !sX) {
                        sX = pX < 1 ? -1 : 1;
                    }
                    if (pY && !sY) {
                        sY = pY < 1 ? -1 : 1;
                    }
                    return {
                        spinX: sX,
                        spinY: sY,
                        pixelX: pX,
                        pixelY: pY,
                    };
                }
                function handleMouseEnter() {
                    if (!swiper.enabled) return;
                    swiper.mouseEntered = true;
                }
                function handleMouseLeave() {
                    if (!swiper.enabled) return;
                    swiper.mouseEntered = false;
                }
                function animateSlider(newEvent) {
                    if (
                        swiper.params.mousewheel.thresholdDelta &&
                        newEvent.delta < swiper.params.mousewheel.thresholdDelta
                    ) {
                        // Prevent if delta of wheel scroll delta is below configured threshold
                        return false;
                    }
                    if (
                        swiper.params.mousewheel.thresholdTime &&
                        now() - lastScrollTime < swiper.params.mousewheel.thresholdTime
                    ) {
                        // Prevent if time between scrolls is below configured threshold
                        return false;
                    }

                    // If the movement is NOT big enough and
                    // if the last time the user scrolled was too close to the current one (avoid continuously triggering the slider):
                    //   Don't go any further (avoid insignificant scroll movement).
                    if (newEvent.delta >= 6 && now() - lastScrollTime < 60) {
                        // Return false as a default
                        return true;
                    }
                    // If user is scrolling towards the end:
                    //   If the slider hasn't hit the latest slide or
                    //   if the slider is a loop and
                    //   if the slider isn't moving right now:
                    //     Go to next slide and
                    //     emit a scroll event.
                    // Else (the user is scrolling towards the beginning) and
                    // if the slider hasn't hit the first slide or
                    // if the slider is a loop and
                    // if the slider isn't moving right now:
                    //   Go to prev slide and
                    //   emit a scroll event.
                    if (newEvent.direction < 0) {
                        if ((!swiper.isEnd || swiper.params.loop) && !swiper.animating) {
                            swiper.slideNext();
                            emit("scroll", newEvent.raw);
                        }
                    } else if (
                        (!swiper.isBeginning || swiper.params.loop) &&
                        !swiper.animating
                    ) {
                        swiper.slidePrev();
                        emit("scroll", newEvent.raw);
                    }
                    // If you got here is because an animation has been triggered so store the current time
                    lastScrollTime = new window.Date().getTime();
                    // Return false as a default
                    return false;
                }
                function releaseScroll(newEvent) {
                    const params = swiper.params.mousewheel;
                    if (newEvent.direction < 0) {
                        if (
                            swiper.isEnd &&
                            !swiper.params.loop &&
                            params.releaseOnEdges
                        ) {
                            // Return true to animate scroll on edges
                            return true;
                        }
                    } else if (
                        swiper.isBeginning &&
                        !swiper.params.loop &&
                        params.releaseOnEdges
                    ) {
                        // Return true to animate scroll on edges
                        return true;
                    }
                    return false;
                }
                function handle(event) {
                    let e = event;
                    let disableParentSwiper = true;
                    if (!swiper.enabled) return;

                    // Ignore event if the target or its parents have the swiper-no-mousewheel class
                    if (
                        event.target.closest(
                            `.${swiper.params.mousewheel.noMousewheelClass}`
                        )
                    )
                        return;
                    const params = swiper.params.mousewheel;
                    if (swiper.params.cssMode) {
                        e.preventDefault();
                    }
                    let targetEl = swiper.el;
                    if (swiper.params.mousewheel.eventsTarget !== "container") {
                        targetEl = document.querySelector(
                            swiper.params.mousewheel.eventsTarget
                        );
                    }
                    const targetElContainsTarget =
                        targetEl && targetEl.contains(e.target);
                    if (
                        !swiper.mouseEntered &&
                        !targetElContainsTarget &&
                        !params.releaseOnEdges
                    )
                        return true;
                    if (e.originalEvent) e = e.originalEvent; // jquery fix
                    let delta = 0;
                    const rtlFactor = swiper.rtlTranslate ? -1 : 1;
                    const data = normalize(e);
                    if (params.forceToAxis) {
                        if (swiper.isHorizontal()) {
                            if (Math.abs(data.pixelX) > Math.abs(data.pixelY))
                                delta = -data.pixelX * rtlFactor;
                            else return true;
                        } else if (Math.abs(data.pixelY) > Math.abs(data.pixelX))
                            delta = -data.pixelY;
                        else return true;
                    } else {
                        delta =
                            Math.abs(data.pixelX) > Math.abs(data.pixelY)
                                ? -data.pixelX * rtlFactor
                                : -data.pixelY;
                    }
                    if (delta === 0) return true;
                    if (params.invert) delta = -delta;

                    // Get the scroll positions
                    let positions = swiper.getTranslate() + delta * params.sensitivity;
                    if (positions >= swiper.minTranslate())
                        positions = swiper.minTranslate();
                    if (positions <= swiper.maxTranslate())
                        positions = swiper.maxTranslate();

                    // When loop is true:
                    //     the disableParentSwiper will be true.
                    // When loop is false:
                    //     if the scroll positions is not on edge,
                    //     then the disableParentSwiper will be true.
                    //     if the scroll on edge positions,
                    //     then the disableParentSwiper will be false.
                    disableParentSwiper = swiper.params.loop
                        ? true
                        : !(
                            positions === swiper.minTranslate() ||
                            positions === swiper.maxTranslate()
                        );
                    if (disableParentSwiper && swiper.params.nested)
                        e.stopPropagation();
                    if (!swiper.params.freeMode || !swiper.params.freeMode.enabled) {
                        // Register the new event in a variable which stores the relevant data
                        const newEvent = {
                            time: now(),
                            delta: Math.abs(delta),
                            direction: Math.sign(delta),
                            raw: event,
                        };

                        // Keep the most recent events
                        if (recentWheelEvents.length >= 2) {
                            recentWheelEvents.shift(); // only store the last N events
                        }

                        const prevEvent = recentWheelEvents.length
                            ? recentWheelEvents[recentWheelEvents.length - 1]
                            : undefined;
                        recentWheelEvents.push(newEvent);

                        // If there is at least one previous recorded event:
                        //   If direction has changed or
                        //   if the scroll is quicker than the previous one:
                        //     Animate the slider.
                        // Else (this is the first time the wheel is moved):
                        //     Animate the slider.
                        if (prevEvent) {
                            if (
                                newEvent.direction !== prevEvent.direction ||
                                newEvent.delta > prevEvent.delta ||
                                newEvent.time > prevEvent.time + 150
                            ) {
                                animateSlider(newEvent);
                            }
                        } else {
                            animateSlider(newEvent);
                        }

                        // If it's time to release the scroll:
                        //   Return now so you don't hit the preventDefault.
                        if (releaseScroll(newEvent)) {
                            return true;
                        }
                    } else {
                        // Freemode or scrollContainer:

                        // If we recently snapped after a momentum scroll, then ignore wheel events
                        // to give time for the deceleration to finish. Stop ignoring after 500 msecs
                        // or if it's a new scroll (larger delta or inverse sign as last event before
                        // an end-of-momentum snap).
                        const newEvent = {
                            time: now(),
                            delta: Math.abs(delta),
                            direction: Math.sign(delta),
                        };
                        const ignoreWheelEvents =
                            lastEventBeforeSnap &&
                            newEvent.time < lastEventBeforeSnap.time + 500 &&
                            newEvent.delta <= lastEventBeforeSnap.delta &&
                            newEvent.direction === lastEventBeforeSnap.direction;
                        if (!ignoreWheelEvents) {
                            lastEventBeforeSnap = undefined;
                            let position =
                                swiper.getTranslate() + delta * params.sensitivity;
                            const wasBeginning = swiper.isBeginning;
                            const wasEnd = swiper.isEnd;
                            if (position >= swiper.minTranslate())
                                position = swiper.minTranslate();
                            if (position <= swiper.maxTranslate())
                                position = swiper.maxTranslate();
                            swiper.setTransition(0);
                            swiper.setTranslate(position);
                            swiper.updateProgress();
                            swiper.updateActiveIndex();
                            swiper.updateSlidesClasses();
                            if (
                                (!wasBeginning && swiper.isBeginning) ||
                                (!wasEnd && swiper.isEnd)
                            ) {
                                swiper.updateSlidesClasses();
                            }
                            if (swiper.params.loop) {
                                swiper.loopFix({
                                    direction: newEvent.direction < 0 ? "next" : "prev",
                                    byMousewheel: true,
                                });
                            }
                            if (swiper.params.freeMode.sticky) {
                                // When wheel scrolling starts with sticky (aka snap) enabled, then detect
                                // the end of a momentum scroll by storing recent (N=15?) wheel events.
                                // 1. do all N events have decreasing or same (absolute value) delta?
                                // 2. did all N events arrive in the last M (M=500?) msecs?
                                // 3. does the earliest event have an (absolute value) delta that's
                                //    at least P (P=1?) larger than the most recent event's delta?
                                // 4. does the latest event have a delta that's smaller than Q (Q=6?) pixels?
                                // If 1-4 are "yes" then we're near the end of a momentum scroll deceleration.
                                // Snap immediately and ignore remaining wheel events in this scroll.
                                // See comment above for "remaining wheel events in this scroll" determination.
                                // If 1-4 aren't satisfied, then wait to snap until 500ms after the last event.
                                clearTimeout(timeout);
                                timeout = undefined;
                                if (recentWheelEvents.length >= 15) {
                                    recentWheelEvents.shift(); // only store the last N events
                                }

                                const prevEvent = recentWheelEvents.length
                                    ? recentWheelEvents[recentWheelEvents.length - 1]
                                    : undefined;
                                const firstEvent = recentWheelEvents[0];
                                recentWheelEvents.push(newEvent);
                                if (
                                    prevEvent &&
                                    (newEvent.delta > prevEvent.delta ||
                                        newEvent.direction !== prevEvent.direction)
                                ) {
                                    // Increasing or reverse-sign delta means the user started scrolling again. Clear the wheel event log.
                                    recentWheelEvents.splice(0);
                                } else if (
                                    recentWheelEvents.length >= 15 &&
                                    newEvent.time - firstEvent.time < 500 &&
                                    firstEvent.delta - newEvent.delta >= 1 &&
                                    newEvent.delta <= 6
                                ) {
                                    // We're at the end of the deceleration of a momentum scroll, so there's no need
                                    // to wait for more events. Snap ASAP on the next tick.
                                    // Also, because there's some remaining momentum we'll bias the snap in the
                                    // direction of the ongoing scroll because it's better UX for the scroll to snap
                                    // in the same direction as the scroll instead of reversing to snap.  Therefore,
                                    // if it's already scrolled more than 20% in the current direction, keep going.
                                    const snapToThreshold = delta > 0 ? 0.8 : 0.2;
                                    lastEventBeforeSnap = newEvent;
                                    recentWheelEvents.splice(0);
                                    timeout = nextTick(() => {
                                        swiper.slideToClosest(
                                            swiper.params.speed,
                                            true,
                                            undefined,
                                            snapToThreshold
                                        );
                                    }, 0); // no delay; move on next tick
                                }

                                if (!timeout) {
                                    // if we get here, then we haven't detected the end of a momentum scroll, so
                                    // we'll consider a scroll "complete" when there haven't been any wheel events
                                    // for 500ms.
                                    timeout = nextTick(() => {
                                        const snapToThreshold = 0.5;
                                        lastEventBeforeSnap = newEvent;
                                        recentWheelEvents.splice(0);
                                        swiper.slideToClosest(
                                            swiper.params.speed,
                                            true,
                                            undefined,
                                            snapToThreshold
                                        );
                                    }, 500);
                                }
                            }

                            // Emit event
                            if (!ignoreWheelEvents) emit("scroll", e);

                            // Stop autoplay
                            if (
                                swiper.params.autoplay &&
                                swiper.params.autoplayDisableOnInteraction
                            )
                                swiper.autoplay.stop();
                            // Return page scroll on edge positions
                            if (
                                position === swiper.minTranslate() ||
                                position === swiper.maxTranslate()
                            )
                                return true;
                        }
                    }
                    if (e.preventDefault) e.preventDefault();
                    else e.returnValue = false;
                    return false;
                }
                function events(method) {
                    let targetEl = swiper.el;
                    if (swiper.params.mousewheel.eventsTarget !== "container") {
                        targetEl = document.querySelector(
                            swiper.params.mousewheel.eventsTarget
                        );
                    }
                    targetEl[method]("mouseenter", handleMouseEnter);
                    targetEl[method]("mouseleave", handleMouseLeave);
                    targetEl[method]("wheel", handle);
                }
                function enable() {
                    if (swiper.params.cssMode) {
                        swiper.wrapperEl.removeEventListener("wheel", handle);
                        return true;
                    }
                    if (swiper.mousewheel.enabled) return false;
                    events("addEventListener");
                    swiper.mousewheel.enabled = true;
                    return true;
                }
                function disable() {
                    if (swiper.params.cssMode) {
                        swiper.wrapperEl.addEventListener(event, handle);
                        return true;
                    }
                    if (!swiper.mousewheel.enabled) return false;
                    events("removeEventListener");
                    swiper.mousewheel.enabled = false;
                    return true;
                }
                on("init", () => {
                    if (!swiper.params.mousewheel.enabled && swiper.params.cssMode) {
                        disable();
                    }
                    if (swiper.params.mousewheel.enabled) enable();
                });
                on("destroy", () => {
                    if (swiper.params.cssMode) {
                        enable();
                    }
                    if (swiper.mousewheel.enabled) disable();
                });
                Object.assign(swiper.mousewheel, {
                    enable,
                    disable,
                });
            }

            function createElementIfNotDefined(
                swiper,
                originalParams,
                params,
                checkProps
            ) {
                if (swiper.params.createElements) {
                    Object.keys(checkProps).forEach((key) => {
                        if (!params[key] && params.auto === true) {
                            let element = elementChildren(
                                swiper.el,
                                `.${checkProps[key]}`
                            )[0];
                            if (!element) {
                                element = createElement("div", checkProps[key]);
                                element.className = checkProps[key];
                                swiper.el.append(element);
                            }
                            params[key] = element;
                            originalParams[key] = element;
                        }
                    });
                }
                return params;
            }

            function Navigation(_ref) {
                let { swiper, extendParams, on, emit } = _ref;
                extendParams({
                    navigation: {
                        nextEl: null,
                        prevEl: null,
                        hideOnClick: false,
                        disabledClass: "swiper-button-disabled",
                        hiddenClass: "swiper-button-hidden",
                        lockClass: "swiper-button-lock",
                        navigationDisabledClass: "swiper-navigation-disabled",
                    },
                });
                swiper.navigation = {
                    nextEl: null,
                    prevEl: null,
                };
                const makeElementsArray = (el) => {
                    if (!Array.isArray(el)) el = [el].filter((e) => !!e);
                    return el;
                };
                function getEl(el) {
                    let res;
                    if (el && typeof el === "string" && swiper.isElement) {
                        res = swiper.el.querySelector(el);
                        if (res) return res;
                    }
                    if (el) {
                        if (typeof el === "string")
                            res = [...document.querySelectorAll(el)];
                        if (
                            swiper.params.uniqueNavElements &&
                            typeof el === "string" &&
                            res.length > 1 &&
                            swiper.el.querySelectorAll(el).length === 1
                        ) {
                            res = swiper.el.querySelector(el);
                        }
                    }
                    if (el && !res) return el;
                    // if (Array.isArray(res) && res.length === 1) res = res[0];
                    return res;
                }
                function toggleEl(el, disabled) {
                    const params = swiper.params.navigation;
                    el = makeElementsArray(el);
                    el.forEach((subEl) => {
                        if (subEl) {
                            subEl.classList[disabled ? "add" : "remove"](
                                ...params.disabledClass.split(" ")
                            );
                            if (subEl.tagName === "BUTTON") subEl.disabled = disabled;
                            if (swiper.params.watchOverflow && swiper.enabled) {
                                subEl.classList[swiper.isLocked ? "add" : "remove"](
                                    params.lockClass
                                );
                            }
                        }
                    });
                }
                function update() {
                    // Update Navigation Buttons
                    const { nextEl, prevEl } = swiper.navigation;
                    if (swiper.params.loop) {
                        toggleEl(prevEl, false);
                        toggleEl(nextEl, false);
                        return;
                    }
                    toggleEl(prevEl, swiper.isBeginning && !swiper.params.rewind);
                    toggleEl(nextEl, swiper.isEnd && !swiper.params.rewind);
                }
                function onPrevClick(e) {
                    e.preventDefault();
                    if (
                        swiper.isBeginning &&
                        !swiper.params.loop &&
                        !swiper.params.rewind
                    )
                        return;
                    swiper.slidePrev();
                    emit("navigationPrev");
                }
                function onNextClick(e) {
                    e.preventDefault();
                    if (swiper.isEnd && !swiper.params.loop && !swiper.params.rewind)
                        return;
                    swiper.slideNext();
                    emit("navigationNext");
                }
                function init() {
                    const params = swiper.params.navigation;
                    swiper.params.navigation = createElementIfNotDefined(
                        swiper,
                        swiper.originalParams.navigation,
                        swiper.params.navigation,
                        {
                            nextEl: "swiper-button-next",
                            prevEl: "swiper-button-prev",
                        }
                    );
                    if (!(params.nextEl || params.prevEl)) return;
                    let nextEl = getEl(params.nextEl);
                    let prevEl = getEl(params.prevEl);
                    Object.assign(swiper.navigation, {
                        nextEl,
                        prevEl,
                    });
                    nextEl = makeElementsArray(nextEl);
                    prevEl = makeElementsArray(prevEl);
                    const initButton = (el, dir) => {
                        if (el) {
                            el.addEventListener(
                                "click",
                                dir === "next" ? onNextClick : onPrevClick
                            );
                        }
                        if (!swiper.enabled && el) {
                            el.classList.add(...params.lockClass.split(" "));
                        }
                    };
                    nextEl.forEach((el) => initButton(el, "next"));
                    prevEl.forEach((el) => initButton(el, "prev"));
                }
                function destroy() {
                    let { nextEl, prevEl } = swiper.navigation;
                    nextEl = makeElementsArray(nextEl);
                    prevEl = makeElementsArray(prevEl);
                    const destroyButton = (el, dir) => {
                        el.removeEventListener(
                            "click",
                            dir === "next" ? onNextClick : onPrevClick
                        );
                        el.classList.remove(
                            ...swiper.params.navigation.disabledClass.split(" ")
                        );
                    };
                    nextEl.forEach((el) => destroyButton(el, "next"));
                    prevEl.forEach((el) => destroyButton(el, "prev"));
                }
                on("init", () => {
                    if (swiper.params.navigation.enabled === false) {
                        // eslint-disable-next-line
                        disable();
                    } else {
                        init();
                        update();
                    }
                });
                on("toEdge fromEdge lock unlock", () => {
                    update();
                });
                on("destroy", () => {
                    destroy();
                });
                on("enable disable", () => {
                    let { nextEl, prevEl } = swiper.navigation;
                    nextEl = makeElementsArray(nextEl);
                    prevEl = makeElementsArray(prevEl);
                    [...nextEl, ...prevEl]
                        .filter((el) => !!el)
                        .forEach((el) =>
                            el.classList[swiper.enabled ? "remove" : "add"](
                                swiper.params.navigation.lockClass
                            )
                        );
                });
                on("click", (_s, e) => {
                    let { nextEl, prevEl } = swiper.navigation;
                    nextEl = makeElementsArray(nextEl);
                    prevEl = makeElementsArray(prevEl);
                    const targetEl = e.target;
                    if (
                        swiper.params.navigation.hideOnClick &&
                        !prevEl.includes(targetEl) &&
                        !nextEl.includes(targetEl)
                    ) {
                        if (
                            swiper.pagination &&
                            swiper.params.pagination &&
                            swiper.params.pagination.clickable &&
                            (swiper.pagination.el === targetEl ||
                                swiper.pagination.el.contains(targetEl))
                        )
                            return;
                        let isHidden;
                        if (nextEl.length) {
                            isHidden = nextEl[0].classList.contains(
                                swiper.params.navigation.hiddenClass
                            );
                        } else if (prevEl.length) {
                            isHidden = prevEl[0].classList.contains(
                                swiper.params.navigation.hiddenClass
                            );
                        }
                        if (isHidden === true) {
                            emit("navigationShow");
                        } else {
                            emit("navigationHide");
                        }
                        [...nextEl, ...prevEl]
                            .filter((el) => !!el)
                            .forEach((el) =>
                                el.classList.toggle(swiper.params.navigation.hiddenClass)
                            );
                    }
                });
                const enable = () => {
                    swiper.el.classList.remove(
                        ...swiper.params.navigation.navigationDisabledClass.split(" ")
                    );
                    init();
                    update();
                };
                const disable = () => {
                    swiper.el.classList.add(
                        ...swiper.params.navigation.navigationDisabledClass.split(" ")
                    );
                    destroy();
                };
                Object.assign(swiper.navigation, {
                    enable,
                    disable,
                    update,
                    init,
                    destroy,
                });
            }

            function classesToSelector(classes) {
                if (classes === void 0) {
                    classes = "";
                }
                return `.${classes
                    .trim()
                    .replace(/([\.:!+\/])/g, "\\$1") // eslint-disable-line
                    .replace(/ /g, ".")}`;
            }

            function Pagination(_ref) {
                let { swiper, extendParams, on, emit } = _ref;
                const pfx = "swiper-pagination";
                extendParams({
                    pagination: {
                        el: null,
                        bulletElement: "span",
                        clickable: false,
                        hideOnClick: false,
                        renderBullet: null,
                        renderProgressbar: null,
                        renderFraction: null,
                        renderCustom: null,
                        progressbarOpposite: false,
                        type: "bullets",
                        // 'bullets' or 'progressbar' or 'fraction' or 'custom'
                        dynamicBullets: false,
                        dynamicMainBullets: 1,
                        formatFractionCurrent: (number) => number,
                        formatFractionTotal: (number) => number,
                        bulletClass: `${pfx}-bullet`,
                        bulletActiveClass: `${pfx}-bullet-active`,
                        modifierClass: `${pfx}-`,
                        currentClass: `${pfx}-current`,
                        totalClass: `${pfx}-total`,
                        hiddenClass: `${pfx}-hidden`,
                        progressbarFillClass: `${pfx}-progressbar-fill`,
                        progressbarOppositeClass: `${pfx}-progressbar-opposite`,
                        clickableClass: `${pfx}-clickable`,
                        lockClass: `${pfx}-lock`,
                        horizontalClass: `${pfx}-horizontal`,
                        verticalClass: `${pfx}-vertical`,
                        paginationDisabledClass: `${pfx}-disabled`,
                    },
                });
                swiper.pagination = {
                    el: null,
                    bullets: [],
                };
                let bulletSize;
                let dynamicBulletIndex = 0;
                const makeElementsArray = (el) => {
                    if (!Array.isArray(el)) el = [el].filter((e) => !!e);
                    return el;
                };
                function isPaginationDisabled() {
                    return (
                        !swiper.params.pagination.el ||
                        !swiper.pagination.el ||
                        (Array.isArray(swiper.pagination.el) &&
                            swiper.pagination.el.length === 0)
                    );
                }
                function setSideBullets(bulletEl, position) {
                    const { bulletActiveClass } = swiper.params.pagination;
                    if (!bulletEl) return;
                    bulletEl =
                        bulletEl[
                        `${position === "prev" ? "previous" : "next"}ElementSibling`
                        ];
                    if (bulletEl) {
                        bulletEl.classList.add(`${bulletActiveClass}-${position}`);
                        bulletEl =
                            bulletEl[
                            `${position === "prev" ? "previous" : "next"}ElementSibling`
                            ];
                        if (bulletEl) {
                            bulletEl.classList.add(
                                `${bulletActiveClass}-${position}-${position}`
                            );
                        }
                    }
                }
                function onBulletClick(e) {
                    const bulletEl = e.target.closest(
                        classesToSelector(swiper.params.pagination.bulletClass)
                    );
                    if (!bulletEl) {
                        return;
                    }
                    e.preventDefault();
                    const index = elementIndex(bulletEl) * swiper.params.slidesPerGroup;
                    if (swiper.params.loop) {
                        if (swiper.realIndex === index) return;
                        const newSlideIndex = swiper.getSlideIndexByData(index);
                        const currentSlideIndex = swiper.getSlideIndexByData(
                            swiper.realIndex
                        );
                        if (newSlideIndex > swiper.slides.length - swiper.loopedSlides) {
                            swiper.loopFix({
                                direction:
                                    newSlideIndex > currentSlideIndex ? "next" : "prev",
                                activeSlideIndex: newSlideIndex,
                                slideTo: false,
                            });
                        }
                        swiper.slideToLoop(index);
                    } else {
                        swiper.slideTo(index);
                    }
                }
                function update() {
                    // Render || Update Pagination bullets/items
                    const rtl = swiper.rtl;
                    const params = swiper.params.pagination;
                    if (isPaginationDisabled()) return;
                    let el = swiper.pagination.el;
                    el = makeElementsArray(el);
                    // Current/Total
                    let current;
                    let previousIndex;
                    const slidesLength =
                        swiper.virtual && swiper.params.virtual.enabled
                            ? swiper.virtual.slides.length
                            : swiper.slides.length;
                    const total = swiper.params.loop
                        ? Math.ceil(slidesLength / swiper.params.slidesPerGroup)
                        : swiper.snapGrid.length;
                    if (swiper.params.loop) {
                        previousIndex = swiper.previousRealIndex || 0;
                        current =
                            swiper.params.slidesPerGroup > 1
                                ? Math.floor(swiper.realIndex / swiper.params.slidesPerGroup)
                                : swiper.realIndex;
                    } else if (typeof swiper.snapIndex !== "undefined") {
                        current = swiper.snapIndex;
                        previousIndex = swiper.previousSnapIndex;
                    } else {
                        previousIndex = swiper.previousIndex || 0;
                        current = swiper.activeIndex || 0;
                    }
                    // Types
                    if (
                        params.type === "bullets" &&
                        swiper.pagination.bullets &&
                        swiper.pagination.bullets.length > 0
                    ) {
                        const bullets = swiper.pagination.bullets;
                        let firstIndex;
                        let lastIndex;
                        let midIndex;
                        if (params.dynamicBullets) {
                            bulletSize = elementOuterSize(
                                bullets[0],
                                swiper.isHorizontal() ? "width" : "height",
                                true
                            );
                            el.forEach((subEl) => {
                                subEl.style[swiper.isHorizontal() ? "width" : "height"] = `${bulletSize * (params.dynamicMainBullets + 4)
                                    }px`;
                            });
                            if (
                                params.dynamicMainBullets > 1 &&
                                previousIndex !== undefined
                            ) {
                                dynamicBulletIndex += current - (previousIndex || 0);
                                if (dynamicBulletIndex > params.dynamicMainBullets - 1) {
                                    dynamicBulletIndex = params.dynamicMainBullets - 1;
                                } else if (dynamicBulletIndex < 0) {
                                    dynamicBulletIndex = 0;
                                }
                            }
                            firstIndex = Math.max(current - dynamicBulletIndex, 0);
                            lastIndex =
                                firstIndex +
                                (Math.min(bullets.length, params.dynamicMainBullets) - 1);
                            midIndex = (lastIndex + firstIndex) / 2;
                        }
                        bullets.forEach((bulletEl) => {
                            const classesToRemove = [
                                ...[
                                    "",
                                    "-next",
                                    "-next-next",
                                    "-prev",
                                    "-prev-prev",
                                    "-main",
                                ].map((suffix) => `${params.bulletActiveClass}${suffix}`),
                            ]
                                .map((s) =>
                                    typeof s === "string" && s.includes(" ") ? s.split(" ") : s
                                )
                                .flat();
                            bulletEl.classList.remove(...classesToRemove);
                        });
                        if (el.length > 1) {
                            bullets.forEach((bullet) => {
                                const bulletIndex = elementIndex(bullet);
                                if (bulletIndex === current) {
                                    bullet.classList.add(
                                        ...params.bulletActiveClass.split(" ")
                                    );
                                } else if (swiper.isElement) {
                                    bullet.setAttribute("part", "bullet");
                                }
                                if (params.dynamicBullets) {
                                    if (bulletIndex >= firstIndex && bulletIndex <= lastIndex) {
                                        bullet.classList.add(
                                            ...`${params.bulletActiveClass}-main`.split(" ")
                                        );
                                    }
                                    if (bulletIndex === firstIndex) {
                                        setSideBullets(bullet, "prev");
                                    }
                                    if (bulletIndex === lastIndex) {
                                        setSideBullets(bullet, "next");
                                    }
                                }
                            });
                        } else {
                            const bullet = bullets[current];
                            if (bullet) {
                                bullet.classList.add(...params.bulletActiveClass.split(" "));
                            }
                            if (swiper.isElement) {
                                bullets.forEach((bulletEl, bulletIndex) => {
                                    bulletEl.setAttribute(
                                        "part",
                                        bulletIndex === current ? "bullet-active" : "bullet"
                                    );
                                });
                            }
                            if (params.dynamicBullets) {
                                const firstDisplayedBullet = bullets[firstIndex];
                                const lastDisplayedBullet = bullets[lastIndex];
                                for (let i = firstIndex; i <= lastIndex; i += 1) {
                                    if (bullets[i]) {
                                        bullets[i].classList.add(
                                            ...`${params.bulletActiveClass}-main`.split(" ")
                                        );
                                    }
                                }
                                setSideBullets(firstDisplayedBullet, "prev");
                                setSideBullets(lastDisplayedBullet, "next");
                            }
                        }
                        if (params.dynamicBullets) {
                            const dynamicBulletsLength = Math.min(
                                bullets.length,
                                params.dynamicMainBullets + 4
                            );
                            const bulletsOffset =
                                (bulletSize * dynamicBulletsLength - bulletSize) / 2 -
                                midIndex * bulletSize;
                            const offsetProp = rtl ? "right" : "left";
                            bullets.forEach((bullet) => {
                                bullet.style[
                                    swiper.isHorizontal() ? offsetProp : "top"
                                ] = `${bulletsOffset}px`;
                            });
                        }
                    }
                    el.forEach((subEl, subElIndex) => {
                        if (params.type === "fraction") {
                            subEl
                                .querySelectorAll(classesToSelector(params.currentClass))
                                .forEach((fractionEl) => {
                                    fractionEl.textContent = params.formatFractionCurrent(
                                        current + 1
                                    );
                                });
                            subEl
                                .querySelectorAll(classesToSelector(params.totalClass))
                                .forEach((totalEl) => {
                                    totalEl.textContent = params.formatFractionTotal(total);
                                });
                        }
                        if (params.type === "progressbar") {
                            let progressbarDirection;
                            if (params.progressbarOpposite) {
                                progressbarDirection = swiper.isHorizontal()
                                    ? "vertical"
                                    : "horizontal";
                            } else {
                                progressbarDirection = swiper.isHorizontal()
                                    ? "horizontal"
                                    : "vertical";
                            }
                            const scale = (current + 1) / total;
                            let scaleX = 1;
                            let scaleY = 1;
                            if (progressbarDirection === "horizontal") {
                                scaleX = scale;
                            } else {
                                scaleY = scale;
                            }
                            subEl
                                .querySelectorAll(
                                    classesToSelector(params.progressbarFillClass)
                                )
                                .forEach((progressEl) => {
                                    progressEl.style.transform = `translate3d(0,0,0) scaleX(${scaleX}) scaleY(${scaleY})`;
                                    progressEl.style.transitionDuration = `${swiper.params.speed}ms`;
                                });
                        }
                        if (params.type === "custom" && params.renderCustom) {
                            subEl.innerHTML = params.renderCustom(
                                swiper,
                                current + 1,
                                total
                            );
                            if (subElIndex === 0) emit("paginationRender", subEl);
                        } else {
                            if (subElIndex === 0) emit("paginationRender", subEl);
                            emit("paginationUpdate", subEl);
                        }
                        if (swiper.params.watchOverflow && swiper.enabled) {
                            subEl.classList[swiper.isLocked ? "add" : "remove"](
                                params.lockClass
                            );
                        }
                    });
                }
                function render() {
                    // Render Container
                    const params = swiper.params.pagination;
                    if (isPaginationDisabled()) return;
                    const slidesLength =
                        swiper.virtual && swiper.params.virtual.enabled
                            ? swiper.virtual.slides.length
                            : swiper.slides.length;
                    let el = swiper.pagination.el;
                    el = makeElementsArray(el);
                    let paginationHTML = "";
                    if (params.type === "bullets") {
                        let numberOfBullets = swiper.params.loop
                            ? Math.ceil(slidesLength / swiper.params.slidesPerGroup)
                            : swiper.snapGrid.length;
                        if (
                            swiper.params.freeMode &&
                            swiper.params.freeMode.enabled &&
                            numberOfBullets > slidesLength
                        ) {
                            numberOfBullets = slidesLength;
                        }
                        for (let i = 0; i < numberOfBullets; i += 1) {
                            if (params.renderBullet) {
                                paginationHTML += params.renderBullet.call(
                                    swiper,
                                    i,
                                    params.bulletClass
                                );
                            } else {
                                // prettier-ignore
                                paginationHTML += `<${params.bulletElement} ${swiper.isElement ? 'part="bullet"' : ''} class="${params.bulletClass}"></${params.bulletElement}>`;
                            }
                        }
                    }
                    if (params.type === "fraction") {
                        if (params.renderFraction) {
                            paginationHTML = params.renderFraction.call(
                                swiper,
                                params.currentClass,
                                params.totalClass
                            );
                        } else {
                            paginationHTML =
                                `<span class="${params.currentClass}"></span>` +
                                " / " +
                                `<span class="${params.totalClass}"></span>`;
                        }
                    }
                    if (params.type === "progressbar") {
                        if (params.renderProgressbar) {
                            paginationHTML = params.renderProgressbar.call(
                                swiper,
                                params.progressbarFillClass
                            );
                        } else {
                            paginationHTML = `<span class="${params.progressbarFillClass}"></span>`;
                        }
                    }
                    swiper.pagination.bullets = [];
                    el.forEach((subEl) => {
                        if (params.type !== "custom") {
                            subEl.innerHTML = paginationHTML || "";
                        }
                        if (params.type === "bullets") {
                            swiper.pagination.bullets.push(
                                ...subEl.querySelectorAll(
                                    classesToSelector(params.bulletClass)
                                )
                            );
                        }
                    });
                    if (params.type !== "custom") {
                        emit("paginationRender", el[0]);
                    }
                }
                function init() {
                    swiper.params.pagination = createElementIfNotDefined(
                        swiper,
                        swiper.originalParams.pagination,
                        swiper.params.pagination,
                        {
                            el: "swiper-pagination",
                        }
                    );
                    const params = swiper.params.pagination;
                    if (!params.el) return;
                    let el;
                    if (typeof params.el === "string" && swiper.isElement) {
                        el = swiper.el.querySelector(params.el);
                    }
                    if (!el && typeof params.el === "string") {
                        el = [...document.querySelectorAll(params.el)];
                    }
                    if (!el) {
                        el = params.el;
                    }
                    if (!el || el.length === 0) return;
                    if (
                        swiper.params.uniqueNavElements &&
                        typeof params.el === "string" &&
                        Array.isArray(el) &&
                        el.length > 1
                    ) {
                        el = [...swiper.el.querySelectorAll(params.el)];
                        // check if it belongs to another nested Swiper
                        if (el.length > 1) {
                            el = el.filter((subEl) => {
                                if (elementParents(subEl, ".swiper")[0] !== swiper.el)
                                    return false;
                                return true;
                            })[0];
                        }
                    }
                    if (Array.isArray(el) && el.length === 1) el = el[0];
                    Object.assign(swiper.pagination, {
                        el,
                    });
                    el = makeElementsArray(el);
                    el.forEach((subEl) => {
                        if (params.type === "bullets" && params.clickable) {
                            subEl.classList.add(params.clickableClass);
                        }
                        subEl.classList.add(params.modifierClass + params.type);
                        subEl.classList.add(
                            swiper.isHorizontal()
                                ? params.horizontalClass
                                : params.verticalClass
                        );
                        if (params.type === "bullets" && params.dynamicBullets) {
                            subEl.classList.add(
                                `${params.modifierClass}${params.type}-dynamic`
                            );
                            dynamicBulletIndex = 0;
                            if (params.dynamicMainBullets < 1) {
                                params.dynamicMainBullets = 1;
                            }
                        }
                        if (params.type === "progressbar" && params.progressbarOpposite) {
                            subEl.classList.add(params.progressbarOppositeClass);
                        }
                        if (params.clickable) {
                            subEl.addEventListener("click", onBulletClick);
                        }
                        if (!swiper.enabled) {
                            subEl.classList.add(params.lockClass);
                        }
                    });
                }
                function destroy() {
                    const params = swiper.params.pagination;
                    if (isPaginationDisabled()) return;
                    let el = swiper.pagination.el;
                    if (el) {
                        el = makeElementsArray(el);
                        el.forEach((subEl) => {
                            subEl.classList.remove(params.hiddenClass);
                            subEl.classList.remove(params.modifierClass + params.type);
                            subEl.classList.remove(
                                swiper.isHorizontal()
                                    ? params.horizontalClass
                                    : params.verticalClass
                            );
                            if (params.clickable) {
                                subEl.removeEventListener("click", onBulletClick);
                            }
                        });
                    }
                    if (swiper.pagination.bullets)
                        swiper.pagination.bullets.forEach((subEl) =>
                            subEl.classList.remove(...params.bulletActiveClass.split(" "))
                        );
                }
                on("changeDirection", () => {
                    if (!swiper.pagination || !swiper.pagination.el) return;
                    const params = swiper.params.pagination;
                    let { el } = swiper.pagination;
                    el = makeElementsArray(el);
                    el.forEach((subEl) => {
                        subEl.classList.remove(
                            params.horizontalClass,
                            params.verticalClass
                        );
                        subEl.classList.add(
                            swiper.isHorizontal()
                                ? params.horizontalClass
                                : params.verticalClass
                        );
                    });
                });
                on("init", () => {
                    if (swiper.params.pagination.enabled === false) {
                        // eslint-disable-next-line
                        disable();
                    } else {
                        init();
                        render();
                        update();
                    }
                });
                on("activeIndexChange", () => {
                    if (typeof swiper.snapIndex === "undefined") {
                        update();
                    }
                });
                on("snapIndexChange", () => {
                    update();
                });
                on("snapGridLengthChange", () => {
                    render();
                    update();
                });
                on("destroy", () => {
                    destroy();
                });
                on("enable disable", () => {
                    let { el } = swiper.pagination;
                    if (el) {
                        el = makeElementsArray(el);
                        el.forEach((subEl) =>
                            subEl.classList[swiper.enabled ? "remove" : "add"](
                                swiper.params.pagination.lockClass
                            )
                        );
                    }
                });
                on("lock unlock", () => {
                    update();
                });
                on("click", (_s, e) => {
                    const targetEl = e.target;
                    const el = makeElementsArray(swiper.pagination.el);
                    if (
                        swiper.params.pagination.el &&
                        swiper.params.pagination.hideOnClick &&
                        el &&
                        el.length > 0 &&
                        !targetEl.classList.contains(swiper.params.pagination.bulletClass)
                    ) {
                        if (
                            swiper.navigation &&
                            ((swiper.navigation.nextEl &&
                                targetEl === swiper.navigation.nextEl) ||
                                (swiper.navigation.prevEl &&
                                    targetEl === swiper.navigation.prevEl))
                        )
                            return;
                        const isHidden = el[0].classList.contains(
                            swiper.params.pagination.hiddenClass
                        );
                        if (isHidden === true) {
                            emit("paginationShow");
                        } else {
                            emit("paginationHide");
                        }
                        el.forEach((subEl) =>
                            subEl.classList.toggle(swiper.params.pagination.hiddenClass)
                        );
                    }
                });
                const enable = () => {
                    swiper.el.classList.remove(
                        swiper.params.pagination.paginationDisabledClass
                    );
                    let { el } = swiper.pagination;
                    if (el) {
                        el = makeElementsArray(el);
                        el.forEach((subEl) =>
                            subEl.classList.remove(
                                swiper.params.pagination.paginationDisabledClass
                            )
                        );
                    }
                    init();
                    render();
                    update();
                };
                const disable = () => {
                    swiper.el.classList.add(
                        swiper.params.pagination.paginationDisabledClass
                    );
                    let { el } = swiper.pagination;
                    if (el) {
                        el = makeElementsArray(el);
                        el.forEach((subEl) =>
                            subEl.classList.add(
                                swiper.params.pagination.paginationDisabledClass
                            )
                        );
                    }
                    destroy();
                };
                Object.assign(swiper.pagination, {
                    enable,
                    disable,
                    render,
                    update,
                    init,
                    destroy,
                });
            }

            function Scrollbar(_ref) {
                let { swiper, extendParams, on, emit } = _ref;
                const document = getDocument();
                let isTouched = false;
                let timeout = null;
                let dragTimeout = null;
                let dragStartPos;
                let dragSize;
                let trackSize;
                let divider;
                extendParams({
                    scrollbar: {
                        el: null,
                        dragSize: "auto",
                        hide: false,
                        draggable: false,
                        snapOnRelease: true,
                        lockClass: "swiper-scrollbar-lock",
                        dragClass: "swiper-scrollbar-drag",
                        scrollbarDisabledClass: "swiper-scrollbar-disabled",
                        horizontalClass: `swiper-scrollbar-horizontal`,
                        verticalClass: `swiper-scrollbar-vertical`,
                    },
                });
                swiper.scrollbar = {
                    el: null,
                    dragEl: null,
                };
                function setTranslate() {
                    if (!swiper.params.scrollbar.el || !swiper.scrollbar.el) return;
                    const { scrollbar, rtlTranslate: rtl } = swiper;
                    const { dragEl, el } = scrollbar;
                    const params = swiper.params.scrollbar;
                    const progress = swiper.params.loop
                        ? swiper.progressLoop
                        : swiper.progress;
                    let newSize = dragSize;
                    let newPos = (trackSize - dragSize) * progress;
                    if (rtl) {
                        newPos = -newPos;
                        if (newPos > 0) {
                            newSize = dragSize - newPos;
                            newPos = 0;
                        } else if (-newPos + dragSize > trackSize) {
                            newSize = trackSize + newPos;
                        }
                    } else if (newPos < 0) {
                        newSize = dragSize + newPos;
                        newPos = 0;
                    } else if (newPos + dragSize > trackSize) {
                        newSize = trackSize - newPos;
                    }
                    if (swiper.isHorizontal()) {
                        dragEl.style.transform = `translate3d(${newPos}px, 0, 0)`;
                        dragEl.style.width = `${newSize}px`;
                    } else {
                        dragEl.style.transform = `translate3d(0px, ${newPos}px, 0)`;
                        dragEl.style.height = `${newSize}px`;
                    }
                    if (params.hide) {
                        clearTimeout(timeout);
                        el.style.opacity = 1;
                        timeout = setTimeout(() => {
                            el.style.opacity = 0;
                            el.style.transitionDuration = "400ms";
                        }, 1000);
                    }
                }
                function setTransition(duration) {
                    if (!swiper.params.scrollbar.el || !swiper.scrollbar.el) return;
                    swiper.scrollbar.dragEl.style.transitionDuration = `${duration}ms`;
                }
                function updateSize() {
                    if (!swiper.params.scrollbar.el || !swiper.scrollbar.el) return;
                    const { scrollbar } = swiper;
                    const { dragEl, el } = scrollbar;
                    dragEl.style.width = "";
                    dragEl.style.height = "";
                    trackSize = swiper.isHorizontal()
                        ? el.offsetWidth
                        : el.offsetHeight;
                    divider =
                        swiper.size /
                        (swiper.virtualSize +
                            swiper.params.slidesOffsetBefore -
                            (swiper.params.centeredSlides ? swiper.snapGrid[0] : 0));
                    if (swiper.params.scrollbar.dragSize === "auto") {
                        dragSize = trackSize * divider;
                    } else {
                        dragSize = parseInt(swiper.params.scrollbar.dragSize, 10);
                    }
                    if (swiper.isHorizontal()) {
                        dragEl.style.width = `${dragSize}px`;
                    } else {
                        dragEl.style.height = `${dragSize}px`;
                    }
                    if (divider >= 1) {
                        el.style.display = "none";
                    } else {
                        el.style.display = "";
                    }
                    if (swiper.params.scrollbar.hide) {
                        el.style.opacity = 0;
                    }
                    if (swiper.params.watchOverflow && swiper.enabled) {
                        scrollbar.el.classList[swiper.isLocked ? "add" : "remove"](
                            swiper.params.scrollbar.lockClass
                        );
                    }
                }
                function getPointerPosition(e) {
                    return swiper.isHorizontal() ? e.clientX : e.clientY;
                }
                function setDragPosition(e) {
                    const { scrollbar, rtlTranslate: rtl } = swiper;
                    const { el } = scrollbar;
                    let positionRatio;
                    positionRatio =
                        (getPointerPosition(e) -
                            elementOffset(el)[swiper.isHorizontal() ? "left" : "top"] -
                            (dragStartPos !== null ? dragStartPos : dragSize / 2)) /
                        (trackSize - dragSize);
                    positionRatio = Math.max(Math.min(positionRatio, 1), 0);
                    if (rtl) {
                        positionRatio = 1 - positionRatio;
                    }
                    const position =
                        swiper.minTranslate() +
                        (swiper.maxTranslate() - swiper.minTranslate()) * positionRatio;
                    swiper.updateProgress(position);
                    swiper.setTranslate(position);
                    swiper.updateActiveIndex();
                    swiper.updateSlidesClasses();
                }
                function onDragStart(e) {
                    const params = swiper.params.scrollbar;
                    const { scrollbar, wrapperEl } = swiper;
                    const { el, dragEl } = scrollbar;
                    isTouched = true;
                    dragStartPos =
                        e.target === dragEl
                            ? getPointerPosition(e) -
                            e.target.getBoundingClientRect()[
                            swiper.isHorizontal() ? "left" : "top"
                            ]
                            : null;
                    e.preventDefault();
                    e.stopPropagation();
                    wrapperEl.style.transitionDuration = "100ms";
                    dragEl.style.transitionDuration = "100ms";
                    setDragPosition(e);
                    clearTimeout(dragTimeout);
                    el.style.transitionDuration = "0ms";
                    if (params.hide) {
                        el.style.opacity = 1;
                    }
                    if (swiper.params.cssMode) {
                        swiper.wrapperEl.style["scroll-snap-type"] = "none";
                    }
                    emit("scrollbarDragStart", e);
                }
                function onDragMove(e) {
                    const { scrollbar, wrapperEl } = swiper;
                    const { el, dragEl } = scrollbar;
                    if (!isTouched) return;
                    if (e.preventDefault) e.preventDefault();
                    else e.returnValue = false;
                    setDragPosition(e);
                    wrapperEl.style.transitionDuration = "0ms";
                    el.style.transitionDuration = "0ms";
                    dragEl.style.transitionDuration = "0ms";
                    emit("scrollbarDragMove", e);
                }
                function onDragEnd(e) {
                    const params = swiper.params.scrollbar;
                    const { scrollbar, wrapperEl } = swiper;
                    const { el } = scrollbar;
                    if (!isTouched) return;
                    isTouched = false;
                    if (swiper.params.cssMode) {
                        swiper.wrapperEl.style["scroll-snap-type"] = "";
                        wrapperEl.style.transitionDuration = "";
                    }
                    if (params.hide) {
                        clearTimeout(dragTimeout);
                        dragTimeout = nextTick(() => {
                            el.style.opacity = 0;
                            el.style.transitionDuration = "400ms";
                        }, 1000);
                    }
                    emit("scrollbarDragEnd", e);
                    if (params.snapOnRelease) {
                        swiper.slideToClosest();
                    }
                }
                function events(method) {
                    const { scrollbar, params } = swiper;
                    const el = scrollbar.el;
                    if (!el) return;
                    const target = el;
                    const activeListener = params.passiveListeners
                        ? {
                            passive: false,
                            capture: false,
                        }
                        : false;
                    const passiveListener = params.passiveListeners
                        ? {
                            passive: true,
                            capture: false,
                        }
                        : false;
                    if (!target) return;
                    const eventMethod =
                        method === "on" ? "addEventListener" : "removeEventListener";
                    target[eventMethod]("pointerdown", onDragStart, activeListener);
                    document[eventMethod]("pointermove", onDragMove, activeListener);
                    document[eventMethod]("pointerup", onDragEnd, passiveListener);
                }
                function enableDraggable() {
                    if (!swiper.params.scrollbar.el || !swiper.scrollbar.el) return;
                    events("on");
                }
                function disableDraggable() {
                    if (!swiper.params.scrollbar.el || !swiper.scrollbar.el) return;
                    events("off");
                }
                function init() {
                    const { scrollbar, el: swiperEl } = swiper;
                    swiper.params.scrollbar = createElementIfNotDefined(
                        swiper,
                        swiper.originalParams.scrollbar,
                        swiper.params.scrollbar,
                        {
                            el: "swiper-scrollbar",
                        }
                    );
                    const params = swiper.params.scrollbar;
                    if (!params.el) return;
                    let el;
                    if (typeof params.el === "string" && swiper.isElement) {
                        el = swiper.el.querySelector(params.el);
                    }
                    if (!el && typeof params.el === "string") {
                        el = document.querySelectorAll(params.el);
                    } else if (!el) {
                        el = params.el;
                    }
                    if (
                        swiper.params.uniqueNavElements &&
                        typeof params.el === "string" &&
                        el.length > 1 &&
                        swiperEl.querySelectorAll(params.el).length === 1
                    ) {
                        el = swiperEl.querySelector(params.el);
                    }
                    if (el.length > 0) el = el[0];
                    el.classList.add(
                        swiper.isHorizontal()
                            ? params.horizontalClass
                            : params.verticalClass
                    );
                    let dragEl;
                    if (el) {
                        dragEl = el.querySelector(
                            `.${swiper.params.scrollbar.dragClass}`
                        );
                        if (!dragEl) {
                            dragEl = createElement(
                                "div",
                                swiper.params.scrollbar.dragClass
                            );
                            el.append(dragEl);
                        }
                    }
                    Object.assign(scrollbar, {
                        el,
                        dragEl,
                    });
                    if (params.draggable) {
                        enableDraggable();
                    }
                    if (el) {
                        el.classList[swiper.enabled ? "remove" : "add"](
                            swiper.params.scrollbar.lockClass
                        );
                    }
                }
                function destroy() {
                    const params = swiper.params.scrollbar;
                    const el = swiper.scrollbar.el;
                    if (el) {
                        el.classList.remove(
                            swiper.isHorizontal()
                                ? params.horizontalClass
                                : params.verticalClass
                        );
                    }
                    disableDraggable();
                }
                on("init", () => {
                    if (swiper.params.scrollbar.enabled === false) {
                        // eslint-disable-next-line
                        disable();
                    } else {
                        init();
                        updateSize();
                        setTranslate();
                    }
                });
                on("update resize observerUpdate lock unlock", () => {
                    updateSize();
                });
                on("setTranslate", () => {
                    setTranslate();
                });
                on("setTransition", (_s, duration) => {
                    setTransition(duration);
                });
                on("enable disable", () => {
                    const { el } = swiper.scrollbar;
                    if (el) {
                        el.classList[swiper.enabled ? "remove" : "add"](
                            swiper.params.scrollbar.lockClass
                        );
                    }
                });
                on("destroy", () => {
                    destroy();
                });
                const enable = () => {
                    swiper.el.classList.remove(
                        swiper.params.scrollbar.scrollbarDisabledClass
                    );
                    if (swiper.scrollbar.el) {
                        swiper.scrollbar.el.classList.remove(
                            swiper.params.scrollbar.scrollbarDisabledClass
                        );
                    }
                    init();
                    updateSize();
                    setTranslate();
                };
                const disable = () => {
                    swiper.el.classList.add(
                        swiper.params.scrollbar.scrollbarDisabledClass
                    );
                    if (swiper.scrollbar.el) {
                        swiper.scrollbar.el.classList.add(
                            swiper.params.scrollbar.scrollbarDisabledClass
                        );
                    }
                    destroy();
                };
                Object.assign(swiper.scrollbar, {
                    enable,
                    disable,
                    updateSize,
                    setTranslate,
                    init,
                    destroy,
                });
            }

            function Parallax(_ref) {
                let { swiper, extendParams, on } = _ref;
                extendParams({
                    parallax: {
                        enabled: false,
                    },
                });
                const setTransform = (el, progress) => {
                    const { rtl } = swiper;
                    const rtlFactor = rtl ? -1 : 1;
                    const p = el.getAttribute("data-swiper-parallax") || "0";
                    let x = el.getAttribute("data-swiper-parallax-x");
                    let y = el.getAttribute("data-swiper-parallax-y");
                    const scale = el.getAttribute("data-swiper-parallax-scale");
                    const opacity = el.getAttribute("data-swiper-parallax-opacity");
                    const rotate = el.getAttribute("data-swiper-parallax-rotate");
                    if (x || y) {
                        x = x || "0";
                        y = y || "0";
                    } else if (swiper.isHorizontal()) {
                        x = p;
                        y = "0";
                    } else {
                        y = p;
                        x = "0";
                    }
                    if (x.indexOf("%") >= 0) {
                        x = `${parseInt(x, 10) * progress * rtlFactor}%`;
                    } else {
                        x = `${x * progress * rtlFactor}px`;
                    }
                    if (y.indexOf("%") >= 0) {
                        y = `${parseInt(y, 10) * progress}%`;
                    } else {
                        y = `${y * progress}px`;
                    }
                    if (typeof opacity !== "undefined" && opacity !== null) {
                        const currentOpacity =
                            opacity - (opacity - 1) * (1 - Math.abs(progress));
                        el.style.opacity = currentOpacity;
                    }
                    let transform = `translate3d(${x}, ${y}, 0px)`;
                    if (typeof scale !== "undefined" && scale !== null) {
                        const currentScale =
                            scale - (scale - 1) * (1 - Math.abs(progress));
                        transform += ` scale(${currentScale})`;
                    }
                    if (rotate && typeof rotate !== "undefined" && rotate !== null) {
                        const currentRotate = rotate * progress * -1;
                        transform += ` rotate(${currentRotate}deg)`;
                    }
                    el.style.transform = transform;
                };
                const setTranslate = () => {
                    const { el, slides, progress, snapGrid } = swiper;
                    elementChildren(
                        el,
                        "[data-swiper-parallax], [data-swiper-parallax-x], [data-swiper-parallax-y], [data-swiper-parallax-opacity], [data-swiper-parallax-scale]"
                    ).forEach((subEl) => {
                        setTransform(subEl, progress);
                    });
                    slides.forEach((slideEl, slideIndex) => {
                        let slideProgress = slideEl.progress;
                        if (
                            swiper.params.slidesPerGroup > 1 &&
                            swiper.params.slidesPerView !== "auto"
                        ) {
                            slideProgress +=
                                Math.ceil(slideIndex / 2) - progress * (snapGrid.length - 1);
                        }
                        slideProgress = Math.min(Math.max(slideProgress, -1), 1);
                        slideEl
                            .querySelectorAll(
                                "[data-swiper-parallax], [data-swiper-parallax-x], [data-swiper-parallax-y], [data-swiper-parallax-opacity], [data-swiper-parallax-scale], [data-swiper-parallax-rotate]"
                            )
                            .forEach((subEl) => {
                                setTransform(subEl, slideProgress);
                            });
                    });
                };
                const setTransition = function (duration) {
                    if (duration === void 0) {
                        duration = swiper.params.speed;
                    }
                    const { el } = swiper;
                    el.querySelectorAll(
                        "[data-swiper-parallax], [data-swiper-parallax-x], [data-swiper-parallax-y], [data-swiper-parallax-opacity], [data-swiper-parallax-scale]"
                    ).forEach((parallaxEl) => {
                        let parallaxDuration =
                            parseInt(
                                parallaxEl.getAttribute("data-swiper-parallax-duration"),
                                10
                            ) || duration;
                        if (duration === 0) parallaxDuration = 0;
                        parallaxEl.style.transitionDuration = `${parallaxDuration}ms`;
                    });
                };
                on("beforeInit", () => {
                    if (!swiper.params.parallax.enabled) return;
                    swiper.params.watchSlidesProgress = true;
                    swiper.originalParams.watchSlidesProgress = true;
                });
                on("init", () => {
                    if (!swiper.params.parallax.enabled) return;
                    setTranslate();
                });
                on("setTranslate", () => {
                    if (!swiper.params.parallax.enabled) return;
                    setTranslate();
                });
                on("setTransition", (_swiper, duration) => {
                    if (!swiper.params.parallax.enabled) return;
                    setTransition(duration);
                });
            }

            function Zoom(_ref) {
                let { swiper, extendParams, on, emit } = _ref;
                const window = getWindow();
                extendParams({
                    zoom: {
                        enabled: false,
                        maxRatio: 3,
                        minRatio: 1,
                        toggle: true,
                        containerClass: "swiper-zoom-container",
                        zoomedSlideClass: "swiper-slide-zoomed",
                    },
                });
                swiper.zoom = {
                    enabled: false,
                };
                let currentScale = 1;
                let isScaling = false;
                let fakeGestureTouched;
                let fakeGestureMoved;
                const evCache = [];
                const gesture = {
                    originX: 0,
                    originY: 0,
                    slideEl: undefined,
                    slideWidth: undefined,
                    slideHeight: undefined,
                    imageEl: undefined,
                    imageWrapEl: undefined,
                    maxRatio: 3,
                };
                const image = {
                    isTouched: undefined,
                    isMoved: undefined,
                    currentX: undefined,
                    currentY: undefined,
                    minX: undefined,
                    minY: undefined,
                    maxX: undefined,
                    maxY: undefined,
                    width: undefined,
                    height: undefined,
                    startX: undefined,
                    startY: undefined,
                    touchesStart: {},
                    touchesCurrent: {},
                };
                const velocity = {
                    x: undefined,
                    y: undefined,
                    prevPositionX: undefined,
                    prevPositionY: undefined,
                    prevTime: undefined,
                };
                let scale = 1;
                Object.defineProperty(swiper.zoom, "scale", {
                    get() {
                        return scale;
                    },
                    set(value) {
                        if (scale !== value) {
                            const imageEl = gesture.imageEl;
                            const slideEl = gesture.slideEl;
                            emit("zoomChange", value, imageEl, slideEl);
                        }
                        scale = value;
                    },
                });
                function getDistanceBetweenTouches() {
                    if (evCache.length < 2) return 1;
                    const x1 = evCache[0].pageX;
                    const y1 = evCache[0].pageY;
                    const x2 = evCache[1].pageX;
                    const y2 = evCache[1].pageY;
                    const distance = Math.sqrt((x2 - x1) ** 2 + (y2 - y1) ** 2);
                    return distance;
                }
                function getScaleOrigin() {
                    if (evCache.length < 2)
                        return {
                            x: null,
                            y: null,
                        };
                    const box = gesture.imageEl.getBoundingClientRect();
                    return [
                        (evCache[0].pageX +
                            (evCache[1].pageX - evCache[0].pageX) / 2 -
                            box.x) /
                        currentScale,
                        (evCache[0].pageY +
                            (evCache[1].pageY - evCache[0].pageY) / 2 -
                            box.y) /
                        currentScale,
                    ];
                }
                function getSlideSelector() {
                    return swiper.isElement
                        ? `swiper-slide`
                        : `.${swiper.params.slideClass}`;
                }
                function eventWithinSlide(e) {
                    const slideSelector = getSlideSelector();
                    if (e.target.matches(slideSelector)) return true;
                    if (
                        swiper.slides.filter((slideEl) => slideEl.contains(e.target))
                            .length > 0
                    )
                        return true;
                    return false;
                }
                function eventWithinZoomContainer(e) {
                    const selector = `.${swiper.params.zoom.containerClass}`;
                    if (e.target.matches(selector)) return true;
                    if (
                        [...swiper.el.querySelectorAll(selector)].filter((containerEl) =>
                            containerEl.contains(e.target)
                        ).length > 0
                    )
                        return true;
                    return false;
                }

                // Events
                function onGestureStart(e) {
                    if (e.pointerType === "mouse") {
                        evCache.splice(0, evCache.length);
                    }
                    if (!eventWithinSlide(e)) return;
                    const params = swiper.params.zoom;
                    fakeGestureTouched = false;
                    fakeGestureMoved = false;
                    evCache.push(e);
                    if (evCache.length < 2) {
                        return;
                    }
                    fakeGestureTouched = true;
                    gesture.scaleStart = getDistanceBetweenTouches();
                    if (!gesture.slideEl) {
                        gesture.slideEl = e.target.closest(
                            `.${swiper.params.slideClass}, swiper-slide`
                        );
                        if (!gesture.slideEl)
                            gesture.slideEl = swiper.slides[swiper.activeIndex];
                        let imageEl = gesture.slideEl.querySelector(
                            `.${params.containerClass}`
                        );
                        if (imageEl) {
                            imageEl = imageEl.querySelectorAll(
                                "picture, img, svg, canvas, .swiper-zoom-target"
                            )[0];
                        }
                        gesture.imageEl = imageEl;
                        if (imageEl) {
                            gesture.imageWrapEl = elementParents(
                                gesture.imageEl,
                                `.${params.containerClass}`
                            )[0];
                        } else {
                            gesture.imageWrapEl = undefined;
                        }
                        if (!gesture.imageWrapEl) {
                            gesture.imageEl = undefined;
                            return;
                        }
                        gesture.maxRatio =
                            gesture.imageWrapEl.getAttribute("data-swiper-zoom") ||
                            params.maxRatio;
                    }
                    if (gesture.imageEl) {
                        const [originX, originY] = getScaleOrigin();
                        gesture.originX = originX;
                        gesture.originY = originY;
                        gesture.imageEl.style.transitionDuration = "0ms";
                    }
                    isScaling = true;
                }
                function onGestureChange(e) {
                    if (!eventWithinSlide(e)) return;
                    const params = swiper.params.zoom;
                    const zoom = swiper.zoom;
                    const pointerIndex = evCache.findIndex(
                        (cachedEv) => cachedEv.pointerId === e.pointerId
                    );
                    if (pointerIndex >= 0) evCache[pointerIndex] = e;
                    if (evCache.length < 2) {
                        return;
                    }
                    fakeGestureMoved = true;
                    gesture.scaleMove = getDistanceBetweenTouches();
                    if (!gesture.imageEl) {
                        return;
                    }
                    zoom.scale =
                        (gesture.scaleMove / gesture.scaleStart) * currentScale;
                    if (zoom.scale > gesture.maxRatio) {
                        zoom.scale =
                            gesture.maxRatio -
                            1 +
                            (zoom.scale - gesture.maxRatio + 1) ** 0.5;
                    }
                    if (zoom.scale < params.minRatio) {
                        zoom.scale =
                            params.minRatio + 1 - (params.minRatio - zoom.scale + 1) ** 0.5;
                    }
                    gesture.imageEl.style.transform = `translate3d(0,0,0) scale(${zoom.scale})`;
                }
                function onGestureEnd(e) {
                    if (!eventWithinSlide(e)) return;
                    if (e.pointerType === "mouse" && e.type === "pointerout") return;
                    const params = swiper.params.zoom;
                    const zoom = swiper.zoom;
                    const pointerIndex = evCache.findIndex(
                        (cachedEv) => cachedEv.pointerId === e.pointerId
                    );
                    if (pointerIndex >= 0) evCache.splice(pointerIndex, 1);
                    if (!fakeGestureTouched || !fakeGestureMoved) {
                        return;
                    }
                    fakeGestureTouched = false;
                    fakeGestureMoved = false;
                    if (!gesture.imageEl) return;
                    zoom.scale = Math.max(
                        Math.min(zoom.scale, gesture.maxRatio),
                        params.minRatio
                    );
                    gesture.imageEl.style.transitionDuration = `${swiper.params.speed}ms`;
                    gesture.imageEl.style.transform = `translate3d(0,0,0) scale(${zoom.scale})`;
                    currentScale = zoom.scale;
                    isScaling = false;
                    if (zoom.scale > 1 && gesture.slideEl) {
                        gesture.slideEl.classList.add(`${params.zoomedSlideClass}`);
                    } else if (zoom.scale <= 1 && gesture.slideEl) {
                        gesture.slideEl.classList.remove(`${params.zoomedSlideClass}`);
                    }
                    if (zoom.scale === 1) {
                        gesture.originX = 0;
                        gesture.originY = 0;
                        gesture.slideEl = undefined;
                    }
                }
                function onTouchStart(e) {
                    const device = swiper.device;
                    if (!gesture.imageEl) return;
                    if (image.isTouched) return;
                    if (device.android && e.cancelable) e.preventDefault();
                    image.isTouched = true;
                    const event = evCache.length > 0 ? evCache[0] : e;
                    image.touchesStart.x = event.pageX;
                    image.touchesStart.y = event.pageY;
                }
                function onTouchMove(e) {
                    if (!eventWithinSlide(e) || !eventWithinZoomContainer(e)) return;
                    const zoom = swiper.zoom;
                    if (!gesture.imageEl) return;
                    if (!image.isTouched || !gesture.slideEl) return;
                    if (!image.isMoved) {
                        image.width = gesture.imageEl.offsetWidth;
                        image.height = gesture.imageEl.offsetHeight;
                        image.startX = getTranslate(gesture.imageWrapEl, "x") || 0;
                        image.startY = getTranslate(gesture.imageWrapEl, "y") || 0;
                        gesture.slideWidth = gesture.slideEl.offsetWidth;
                        gesture.slideHeight = gesture.slideEl.offsetHeight;
                        gesture.imageWrapEl.style.transitionDuration = "0ms";
                    }
                    // Define if we need image drag
                    const scaledWidth = image.width * zoom.scale;
                    const scaledHeight = image.height * zoom.scale;
                    if (
                        scaledWidth < gesture.slideWidth &&
                        scaledHeight < gesture.slideHeight
                    )
                        return;
                    image.minX = Math.min(gesture.slideWidth / 2 - scaledWidth / 2, 0);
                    image.maxX = -image.minX;
                    image.minY = Math.min(
                        gesture.slideHeight / 2 - scaledHeight / 2,
                        0
                    );
                    image.maxY = -image.minY;
                    image.touchesCurrent.x =
                        evCache.length > 0 ? evCache[0].pageX : e.pageX;
                    image.touchesCurrent.y =
                        evCache.length > 0 ? evCache[0].pageY : e.pageY;
                    const touchesDiff = Math.max(
                        Math.abs(image.touchesCurrent.x - image.touchesStart.x),
                        Math.abs(image.touchesCurrent.y - image.touchesStart.y)
                    );
                    if (touchesDiff > 5) {
                        swiper.allowClick = false;
                    }
                    if (!image.isMoved && !isScaling) {
                        if (
                            swiper.isHorizontal() &&
                            ((Math.floor(image.minX) === Math.floor(image.startX) &&
                                image.touchesCurrent.x < image.touchesStart.x) ||
                                (Math.floor(image.maxX) === Math.floor(image.startX) &&
                                    image.touchesCurrent.x > image.touchesStart.x))
                        ) {
                            image.isTouched = false;
                            return;
                        }
                        if (
                            !swiper.isHorizontal() &&
                            ((Math.floor(image.minY) === Math.floor(image.startY) &&
                                image.touchesCurrent.y < image.touchesStart.y) ||
                                (Math.floor(image.maxY) === Math.floor(image.startY) &&
                                    image.touchesCurrent.y > image.touchesStart.y))
                        ) {
                            image.isTouched = false;
                            return;
                        }
                    }
                    if (e.cancelable) {
                        e.preventDefault();
                    }
                    e.stopPropagation();
                    image.isMoved = true;
                    const scaleRatio =
                        (zoom.scale - currentScale) /
                        (gesture.maxRatio - swiper.params.zoom.minRatio);
                    const { originX, originY } = gesture;
                    image.currentX =
                        image.touchesCurrent.x -
                        image.touchesStart.x +
                        image.startX +
                        scaleRatio * (image.width - originX * 2);
                    image.currentY =
                        image.touchesCurrent.y -
                        image.touchesStart.y +
                        image.startY +
                        scaleRatio * (image.height - originY * 2);
                    if (image.currentX < image.minX) {
                        image.currentX =
                            image.minX + 1 - (image.minX - image.currentX + 1) ** 0.8;
                    }
                    if (image.currentX > image.maxX) {
                        image.currentX =
                            image.maxX - 1 + (image.currentX - image.maxX + 1) ** 0.8;
                    }
                    if (image.currentY < image.minY) {
                        image.currentY =
                            image.minY + 1 - (image.minY - image.currentY + 1) ** 0.8;
                    }
                    if (image.currentY > image.maxY) {
                        image.currentY =
                            image.maxY - 1 + (image.currentY - image.maxY + 1) ** 0.8;
                    }

                    // Velocity
                    if (!velocity.prevPositionX)
                        velocity.prevPositionX = image.touchesCurrent.x;
                    if (!velocity.prevPositionY)
                        velocity.prevPositionY = image.touchesCurrent.y;
                    if (!velocity.prevTime) velocity.prevTime = Date.now();
                    velocity.x =
                        (image.touchesCurrent.x - velocity.prevPositionX) /
                        (Date.now() - velocity.prevTime) /
                        2;
                    velocity.y =
                        (image.touchesCurrent.y - velocity.prevPositionY) /
                        (Date.now() - velocity.prevTime) /
                        2;
                    if (Math.abs(image.touchesCurrent.x - velocity.prevPositionX) < 2)
                        velocity.x = 0;
                    if (Math.abs(image.touchesCurrent.y - velocity.prevPositionY) < 2)
                        velocity.y = 0;
                    velocity.prevPositionX = image.touchesCurrent.x;
                    velocity.prevPositionY = image.touchesCurrent.y;
                    velocity.prevTime = Date.now();
                    gesture.imageWrapEl.style.transform = `translate3d(${image.currentX}px, ${image.currentY}px,0)`;
                }
                function onTouchEnd() {
                    const zoom = swiper.zoom;
                    if (!gesture.imageEl) return;
                    if (!image.isTouched || !image.isMoved) {
                        image.isTouched = false;
                        image.isMoved = false;
                        return;
                    }
                    image.isTouched = false;
                    image.isMoved = false;
                    let momentumDurationX = 300;
                    let momentumDurationY = 300;
                    const momentumDistanceX = velocity.x * momentumDurationX;
                    const newPositionX = image.currentX + momentumDistanceX;
                    const momentumDistanceY = velocity.y * momentumDurationY;
                    const newPositionY = image.currentY + momentumDistanceY;

                    // Fix duration
                    if (velocity.x !== 0)
                        momentumDurationX = Math.abs(
                            (newPositionX - image.currentX) / velocity.x
                        );
                    if (velocity.y !== 0)
                        momentumDurationY = Math.abs(
                            (newPositionY - image.currentY) / velocity.y
                        );
                    const momentumDuration = Math.max(
                        momentumDurationX,
                        momentumDurationY
                    );
                    image.currentX = newPositionX;
                    image.currentY = newPositionY;
                    // Define if we need image drag
                    const scaledWidth = image.width * zoom.scale;
                    const scaledHeight = image.height * zoom.scale;
                    image.minX = Math.min(gesture.slideWidth / 2 - scaledWidth / 2, 0);
                    image.maxX = -image.minX;
                    image.minY = Math.min(
                        gesture.slideHeight / 2 - scaledHeight / 2,
                        0
                    );
                    image.maxY = -image.minY;
                    image.currentX = Math.max(
                        Math.min(image.currentX, image.maxX),
                        image.minX
                    );
                    image.currentY = Math.max(
                        Math.min(image.currentY, image.maxY),
                        image.minY
                    );
                    gesture.imageWrapEl.style.transitionDuration = `${momentumDuration}ms`;
                    gesture.imageWrapEl.style.transform = `translate3d(${image.currentX}px, ${image.currentY}px,0)`;
                }
                function onTransitionEnd() {
                    const zoom = swiper.zoom;
                    if (
                        gesture.slideEl &&
                        swiper.activeIndex !== swiper.slides.indexOf(gesture.slideEl)
                    ) {
                        if (gesture.imageEl) {
                            gesture.imageEl.style.transform = "translate3d(0,0,0) scale(1)";
                        }
                        if (gesture.imageWrapEl) {
                            gesture.imageWrapEl.style.transform = "translate3d(0,0,0)";
                        }
                        gesture.slideEl.classList.remove(
                            `${swiper.params.zoom.zoomedSlideClass}`
                        );
                        zoom.scale = 1;
                        currentScale = 1;
                        gesture.slideEl = undefined;
                        gesture.imageEl = undefined;
                        gesture.imageWrapEl = undefined;
                        gesture.originX = 0;
                        gesture.originY = 0;
                    }
                }
                function zoomIn(e) {
                    const zoom = swiper.zoom;
                    const params = swiper.params.zoom;
                    if (!gesture.slideEl) {
                        if (e && e.target) {
                            gesture.slideEl = e.target.closest(
                                `.${swiper.params.slideClass}, swiper-slide`
                            );
                        }
                        if (!gesture.slideEl) {
                            if (
                                swiper.params.virtual &&
                                swiper.params.virtual.enabled &&
                                swiper.virtual
                            ) {
                                gesture.slideEl = elementChildren(
                                    swiper.slidesEl,
                                    `.${swiper.params.slideActiveClass}`
                                )[0];
                            } else {
                                gesture.slideEl = swiper.slides[swiper.activeIndex];
                            }
                        }
                        let imageEl = gesture.slideEl.querySelector(
                            `.${params.containerClass}`
                        );
                        if (imageEl) {
                            imageEl = imageEl.querySelectorAll(
                                "picture, img, svg, canvas, .swiper-zoom-target"
                            )[0];
                        }
                        gesture.imageEl = imageEl;
                        if (imageEl) {
                            gesture.imageWrapEl = elementParents(
                                gesture.imageEl,
                                `.${params.containerClass}`
                            )[0];
                        } else {
                            gesture.imageWrapEl = undefined;
                        }
                    }
                    if (!gesture.imageEl || !gesture.imageWrapEl) return;
                    if (swiper.params.cssMode) {
                        swiper.wrapperEl.style.overflow = "hidden";
                        swiper.wrapperEl.style.touchAction = "none";
                    }
                    gesture.slideEl.classList.add(`${params.zoomedSlideClass}`);
                    let touchX;
                    let touchY;
                    let offsetX;
                    let offsetY;
                    let diffX;
                    let diffY;
                    let translateX;
                    let translateY;
                    let imageWidth;
                    let imageHeight;
                    let scaledWidth;
                    let scaledHeight;
                    let translateMinX;
                    let translateMinY;
                    let translateMaxX;
                    let translateMaxY;
                    let slideWidth;
                    let slideHeight;
                    if (typeof image.touchesStart.x === "undefined" && e) {
                        touchX = e.pageX;
                        touchY = e.pageY;
                    } else {
                        touchX = image.touchesStart.x;
                        touchY = image.touchesStart.y;
                    }
                    const forceZoomRatio = typeof e === "number" ? e : null;
                    if (currentScale === 1 && forceZoomRatio) {
                        touchX = undefined;
                        touchY = undefined;
                    }
                    zoom.scale =
                        forceZoomRatio ||
                        gesture.imageWrapEl.getAttribute("data-swiper-zoom") ||
                        params.maxRatio;
                    currentScale =
                        forceZoomRatio ||
                        gesture.imageWrapEl.getAttribute("data-swiper-zoom") ||
                        params.maxRatio;
                    if (e && !(currentScale === 1 && forceZoomRatio)) {
                        slideWidth = gesture.slideEl.offsetWidth;
                        slideHeight = gesture.slideEl.offsetHeight;
                        offsetX = elementOffset(gesture.slideEl).left + window.scrollX;
                        offsetY = elementOffset(gesture.slideEl).top + window.scrollY;
                        diffX = offsetX + slideWidth / 2 - touchX;
                        diffY = offsetY + slideHeight / 2 - touchY;
                        imageWidth = gesture.imageEl.offsetWidth;
                        imageHeight = gesture.imageEl.offsetHeight;
                        scaledWidth = imageWidth * zoom.scale;
                        scaledHeight = imageHeight * zoom.scale;
                        translateMinX = Math.min(slideWidth / 2 - scaledWidth / 2, 0);
                        translateMinY = Math.min(slideHeight / 2 - scaledHeight / 2, 0);
                        translateMaxX = -translateMinX;
                        translateMaxY = -translateMinY;
                        translateX = diffX * zoom.scale;
                        translateY = diffY * zoom.scale;
                        if (translateX < translateMinX) {
                            translateX = translateMinX;
                        }
                        if (translateX > translateMaxX) {
                            translateX = translateMaxX;
                        }
                        if (translateY < translateMinY) {
                            translateY = translateMinY;
                        }
                        if (translateY > translateMaxY) {
                            translateY = translateMaxY;
                        }
                    } else {
                        translateX = 0;
                        translateY = 0;
                    }
                    if (forceZoomRatio && zoom.scale === 1) {
                        gesture.originX = 0;
                        gesture.originY = 0;
                    }
                    gesture.imageWrapEl.style.transitionDuration = "300ms";
                    gesture.imageWrapEl.style.transform = `translate3d(${translateX}px, ${translateY}px,0)`;
                    gesture.imageEl.style.transitionDuration = "300ms";
                    gesture.imageEl.style.transform = `translate3d(0,0,0) scale(${zoom.scale})`;
                }
                function zoomOut() {
                    const zoom = swiper.zoom;
                    const params = swiper.params.zoom;
                    if (!gesture.slideEl) {
                        if (
                            swiper.params.virtual &&
                            swiper.params.virtual.enabled &&
                            swiper.virtual
                        ) {
                            gesture.slideEl = elementChildren(
                                swiper.slidesEl,
                                `.${swiper.params.slideActiveClass}`
                            )[0];
                        } else {
                            gesture.slideEl = swiper.slides[swiper.activeIndex];
                        }
                        let imageEl = gesture.slideEl.querySelector(
                            `.${params.containerClass}`
                        );
                        if (imageEl) {
                            imageEl = imageEl.querySelectorAll(
                                "picture, img, svg, canvas, .swiper-zoom-target"
                            )[0];
                        }
                        gesture.imageEl = imageEl;
                        if (imageEl) {
                            gesture.imageWrapEl = elementParents(
                                gesture.imageEl,
                                `.${params.containerClass}`
                            )[0];
                        } else {
                            gesture.imageWrapEl = undefined;
                        }
                    }
                    if (!gesture.imageEl || !gesture.imageWrapEl) return;
                    if (swiper.params.cssMode) {
                        swiper.wrapperEl.style.overflow = "";
                        swiper.wrapperEl.style.touchAction = "";
                    }
                    zoom.scale = 1;
                    currentScale = 1;
                    gesture.imageWrapEl.style.transitionDuration = "300ms";
                    gesture.imageWrapEl.style.transform = "translate3d(0,0,0)";
                    gesture.imageEl.style.transitionDuration = "300ms";
                    gesture.imageEl.style.transform = "translate3d(0,0,0) scale(1)";
                    gesture.slideEl.classList.remove(`${params.zoomedSlideClass}`);
                    gesture.slideEl = undefined;
                    gesture.originX = 0;
                    gesture.originY = 0;
                }

                // Toggle Zoom
                function zoomToggle(e) {
                    const zoom = swiper.zoom;
                    if (zoom.scale && zoom.scale !== 1) {
                        // Zoom Out
                        zoomOut();
                    } else {
                        // Zoom In
                        zoomIn(e);
                    }
                }
                function getListeners() {
                    const passiveListener = swiper.params.passiveListeners
                        ? {
                            passive: true,
                            capture: false,
                        }
                        : false;
                    const activeListenerWithCapture = swiper.params.passiveListeners
                        ? {
                            passive: false,
                            capture: true,
                        }
                        : true;
                    return {
                        passiveListener,
                        activeListenerWithCapture,
                    };
                }

                // Attach/Detach Events
                function enable() {
                    const zoom = swiper.zoom;
                    if (zoom.enabled) return;
                    zoom.enabled = true;
                    const { passiveListener, activeListenerWithCapture } =
                        getListeners();

                    // Scale image
                    swiper.wrapperEl.addEventListener(
                        "pointerdown",
                        onGestureStart,
                        passiveListener
                    );
                    swiper.wrapperEl.addEventListener(
                        "pointermove",
                        onGestureChange,
                        activeListenerWithCapture
                    );
                    ["pointerup", "pointercancel", "pointerout"].forEach(
                        (eventName) => {
                            swiper.wrapperEl.addEventListener(
                                eventName,
                                onGestureEnd,
                                passiveListener
                            );
                        }
                    );

                    // Move image
                    swiper.wrapperEl.addEventListener(
                        "pointermove",
                        onTouchMove,
                        activeListenerWithCapture
                    );
                }
                function disable() {
                    const zoom = swiper.zoom;
                    if (!zoom.enabled) return;
                    zoom.enabled = false;
                    const { passiveListener, activeListenerWithCapture } =
                        getListeners();

                    // Scale image
                    swiper.wrapperEl.removeEventListener(
                        "pointerdown",
                        onGestureStart,
                        passiveListener
                    );
                    swiper.wrapperEl.removeEventListener(
                        "pointermove",
                        onGestureChange,
                        activeListenerWithCapture
                    );
                    ["pointerup", "pointercancel", "pointerout"].forEach(
                        (eventName) => {
                            swiper.wrapperEl.removeEventListener(
                                eventName,
                                onGestureEnd,
                                passiveListener
                            );
                        }
                    );

                    // Move image
                    swiper.wrapperEl.removeEventListener(
                        "pointermove",
                        onTouchMove,
                        activeListenerWithCapture
                    );
                }
                on("init", () => {
                    if (swiper.params.zoom.enabled) {
                        enable();
                    }
                });
                on("destroy", () => {
                    disable();
                });
                on("touchStart", (_s, e) => {
                    if (!swiper.zoom.enabled) return;
                    onTouchStart(e);
                });
                on("touchEnd", (_s, e) => {
                    if (!swiper.zoom.enabled) return;
                    onTouchEnd();
                });
                on("doubleTap", (_s, e) => {
                    if (
                        !swiper.animating &&
                        swiper.params.zoom.enabled &&
                        swiper.zoom.enabled &&
                        swiper.params.zoom.toggle
                    ) {
                        zoomToggle(e);
                    }
                });
                on("transitionEnd", () => {
                    if (swiper.zoom.enabled && swiper.params.zoom.enabled) {
                        onTransitionEnd();
                    }
                });
                on("slideChange", () => {
                    if (
                        swiper.zoom.enabled &&
                        swiper.params.zoom.enabled &&
                        swiper.params.cssMode
                    ) {
                        onTransitionEnd();
                    }
                });
                Object.assign(swiper.zoom, {
                    enable,
                    disable,
                    in: zoomIn,
                    out: zoomOut,
                    toggle: zoomToggle,
                });
            }

            /* eslint no-bitwise: ["error", { "allow": [">>"] }] */
            function Controller(_ref) {
                let { swiper, extendParams, on } = _ref;
                extendParams({
                    controller: {
                        control: undefined,
                        inverse: false,
                        by: "slide", // or 'container'
                    },
                });

                swiper.controller = {
                    control: undefined,
                };
                function LinearSpline(x, y) {
                    const binarySearch = (function search() {
                        let maxIndex;
                        let minIndex;
                        let guess;
                        return (array, val) => {
                            minIndex = -1;
                            maxIndex = array.length;
                            while (maxIndex - minIndex > 1) {
                                guess = (maxIndex + minIndex) >> 1;
                                if (array[guess] <= val) {
                                    minIndex = guess;
                                } else {
                                    maxIndex = guess;
                                }
                            }
                            return maxIndex;
                        };
                    })();
                    this.x = x;
                    this.y = y;
                    this.lastIndex = x.length - 1;
                    // Given an x value (x2), return the expected y2 value:
                    // (x1,y1) is the known point before given value,
                    // (x3,y3) is the known point after given value.
                    let i1;
                    let i3;
                    this.interpolate = function interpolate(x2) {
                        if (!x2) return 0;

                        // Get the indexes of x1 and x3 (the array indexes before and after given x2):
                        i3 = binarySearch(this.x, x2);
                        i1 = i3 - 1;

                        // We have our indexes i1 & i3, so we can calculate already:
                        // y2 := ((x2−x1) × (y3−y1)) ÷ (x3−x1) + y1
                        return (
                            ((x2 - this.x[i1]) * (this.y[i3] - this.y[i1])) /
                            (this.x[i3] - this.x[i1]) +
                            this.y[i1]
                        );
                    };
                    return this;
                }
                function getInterpolateFunction(c) {
                    swiper.controller.spline = swiper.params.loop
                        ? new LinearSpline(swiper.slidesGrid, c.slidesGrid)
                        : new LinearSpline(swiper.snapGrid, c.snapGrid);
                }
                function setTranslate(_t, byController) {
                    const controlled = swiper.controller.control;
                    let multiplier;
                    let controlledTranslate;
                    const Swiper = swiper.constructor;
                    function setControlledTranslate(c) {
                        if (c.destroyed) return;

                        // this will create an Interpolate function based on the snapGrids
                        // x is the Grid of the scrolled scroller and y will be the controlled scroller
                        // it makes sense to create this only once and recall it for the interpolation
                        // the function does a lot of value caching for performance
                        const translate = swiper.rtlTranslate
                            ? -swiper.translate
                            : swiper.translate;
                        if (swiper.params.controller.by === "slide") {
                            getInterpolateFunction(c);
                            // i am not sure why the values have to be multiplicated this way, tried to invert the snapGrid
                            // but it did not work out
                            controlledTranslate = -swiper.controller.spline.interpolate(
                                -translate
                            );
                        }
                        if (
                            !controlledTranslate ||
                            swiper.params.controller.by === "container"
                        ) {
                            multiplier =
                                (c.maxTranslate() - c.minTranslate()) /
                                (swiper.maxTranslate() - swiper.minTranslate());
                            if (Number.isNaN(multiplier) || !Number.isFinite(multiplier)) {
                                multiplier = 1;
                            }
                            controlledTranslate =
                                (translate - swiper.minTranslate()) * multiplier +
                                c.minTranslate();
                        }
                        if (swiper.params.controller.inverse) {
                            controlledTranslate = c.maxTranslate() - controlledTranslate;
                        }
                        c.updateProgress(controlledTranslate);
                        c.setTranslate(controlledTranslate, swiper);
                        c.updateActiveIndex();
                        c.updateSlidesClasses();
                    }
                    if (Array.isArray(controlled)) {
                        for (let i = 0; i < controlled.length; i += 1) {
                            if (
                                controlled[i] !== byController &&
                                controlled[i] instanceof Swiper
                            ) {
                                setControlledTranslate(controlled[i]);
                            }
                        }
                    } else if (
                        controlled instanceof Swiper &&
                        byController !== controlled
                    ) {
                        setControlledTranslate(controlled);
                    }
                }
                function setTransition(duration, byController) {
                    const Swiper = swiper.constructor;
                    const controlled = swiper.controller.control;
                    let i;
                    function setControlledTransition(c) {
                        if (c.destroyed) return;
                        c.setTransition(duration, swiper);
                        if (duration !== 0) {
                            c.transitionStart();
                            if (c.params.autoHeight) {
                                nextTick(() => {
                                    c.updateAutoHeight();
                                });
                            }
                            elementTransitionEnd(c.wrapperEl, () => {
                                if (!controlled) return;
                                c.transitionEnd();
                            });
                        }
                    }
                    if (Array.isArray(controlled)) {
                        for (i = 0; i < controlled.length; i += 1) {
                            if (
                                controlled[i] !== byController &&
                                controlled[i] instanceof Swiper
                            ) {
                                setControlledTransition(controlled[i]);
                            }
                        }
                    } else if (
                        controlled instanceof Swiper &&
                        byController !== controlled
                    ) {
                        setControlledTransition(controlled);
                    }
                }
                function removeSpline() {
                    if (!swiper.controller.control) return;
                    if (swiper.controller.spline) {
                        swiper.controller.spline = undefined;
                        delete swiper.controller.spline;
                    }
                }
                on("beforeInit", () => {
                    if (
                        typeof window !== "undefined" &&
                        // eslint-disable-line
                        (typeof swiper.params.controller.control === "string" ||
                            swiper.params.controller.control instanceof HTMLElement)
                    ) {
                        const controlElement = document.querySelector(
                            swiper.params.controller.control
                        );
                        if (controlElement && controlElement.swiper) {
                            swiper.controller.control = controlElement.swiper;
                        } else if (controlElement) {
                            const onControllerSwiper = (e) => {
                                swiper.controller.control = e.detail[0];
                                swiper.update();
                                controlElement.removeEventListener(
                                    "init",
                                    onControllerSwiper
                                );
                            };
                            controlElement.addEventListener("init", onControllerSwiper);
                        }
                        return;
                    }
                    swiper.controller.control = swiper.params.controller.control;
                });
                on("update", () => {
                    removeSpline();
                });
                on("resize", () => {
                    removeSpline();
                });
                on("observerUpdate", () => {
                    removeSpline();
                });
                on("setTranslate", (_s, translate, byController) => {
                    if (
                        !swiper.controller.control ||
                        swiper.controller.control.destroyed
                    )
                        return;
                    swiper.controller.setTranslate(translate, byController);
                });
                on("setTransition", (_s, duration, byController) => {
                    if (
                        !swiper.controller.control ||
                        swiper.controller.control.destroyed
                    )
                        return;
                    swiper.controller.setTransition(duration, byController);
                });
                Object.assign(swiper.controller, {
                    setTranslate,
                    setTransition,
                });
            }

            function A11y(_ref) {
                let { swiper, extendParams, on } = _ref;
                extendParams({
                    a11y: {
                        enabled: true,
                        notificationClass: "swiper-notification",
                        prevSlideMessage: "Previous slide",
                        nextSlideMessage: "Next slide",
                        firstSlideMessage: "This is the first slide",
                        lastSlideMessage: "This is the last slide",
                        paginationBulletMessage: "Go to slide {{index}}",
                        slideLabelMessage: "{{index}} / {{slidesLength}}",
                        containerMessage: null,
                        containerRoleDescriptionMessage: null,
                        itemRoleDescriptionMessage: null,
                        slideRole: "group",
                        id: null,
                    },
                });
                swiper.a11y = {
                    clicked: false,
                };
                let liveRegion = null;
                function notify(message) {
                    const notification = liveRegion;
                    if (notification.length === 0) return;
                    notification.innerHTML = "";
                    notification.innerHTML = message;
                }
                const makeElementsArray = (el) => {
                    if (!Array.isArray(el)) el = [el].filter((e) => !!e);
                    return el;
                };
                function getRandomNumber(size) {
                    if (size === void 0) {
                        size = 16;
                    }
                    const randomChar = () =>
                        Math.round(16 * Math.random()).toString(16);
                    return "x".repeat(size).replace(/x/g, randomChar);
                }
                function makeElFocusable(el) {
                    el = makeElementsArray(el);
                    el.forEach((subEl) => {
                        subEl.setAttribute("tabIndex", "0");
                    });
                }
                function makeElNotFocusable(el) {
                    el = makeElementsArray(el);
                    el.forEach((subEl) => {
                        subEl.setAttribute("tabIndex", "-1");
                    });
                }
                function addElRole(el, role) {
                    el = makeElementsArray(el);
                    el.forEach((subEl) => {
                        subEl.setAttribute("role", role);
                    });
                }
                function addElRoleDescription(el, description) {
                    el = makeElementsArray(el);
                    el.forEach((subEl) => {
                        subEl.setAttribute("aria-roledescription", description);
                    });
                }
                function addElControls(el, controls) {
                    el = makeElementsArray(el);
                    el.forEach((subEl) => {
                        subEl.setAttribute("aria-controls", controls);
                    });
                }
                function addElLabel(el, label) {
                    el = makeElementsArray(el);
                    el.forEach((subEl) => {
                        subEl.setAttribute("aria-label", label);
                    });
                }
                function addElId(el, id) {
                    el = makeElementsArray(el);
                    el.forEach((subEl) => {
                        subEl.setAttribute("id", id);
                    });
                }
                function addElLive(el, live) {
                    el = makeElementsArray(el);
                    el.forEach((subEl) => {
                        subEl.setAttribute("aria-live", live);
                    });
                }
                function disableEl(el) {
                    el = makeElementsArray(el);
                    el.forEach((subEl) => {
                        subEl.setAttribute("aria-disabled", true);
                    });
                }
                function enableEl(el) {
                    el = makeElementsArray(el);
                    el.forEach((subEl) => {
                        subEl.setAttribute("aria-disabled", false);
                    });
                }
                function onEnterOrSpaceKey(e) {
                    if (e.keyCode !== 13 && e.keyCode !== 32) return;
                    const params = swiper.params.a11y;
                    const targetEl = e.target;
                    if (
                        swiper.pagination &&
                        swiper.pagination.el &&
                        (targetEl === swiper.pagination.el ||
                            swiper.pagination.el.contains(e.target))
                    ) {
                        if (
                            !e.target.matches(
                                classesToSelector(swiper.params.pagination.bulletClass)
                            )
                        )
                            return;
                    }
                    if (
                        swiper.navigation &&
                        swiper.navigation.nextEl &&
                        targetEl === swiper.navigation.nextEl
                    ) {
                        if (!(swiper.isEnd && !swiper.params.loop)) {
                            swiper.slideNext();
                        }
                        if (swiper.isEnd) {
                            notify(params.lastSlideMessage);
                        } else {
                            notify(params.nextSlideMessage);
                        }
                    }
                    if (
                        swiper.navigation &&
                        swiper.navigation.prevEl &&
                        targetEl === swiper.navigation.prevEl
                    ) {
                        if (!(swiper.isBeginning && !swiper.params.loop)) {
                            swiper.slidePrev();
                        }
                        if (swiper.isBeginning) {
                            notify(params.firstSlideMessage);
                        } else {
                            notify(params.prevSlideMessage);
                        }
                    }
                    if (
                        swiper.pagination &&
                        targetEl.matches(
                            classesToSelector(swiper.params.pagination.bulletClass)
                        )
                    ) {
                        targetEl.click();
                    }
                }
                function updateNavigation() {
                    if (
                        swiper.params.loop ||
                        swiper.params.rewind ||
                        !swiper.navigation
                    )
                        return;
                    const { nextEl, prevEl } = swiper.navigation;
                    if (prevEl) {
                        if (swiper.isBeginning) {
                            disableEl(prevEl);
                            makeElNotFocusable(prevEl);
                        } else {
                            enableEl(prevEl);
                            makeElFocusable(prevEl);
                        }
                    }
                    if (nextEl) {
                        if (swiper.isEnd) {
                            disableEl(nextEl);
                            makeElNotFocusable(nextEl);
                        } else {
                            enableEl(nextEl);
                            makeElFocusable(nextEl);
                        }
                    }
                }
                function hasPagination() {
                    return (
                        swiper.pagination &&
                        swiper.pagination.bullets &&
                        swiper.pagination.bullets.length
                    );
                }
                function hasClickablePagination() {
                    return hasPagination() && swiper.params.pagination.clickable;
                }
                function updatePagination() {
                    const params = swiper.params.a11y;
                    if (!hasPagination()) return;
                    swiper.pagination.bullets.forEach((bulletEl) => {
                        if (swiper.params.pagination.clickable) {
                            makeElFocusable(bulletEl);
                            if (!swiper.params.pagination.renderBullet) {
                                addElRole(bulletEl, "button");
                                addElLabel(
                                    bulletEl,
                                    params.paginationBulletMessage.replace(
                                        /\{\{index\}\}/,
                                        elementIndex(bulletEl) + 1
                                    )
                                );
                            }
                        }
                        if (
                            bulletEl.matches(
                                classesToSelector(swiper.params.pagination.bulletActiveClass)
                            )
                        ) {
                            bulletEl.setAttribute("aria-current", "true");
                        } else {
                            bulletEl.removeAttribute("aria-current");
                        }
                    });
                }
                const initNavEl = (el, wrapperId, message) => {
                    makeElFocusable(el);
                    if (el.tagName !== "BUTTON") {
                        addElRole(el, "button");
                        el.addEventListener("keydown", onEnterOrSpaceKey);
                    }
                    addElLabel(el, message);
                    addElControls(el, wrapperId);
                };
                const handlePointerDown = () => {
                    swiper.a11y.clicked = true;
                };
                const handlePointerUp = () => {
                    requestAnimationFrame(() => {
                        requestAnimationFrame(() => {
                            if (!swiper.destroyed) {
                                swiper.a11y.clicked = false;
                            }
                        });
                    });
                };
                const handleFocus = (e) => {
                    if (swiper.a11y.clicked) return;
                    const slideEl = e.target.closest(
                        `.${swiper.params.slideClass}, swiper-slide`
                    );
                    if (!slideEl || !swiper.slides.includes(slideEl)) return;
                    const isActive =
                        swiper.slides.indexOf(slideEl) === swiper.activeIndex;
                    const isVisible =
                        swiper.params.watchSlidesProgress &&
                        swiper.visibleSlides &&
                        swiper.visibleSlides.includes(slideEl);
                    if (isActive || isVisible) return;
                    if (e.sourceCapabilities && e.sourceCapabilities.firesTouchEvents)
                        return;
                    if (swiper.isHorizontal()) {
                        swiper.el.scrollLeft = 0;
                    } else {
                        swiper.el.scrollTop = 0;
                    }
                    swiper.slideTo(swiper.slides.indexOf(slideEl), 0);
                };
                const initSlides = () => {
                    const params = swiper.params.a11y;
                    if (params.itemRoleDescriptionMessage) {
                        addElRoleDescription(
                            swiper.slides,
                            params.itemRoleDescriptionMessage
                        );
                    }
                    if (params.slideRole) {
                        addElRole(swiper.slides, params.slideRole);
                    }
                    const slidesLength = swiper.slides.length;
                    if (params.slideLabelMessage) {
                        swiper.slides.forEach((slideEl, index) => {
                            const slideIndex = swiper.params.loop
                                ? parseInt(
                                    slideEl.getAttribute("data-swiper-slide-index"),
                                    10
                                )
                                : index;
                            const ariaLabelMessage = params.slideLabelMessage
                                .replace(/\{\{index\}\}/, slideIndex + 1)
                                .replace(/\{\{slidesLength\}\}/, slidesLength);
                            addElLabel(slideEl, ariaLabelMessage);
                        });
                    }
                };
                const init = () => {
                    const params = swiper.params.a11y;
                    swiper.el.append(liveRegion);

                    // Container
                    const containerEl = swiper.el;
                    if (params.containerRoleDescriptionMessage) {
                        addElRoleDescription(
                            containerEl,
                            params.containerRoleDescriptionMessage
                        );
                    }
                    if (params.containerMessage) {
                        addElLabel(containerEl, params.containerMessage);
                    }

                    // Wrapper
                    const wrapperEl = swiper.wrapperEl;
                    const wrapperId =
                        params.id ||
                        wrapperEl.getAttribute("id") ||
                        `swiper-wrapper-${getRandomNumber(16)}`;
                    const live =
                        swiper.params.autoplay && swiper.params.autoplay.enabled
                            ? "off"
                            : "polite";
                    addElId(wrapperEl, wrapperId);
                    addElLive(wrapperEl, live);

                    // Slide
                    initSlides();

                    // Navigation
                    let { nextEl, prevEl } = swiper.navigation ? swiper.navigation : {};
                    nextEl = makeElementsArray(nextEl);
                    prevEl = makeElementsArray(prevEl);
                    if (nextEl) {
                        nextEl.forEach((el) =>
                            initNavEl(el, wrapperId, params.nextSlideMessage)
                        );
                    }
                    if (prevEl) {
                        prevEl.forEach((el) =>
                            initNavEl(el, wrapperId, params.prevSlideMessage)
                        );
                    }

                    // Pagination
                    if (hasClickablePagination()) {
                        const paginationEl = Array.isArray(swiper.pagination.el)
                            ? swiper.pagination.el
                            : [swiper.pagination.el];
                        paginationEl.forEach((el) => {
                            el.addEventListener("keydown", onEnterOrSpaceKey);
                        });
                    }

                    // Tab focus
                    swiper.el.addEventListener("focus", handleFocus, true);
                    swiper.el.addEventListener("pointerdown", handlePointerDown, true);
                    swiper.el.addEventListener("pointerup", handlePointerUp, true);
                };
                function destroy() {
                    if (liveRegion) liveRegion.remove();
                    let { nextEl, prevEl } = swiper.navigation ? swiper.navigation : {};
                    nextEl = makeElementsArray(nextEl);
                    prevEl = makeElementsArray(prevEl);
                    if (nextEl) {
                        nextEl.forEach((el) =>
                            el.removeEventListener("keydown", onEnterOrSpaceKey)
                        );
                    }
                    if (prevEl) {
                        prevEl.forEach((el) =>
                            el.removeEventListener("keydown", onEnterOrSpaceKey)
                        );
                    }

                    // Pagination
                    if (hasClickablePagination()) {
                        const paginationEl = Array.isArray(swiper.pagination.el)
                            ? swiper.pagination.el
                            : [swiper.pagination.el];
                        paginationEl.forEach((el) => {
                            el.removeEventListener("keydown", onEnterOrSpaceKey);
                        });
                    }

                    // Tab focus
                    swiper.el.removeEventListener("focus", handleFocus, true);
                    swiper.el.removeEventListener(
                        "pointerdown",
                        handlePointerDown,
                        true
                    );
                    swiper.el.removeEventListener("pointerup", handlePointerUp, true);
                }
                on("beforeInit", () => {
                    liveRegion = createElement(
                        "span",
                        swiper.params.a11y.notificationClass
                    );
                    liveRegion.setAttribute("aria-live", "assertive");
                    liveRegion.setAttribute("aria-atomic", "true");
                });
                on("afterInit", () => {
                    if (!swiper.params.a11y.enabled) return;
                    init();
                });
                on(
                    "slidesLengthChange snapGridLengthChange slidesGridLengthChange",
                    () => {
                        if (!swiper.params.a11y.enabled) return;
                        initSlides();
                    }
                );
                on("fromEdge toEdge afterInit lock unlock", () => {
                    if (!swiper.params.a11y.enabled) return;
                    updateNavigation();
                });
                on("paginationUpdate", () => {
                    if (!swiper.params.a11y.enabled) return;
                    updatePagination();
                });
                on("destroy", () => {
                    if (!swiper.params.a11y.enabled) return;
                    destroy();
                });
            }

            function History(_ref) {
                let { swiper, extendParams, on } = _ref;
                extendParams({
                    history: {
                        enabled: false,
                        root: "",
                        replaceState: false,
                        key: "slides",
                        keepQuery: false,
                    },
                });
                let initialized = false;
                let paths = {};
                const slugify = (text) => {
                    return text
                        .toString()
                        .replace(/\s+/g, "-")
                        .replace(/[^\w-]+/g, "")
                        .replace(/--+/g, "-")
                        .replace(/^-+/, "")
                        .replace(/-+$/, "");
                };
                const getPathValues = (urlOverride) => {
                    const window = getWindow();
                    let location;
                    if (urlOverride) {
                        location = new URL(urlOverride);
                    } else {
                        location = window.location;
                    }
                    const pathArray = location.pathname
                        .slice(1)
                        .split("/")
                        .filter((part) => part !== "");
                    const total = pathArray.length;
                    const key = pathArray[total - 2];
                    const value = pathArray[total - 1];
                    return {
                        key,
                        value,
                    };
                };
                const setHistory = (key, index) => {
                    const window = getWindow();
                    if (!initialized || !swiper.params.history.enabled) return;
                    let location;
                    if (swiper.params.url) {
                        location = new URL(swiper.params.url);
                    } else {
                        location = window.location;
                    }
                    const slide = swiper.slides[index];
                    let value = slugify(slide.getAttribute("data-history"));
                    if (swiper.params.history.root.length > 0) {
                        let root = swiper.params.history.root;
                        if (root[root.length - 1] === "/")
                            root = root.slice(0, root.length - 1);
                        value = `${root}/${key ? `${key}/` : ""}${value}`;
                    } else if (!location.pathname.includes(key)) {
                        value = `${key ? `${key}/` : ""}${value}`;
                    }
                    if (swiper.params.history.keepQuery) {
                        value += location.search;
                    }
                    const currentState = window.history.state;
                    if (currentState && currentState.value === value) {
                        return;
                    }
                    if (swiper.params.history.replaceState) {
                        window.history.replaceState(
                            {
                                value,
                            },
                            null,
                            value
                        );
                    } else {
                        window.history.pushState(
                            {
                                value,
                            },
                            null,
                            value
                        );
                    }
                };
                const scrollToSlide = (speed, value, runCallbacks) => {
                    if (value) {
                        for (
                            let i = 0, length = swiper.slides.length;
                            i < length;
                            i += 1
                        ) {
                            const slide = swiper.slides[i];
                            const slideHistory = slugify(
                                slide.getAttribute("data-history")
                            );
                            if (slideHistory === value) {
                                const index = swiper.getSlideIndex(slide);
                                swiper.slideTo(index, speed, runCallbacks);
                            }
                        }
                    } else {
                        swiper.slideTo(0, speed, runCallbacks);
                    }
                };
                const setHistoryPopState = () => {
                    paths = getPathValues(swiper.params.url);
                    scrollToSlide(swiper.params.speed, paths.value, false);
                };
                const init = () => {
                    const window = getWindow();
                    if (!swiper.params.history) return;
                    if (!window.history || !window.history.pushState) {
                        swiper.params.history.enabled = false;
                        swiper.params.hashNavigation.enabled = true;
                        return;
                    }
                    initialized = true;
                    paths = getPathValues(swiper.params.url);
                    if (!paths.key && !paths.value) {
                        if (!swiper.params.history.replaceState) {
                            window.addEventListener("popstate", setHistoryPopState);
                        }
                        return;
                    }
                    scrollToSlide(0, paths.value, swiper.params.runCallbacksOnInit);
                    if (!swiper.params.history.replaceState) {
                        window.addEventListener("popstate", setHistoryPopState);
                    }
                };
                const destroy = () => {
                    const window = getWindow();
                    if (!swiper.params.history.replaceState) {
                        window.removeEventListener("popstate", setHistoryPopState);
                    }
                };
                on("init", () => {
                    if (swiper.params.history.enabled) {
                        init();
                    }
                });
                on("destroy", () => {
                    if (swiper.params.history.enabled) {
                        destroy();
                    }
                });
                on("transitionEnd _freeModeNoMomentumRelease", () => {
                    if (initialized) {
                        setHistory(swiper.params.history.key, swiper.activeIndex);
                    }
                });
                on("slideChange", () => {
                    if (initialized && swiper.params.cssMode) {
                        setHistory(swiper.params.history.key, swiper.activeIndex);
                    }
                });
            }

            function HashNavigation(_ref) {
                let { swiper, extendParams, emit, on } = _ref;
                let initialized = false;
                const document = getDocument();
                const window = getWindow();
                extendParams({
                    hashNavigation: {
                        enabled: false,
                        replaceState: false,
                        watchState: false,
                        getSlideIndex(_s, hash) {
                            if (swiper.virtual && swiper.params.virtual.enabled) {
                                const slideWithHash = swiper.slides.filter(
                                    (slideEl) => slideEl.getAttribute("data-hash") === hash
                                )[0];
                                if (!slideWithHash) return 0;
                                const index = parseInt(
                                    slideWithHash.getAttribute("data-swiper-slide-index"),
                                    10
                                );
                                return index;
                            }
                            return swiper.getSlideIndex(
                                elementChildren(
                                    swiper.slidesEl,
                                    `.${swiper.params.slideClass}[data-hash="${hash}"], swiper-slide[data-hash="${hash}"]`
                                )[0]
                            );
                        },
                    },
                });
                const onHashChange = () => {
                    emit("hashChange");
                    const newHash = document.location.hash.replace("#", "");
                    const activeSlideEl =
                        swiper.virtual && swiper.params.virtual.enabled
                            ? swiper.slidesEl.querySelector(
                                `[data-swiper-slide-index="${swiper.activeIndex}"]`
                            )
                            : swiper.slides[swiper.activeIndex];
                    const activeSlideHash = activeSlideEl
                        ? activeSlideEl.getAttribute("data-hash")
                        : "";
                    if (newHash !== activeSlideHash) {
                        const newIndex = swiper.params.hashNavigation.getSlideIndex(
                            swiper,
                            newHash
                        );
                        if (typeof newIndex === "undefined" || Number.isNaN(newIndex))
                            return;
                        swiper.slideTo(newIndex);
                    }
                };
                const setHash = () => {
                    if (!initialized || !swiper.params.hashNavigation.enabled) return;
                    const activeSlideEl =
                        swiper.virtual && swiper.params.virtual.enabled
                            ? swiper.slidesEl.querySelector(
                                `[data-swiper-slide-index="${swiper.activeIndex}"]`
                            )
                            : swiper.slides[swiper.activeIndex];
                    const activeSlideHash = activeSlideEl
                        ? activeSlideEl.getAttribute("data-hash") ||
                        activeSlideEl.getAttribute("data-history")
                        : "";
                    if (
                        swiper.params.hashNavigation.replaceState &&
                        window.history &&
                        window.history.replaceState
                    ) {
                        window.history.replaceState(
                            null,
                            null,
                            `#${activeSlideHash}` || ""
                        );
                        emit("hashSet");
                    } else {
                        document.location.hash = activeSlideHash || "";
                        emit("hashSet");
                    }
                };
                const init = () => {
                    if (
                        !swiper.params.hashNavigation.enabled ||
                        (swiper.params.history && swiper.params.history.enabled)
                    )
                        return;
                    initialized = true;
                    const hash = document.location.hash.replace("#", "");
                    if (hash) {
                        const speed = 0;
                        const index = swiper.params.hashNavigation.getSlideIndex(
                            swiper,
                            hash
                        );
                        swiper.slideTo(
                            index || 0,
                            speed,
                            swiper.params.runCallbacksOnInit,
                            true
                        );
                    }
                    if (swiper.params.hashNavigation.watchState) {
                        window.addEventListener("hashchange", onHashChange);
                    }
                };
                const destroy = () => {
                    if (swiper.params.hashNavigation.watchState) {
                        window.removeEventListener("hashchange", onHashChange);
                    }
                };
                on("init", () => {
                    if (swiper.params.hashNavigation.enabled) {
                        init();
                    }
                });
                on("destroy", () => {
                    if (swiper.params.hashNavigation.enabled) {
                        destroy();
                    }
                });
                on("transitionEnd _freeModeNoMomentumRelease", () => {
                    if (initialized) {
                        setHash();
                    }
                });
                on("slideChange", () => {
                    if (initialized && swiper.params.cssMode) {
                        setHash();
                    }
                });
            }

            /* eslint no-underscore-dangle: "off" */
            /* eslint no-use-before-define: "off" */
            function Autoplay(_ref) {
                let { swiper, extendParams, on, emit, params } = _ref;
                swiper.autoplay = {
                    running: false,
                    paused: false,
                    timeLeft: 0,
                };
                extendParams({
                    autoplay: {
                        enabled: false,
                        delay: 3000,
                        waitForTransition: true,
                        disableOnInteraction: true,
                        stopOnLastSlide: false,
                        reverseDirection: false,
                        pauseOnMouseEnter: false,
                    },
                });
                let timeout;
                let raf;
                let autoplayDelayTotal =
                    params && params.autoplay ? params.autoplay.delay : 3000;
                let autoplayDelayCurrent =
                    params && params.autoplay ? params.autoplay.delay : 3000;
                let autoplayTimeLeft;
                let autoplayStartTime = new Date().getTime;
                let wasPaused;
                let isTouched;
                let pausedByTouch;
                let touchStartTimeout;
                let slideChanged;
                let pausedByInteraction;
                function onTransitionEnd(e) {
                    if (!swiper || swiper.destroyed || !swiper.wrapperEl) return;
                    if (e.target !== swiper.wrapperEl) return;
                    swiper.wrapperEl.removeEventListener(
                        "transitionend",
                        onTransitionEnd
                    );
                    resume();
                }
                const calcTimeLeft = () => {
                    if (swiper.destroyed || !swiper.autoplay.running) return;
                    if (swiper.autoplay.paused) {
                        wasPaused = true;
                    } else if (wasPaused) {
                        autoplayDelayCurrent = autoplayTimeLeft;
                        wasPaused = false;
                    }
                    const timeLeft = swiper.autoplay.paused
                        ? autoplayTimeLeft
                        : autoplayStartTime + autoplayDelayCurrent - new Date().getTime();
                    swiper.autoplay.timeLeft = timeLeft;
                    emit("autoplayTimeLeft", timeLeft, timeLeft / autoplayDelayTotal);
                    raf = requestAnimationFrame(() => {
                        calcTimeLeft();
                    });
                };
                const getSlideDelay = () => {
                    let activeSlideEl;
                    if (swiper.virtual && swiper.params.virtual.enabled) {
                        activeSlideEl = swiper.slides.filter((slideEl) =>
                            slideEl.classList.contains("swiper-slide-active")
                        )[0];
                    } else {
                        activeSlideEl = swiper.slides[swiper.activeIndex];
                    }
                    if (!activeSlideEl) return undefined;
                    const currentSlideDelay = parseInt(
                        activeSlideEl.getAttribute("data-swiper-autoplay"),
                        10
                    );
                    return currentSlideDelay;
                };
                const run = (delayForce) => {
                    if (swiper.destroyed || !swiper.autoplay.running) return;
                    cancelAnimationFrame(raf);
                    calcTimeLeft();
                    let delay =
                        typeof delayForce === "undefined"
                            ? swiper.params.autoplay.delay
                            : delayForce;
                    autoplayDelayTotal = swiper.params.autoplay.delay;
                    autoplayDelayCurrent = swiper.params.autoplay.delay;
                    const currentSlideDelay = getSlideDelay();
                    if (
                        !Number.isNaN(currentSlideDelay) &&
                        currentSlideDelay > 0 &&
                        typeof delayForce === "undefined"
                    ) {
                        delay = currentSlideDelay;
                        autoplayDelayTotal = currentSlideDelay;
                        autoplayDelayCurrent = currentSlideDelay;
                    }
                    autoplayTimeLeft = delay;
                    const speed = swiper.params.speed;
                    const proceed = () => {
                        if (!swiper || swiper.destroyed) return;
                        if (swiper.params.autoplay.reverseDirection) {
                            if (
                                !swiper.isBeginning ||
                                swiper.params.loop ||
                                swiper.params.rewind
                            ) {
                                swiper.slidePrev(speed, true, true);
                                emit("autoplay");
                            } else if (!swiper.params.autoplay.stopOnLastSlide) {
                                swiper.slideTo(swiper.slides.length - 1, speed, true, true);
                                emit("autoplay");
                            }
                        } else {
                            if (
                                !swiper.isEnd ||
                                swiper.params.loop ||
                                swiper.params.rewind
                            ) {
                                swiper.slideNext(speed, true, true);
                                emit("autoplay");
                            } else if (!swiper.params.autoplay.stopOnLastSlide) {
                                swiper.slideTo(0, speed, true, true);
                                emit("autoplay");
                            }
                        }
                        if (swiper.params.cssMode) {
                            autoplayStartTime = new Date().getTime();
                            requestAnimationFrame(() => {
                                run();
                            });
                        }
                    };
                    if (delay > 0) {
                        clearTimeout(timeout);
                        timeout = setTimeout(() => {
                            proceed();
                        }, delay);
                    } else {
                        requestAnimationFrame(() => {
                            proceed();
                        });
                    }

                    // eslint-disable-next-line
                    return delay;
                };
                const start = () => {
                    swiper.autoplay.running = true;
                    run();
                    emit("autoplayStart");
                };
                const stop = () => {
                    swiper.autoplay.running = false;
                    clearTimeout(timeout);
                    cancelAnimationFrame(raf);
                    emit("autoplayStop");
                };
                const pause = (internal, reset) => {
                    if (swiper.destroyed || !swiper.autoplay.running) return;
                    clearTimeout(timeout);
                    if (!internal) {
                        pausedByInteraction = true;
                    }
                    const proceed = () => {
                        emit("autoplayPause");
                        if (swiper.params.autoplay.waitForTransition) {
                            swiper.wrapperEl.addEventListener(
                                "transitionend",
                                onTransitionEnd
                            );
                        } else {
                            resume();
                        }
                    };
                    swiper.autoplay.paused = true;
                    if (reset) {
                        if (slideChanged) {
                            autoplayTimeLeft = swiper.params.autoplay.delay;
                        }
                        slideChanged = false;
                        proceed();
                        return;
                    }
                    const delay = autoplayTimeLeft || swiper.params.autoplay.delay;
                    autoplayTimeLeft =
                        delay - (new Date().getTime() - autoplayStartTime);
                    if (swiper.isEnd && autoplayTimeLeft < 0 && !swiper.params.loop)
                        return;
                    if (autoplayTimeLeft < 0) autoplayTimeLeft = 0;
                    proceed();
                };
                const resume = () => {
                    if (
                        (swiper.isEnd && autoplayTimeLeft < 0 && !swiper.params.loop) ||
                        swiper.destroyed ||
                        !swiper.autoplay.running
                    )
                        return;
                    autoplayStartTime = new Date().getTime();
                    if (pausedByInteraction) {
                        pausedByInteraction = false;
                        run(autoplayTimeLeft);
                    } else {
                        run();
                    }
                    swiper.autoplay.paused = false;
                    emit("autoplayResume");
                };
                const onVisibilityChange = () => {
                    if (swiper.destroyed || !swiper.autoplay.running) return;
                    const document = getDocument();
                    if (document.visibilityState === "hidden") {
                        pausedByInteraction = true;
                        pause(true);
                    }
                    if (document.visibilityState === "visible") {
                        resume();
                    }
                };
                const onPointerEnter = (e) => {
                    if (e.pointerType !== "mouse") return;
                    pausedByInteraction = true;
                    pause(true);
                };
                const onPointerLeave = (e) => {
                    if (e.pointerType !== "mouse") return;
                    if (swiper.autoplay.paused) {
                        resume();
                    }
                };
                const attachMouseEvents = () => {
                    if (swiper.params.autoplay.pauseOnMouseEnter) {
                        swiper.el.addEventListener("pointerenter", onPointerEnter);
                        swiper.el.addEventListener("pointerleave", onPointerLeave);
                    }
                };
                const detachMouseEvents = () => {
                    swiper.el.removeEventListener("pointerenter", onPointerEnter);
                    swiper.el.removeEventListener("pointerleave", onPointerLeave);
                };
                const attachDocumentEvents = () => {
                    const document = getDocument();
                    document.addEventListener("visibilitychange", onVisibilityChange);
                };
                const detachDocumentEvents = () => {
                    const document = getDocument();
                    document.removeEventListener(
                        "visibilitychange",
                        onVisibilityChange
                    );
                };
                on("init", () => {
                    if (swiper.params.autoplay.enabled) {
                        attachMouseEvents();
                        attachDocumentEvents();
                        autoplayStartTime = new Date().getTime();
                        start();
                    }
                });
                on("destroy", () => {
                    detachMouseEvents();
                    detachDocumentEvents();
                    if (swiper.autoplay.running) {
                        stop();
                    }
                });
                on("beforeTransitionStart", (_s, speed, internal) => {
                    if (swiper.destroyed || !swiper.autoplay.running) return;
                    if (internal || !swiper.params.autoplay.disableOnInteraction) {
                        pause(true, true);
                    } else {
                        stop();
                    }
                });
                on("sliderFirstMove", () => {
                    if (swiper.destroyed || !swiper.autoplay.running) return;
                    if (swiper.params.autoplay.disableOnInteraction) {
                        stop();
                        return;
                    }
                    isTouched = true;
                    pausedByTouch = false;
                    pausedByInteraction = false;
                    touchStartTimeout = setTimeout(() => {
                        pausedByInteraction = true;
                        pausedByTouch = true;
                        pause(true);
                    }, 200);
                });
                on("touchEnd", () => {
                    if (swiper.destroyed || !swiper.autoplay.running || !isTouched)
                        return;
                    clearTimeout(touchStartTimeout);
                    clearTimeout(timeout);
                    if (swiper.params.autoplay.disableOnInteraction) {
                        pausedByTouch = false;
                        isTouched = false;
                        return;
                    }
                    if (pausedByTouch && swiper.params.cssMode) resume();
                    pausedByTouch = false;
                    isTouched = false;
                });
                on("slideChange", () => {
                    if (swiper.destroyed || !swiper.autoplay.running) return;
                    slideChanged = true;
                });
                Object.assign(swiper.autoplay, {
                    start,
                    stop,
                    pause,
                    resume,
                });
            }

            function Thumb(_ref) {
                let { swiper, extendParams, on } = _ref;
                extendParams({
                    thumbs: {
                        swiper: null,
                        multipleActiveThumbs: true,
                        autoScrollOffset: 0,
                        slideThumbActiveClass: "swiper-slide-thumb-active",
                        thumbsContainerClass: "swiper-thumbs",
                    },
                });
                let initialized = false;
                let swiperCreated = false;
                swiper.thumbs = {
                    swiper: null,
                };
                function onThumbClick() {
                    const thumbsSwiper = swiper.thumbs.swiper;
                    if (!thumbsSwiper || thumbsSwiper.destroyed) return;
                    const clickedIndex = thumbsSwiper.clickedIndex;
                    const clickedSlide = thumbsSwiper.clickedSlide;
                    if (
                        clickedSlide &&
                        clickedSlide.classList.contains(
                            swiper.params.thumbs.slideThumbActiveClass
                        )
                    )
                        return;
                    if (typeof clickedIndex === "undefined" || clickedIndex === null)
                        return;
                    let slideToIndex;
                    if (thumbsSwiper.params.loop) {
                        slideToIndex = parseInt(
                            thumbsSwiper.clickedSlide.getAttribute(
                                "data-swiper-slide-index"
                            ),
                            10
                        );
                    } else {
                        slideToIndex = clickedIndex;
                    }
                    if (swiper.params.loop) {
                        swiper.slideToLoop(slideToIndex);
                    } else {
                        swiper.slideTo(slideToIndex);
                    }
                }
                function init() {
                    const { thumbs: thumbsParams } = swiper.params;
                    if (initialized) return false;
                    initialized = true;
                    const SwiperClass = swiper.constructor;
                    if (thumbsParams.swiper instanceof SwiperClass) {
                        swiper.thumbs.swiper = thumbsParams.swiper;
                        Object.assign(swiper.thumbs.swiper.originalParams, {
                            watchSlidesProgress: true,
                            slideToClickedSlide: false,
                        });
                        Object.assign(swiper.thumbs.swiper.params, {
                            watchSlidesProgress: true,
                            slideToClickedSlide: false,
                        });
                        swiper.thumbs.swiper.update();
                    } else if (isObject(thumbsParams.swiper)) {
                        const thumbsSwiperParams = Object.assign({}, thumbsParams.swiper);
                        Object.assign(thumbsSwiperParams, {
                            watchSlidesProgress: true,
                            slideToClickedSlide: false,
                        });
                        swiper.thumbs.swiper = new SwiperClass(thumbsSwiperParams);
                        swiperCreated = true;
                    }
                    swiper.thumbs.swiper.el.classList.add(
                        swiper.params.thumbs.thumbsContainerClass
                    );
                    swiper.thumbs.swiper.on("tap", onThumbClick);
                    return true;
                }
                function update(initial) {
                    const thumbsSwiper = swiper.thumbs.swiper;
                    if (!thumbsSwiper || thumbsSwiper.destroyed) return;
                    const slidesPerView =
                        thumbsSwiper.params.slidesPerView === "auto"
                            ? thumbsSwiper.slidesPerViewDynamic()
                            : thumbsSwiper.params.slidesPerView;

                    // Activate thumbs
                    let thumbsToActivate = 1;
                    const thumbActiveClass = swiper.params.thumbs.slideThumbActiveClass;
                    if (
                        swiper.params.slidesPerView > 1 &&
                        !swiper.params.centeredSlides
                    ) {
                        thumbsToActivate = swiper.params.slidesPerView;
                    }
                    if (!swiper.params.thumbs.multipleActiveThumbs) {
                        thumbsToActivate = 1;
                    }
                    thumbsToActivate = Math.floor(thumbsToActivate);
                    thumbsSwiper.slides.forEach((slideEl) =>
                        slideEl.classList.remove(thumbActiveClass)
                    );
                    if (
                        thumbsSwiper.params.loop ||
                        (thumbsSwiper.params.virtual &&
                            thumbsSwiper.params.virtual.enabled)
                    ) {
                        for (let i = 0; i < thumbsToActivate; i += 1) {
                            elementChildren(
                                thumbsSwiper.slidesEl,
                                `[data-swiper-slide-index="${swiper.realIndex + i}"]`
                            ).forEach((slideEl) => {
                                slideEl.classList.add(thumbActiveClass);
                            });
                        }
                    } else {
                        for (let i = 0; i < thumbsToActivate; i += 1) {
                            if (thumbsSwiper.slides[swiper.realIndex + i]) {
                                thumbsSwiper.slides[swiper.realIndex + i].classList.add(
                                    thumbActiveClass
                                );
                            }
                        }
                    }
                    const autoScrollOffset = swiper.params.thumbs.autoScrollOffset;
                    const useOffset = autoScrollOffset && !thumbsSwiper.params.loop;
                    if (swiper.realIndex !== thumbsSwiper.realIndex || useOffset) {
                        const currentThumbsIndex = thumbsSwiper.activeIndex;
                        let newThumbsIndex;
                        let direction;
                        if (thumbsSwiper.params.loop) {
                            const newThumbsSlide = thumbsSwiper.slides.filter(
                                (slideEl) =>
                                    slideEl.getAttribute("data-swiper-slide-index") ===
                                    `${swiper.realIndex}`
                            )[0];
                            newThumbsIndex = thumbsSwiper.slides.indexOf(newThumbsSlide);
                            direction =
                                swiper.activeIndex > swiper.previousIndex ? "next" : "prev";
                        } else {
                            newThumbsIndex = swiper.realIndex;
                            direction =
                                newThumbsIndex > swiper.previousIndex ? "next" : "prev";
                        }
                        if (useOffset) {
                            newThumbsIndex +=
                                direction === "next"
                                    ? autoScrollOffset
                                    : -1 * autoScrollOffset;
                        }
                        if (
                            thumbsSwiper.visibleSlidesIndexes &&
                            thumbsSwiper.visibleSlidesIndexes.indexOf(newThumbsIndex) < 0
                        ) {
                            if (thumbsSwiper.params.centeredSlides) {
                                if (newThumbsIndex > currentThumbsIndex) {
                                    newThumbsIndex =
                                        newThumbsIndex - Math.floor(slidesPerView / 2) + 1;
                                } else {
                                    newThumbsIndex =
                                        newThumbsIndex + Math.floor(slidesPerView / 2) - 1;
                                }
                            } else if (
                                newThumbsIndex > currentThumbsIndex &&
                                thumbsSwiper.params.slidesPerGroup === 1
                            );
                            thumbsSwiper.slideTo(newThumbsIndex, initial ? 0 : undefined);
                        }
                    }
                }
                on("beforeInit", () => {
                    const { thumbs } = swiper.params;
                    if (!thumbs || !thumbs.swiper) return;
                    if (
                        typeof thumbs.swiper === "string" ||
                        thumbs.swiper instanceof HTMLElement
                    ) {
                        const document = getDocument();
                        const getThumbsElementAndInit = () => {
                            const thumbsElement =
                                typeof thumbs.swiper === "string"
                                    ? document.querySelector(thumbs.swiper)
                                    : thumbs.swiper;
                            if (thumbsElement && thumbsElement.swiper) {
                                thumbs.swiper = thumbsElement.swiper;
                                init();
                                update(true);
                            } else if (thumbsElement) {
                                const onThumbsSwiper = (e) => {
                                    thumbs.swiper = e.detail[0];
                                    thumbsElement.removeEventListener("init", onThumbsSwiper);
                                    init();
                                    update(true);
                                    thumbs.swiper.update();
                                    swiper.update();
                                };
                                thumbsElement.addEventListener("init", onThumbsSwiper);
                            }
                            return thumbsElement;
                        };
                        const watchForThumbsToAppear = () => {
                            if (swiper.destroyed) return;
                            const thumbsElement = getThumbsElementAndInit();
                            if (!thumbsElement) {
                                requestAnimationFrame(watchForThumbsToAppear);
                            }
                        };
                        requestAnimationFrame(watchForThumbsToAppear);
                    } else {
                        init();
                        update(true);
                    }
                });
                on("slideChange update resize observerUpdate", () => {
                    update();
                });
                on("setTransition", (_s, duration) => {
                    const thumbsSwiper = swiper.thumbs.swiper;
                    if (!thumbsSwiper || thumbsSwiper.destroyed) return;
                    thumbsSwiper.setTransition(duration);
                });
                on("beforeDestroy", () => {
                    const thumbsSwiper = swiper.thumbs.swiper;
                    if (!thumbsSwiper || thumbsSwiper.destroyed) return;
                    if (swiperCreated) {
                        thumbsSwiper.destroy();
                    }
                });
                Object.assign(swiper.thumbs, {
                    init,
                    update,
                });
            }

            function freeMode(_ref) {
                let { swiper, extendParams, emit, once } = _ref;
                extendParams({
                    freeMode: {
                        enabled: false,
                        momentum: true,
                        momentumRatio: 1,
                        momentumBounce: true,
                        momentumBounceRatio: 1,
                        momentumVelocityRatio: 1,
                        sticky: false,
                        minimumVelocity: 0.02,
                    },
                });
                function onTouchStart() {
                    if (swiper.params.cssMode) return;
                    const translate = swiper.getTranslate();
                    swiper.setTranslate(translate);
                    swiper.setTransition(0);
                    swiper.touchEventsData.velocities.length = 0;
                    swiper.freeMode.onTouchEnd({
                        currentPos: swiper.rtl ? swiper.translate : -swiper.translate,
                    });
                }
                function onTouchMove() {
                    if (swiper.params.cssMode) return;
                    const { touchEventsData: data, touches } = swiper;
                    // Velocity
                    if (data.velocities.length === 0) {
                        data.velocities.push({
                            position: touches[swiper.isHorizontal() ? "startX" : "startY"],
                            time: data.touchStartTime,
                        });
                    }
                    data.velocities.push({
                        position:
                            touches[swiper.isHorizontal() ? "currentX" : "currentY"],
                        time: now(),
                    });
                }
                function onTouchEnd(_ref2) {
                    let { currentPos } = _ref2;
                    if (swiper.params.cssMode) return;
                    const {
                        params,
                        wrapperEl,
                        rtlTranslate: rtl,
                        snapGrid,
                        touchEventsData: data,
                    } = swiper;
                    // Time diff
                    const touchEndTime = now();
                    const timeDiff = touchEndTime - data.touchStartTime;
                    if (currentPos < -swiper.minTranslate()) {
                        swiper.slideTo(swiper.activeIndex);
                        return;
                    }
                    if (currentPos > -swiper.maxTranslate()) {
                        if (swiper.slides.length < snapGrid.length) {
                            swiper.slideTo(snapGrid.length - 1);
                        } else {
                            swiper.slideTo(swiper.slides.length - 1);
                        }
                        return;
                    }
                    if (params.freeMode.momentum) {
                        if (data.velocities.length > 1) {
                            const lastMoveEvent = data.velocities.pop();
                            const velocityEvent = data.velocities.pop();
                            const distance =
                                lastMoveEvent.position - velocityEvent.position;
                            const time = lastMoveEvent.time - velocityEvent.time;
                            swiper.velocity = distance / time;
                            swiper.velocity /= 2;
                            if (
                                Math.abs(swiper.velocity) < params.freeMode.minimumVelocity
                            ) {
                                swiper.velocity = 0;
                            }
                            // this implies that the user stopped moving a finger then released.
                            // There would be no events with distance zero, so the last event is stale.
                            if (time > 150 || now() - lastMoveEvent.time > 300) {
                                swiper.velocity = 0;
                            }
                        } else {
                            swiper.velocity = 0;
                        }
                        swiper.velocity *= params.freeMode.momentumVelocityRatio;
                        data.velocities.length = 0;
                        let momentumDuration = 1000 * params.freeMode.momentumRatio;
                        const momentumDistance = swiper.velocity * momentumDuration;
                        let newPosition = swiper.translate + momentumDistance;
                        if (rtl) newPosition = -newPosition;
                        let doBounce = false;
                        let afterBouncePosition;
                        const bounceAmount =
                            Math.abs(swiper.velocity) *
                            20 *
                            params.freeMode.momentumBounceRatio;
                        let needsLoopFix;
                        if (newPosition < swiper.maxTranslate()) {
                            if (params.freeMode.momentumBounce) {
                                if (newPosition + swiper.maxTranslate() < -bounceAmount) {
                                    newPosition = swiper.maxTranslate() - bounceAmount;
                                }
                                afterBouncePosition = swiper.maxTranslate();
                                doBounce = true;
                                data.allowMomentumBounce = true;
                            } else {
                                newPosition = swiper.maxTranslate();
                            }
                            if (params.loop && params.centeredSlides) needsLoopFix = true;
                        } else if (newPosition > swiper.minTranslate()) {
                            if (params.freeMode.momentumBounce) {
                                if (newPosition - swiper.minTranslate() > bounceAmount) {
                                    newPosition = swiper.minTranslate() + bounceAmount;
                                }
                                afterBouncePosition = swiper.minTranslate();
                                doBounce = true;
                                data.allowMomentumBounce = true;
                            } else {
                                newPosition = swiper.minTranslate();
                            }
                            if (params.loop && params.centeredSlides) needsLoopFix = true;
                        } else if (params.freeMode.sticky) {
                            let nextSlide;
                            for (let j = 0; j < snapGrid.length; j += 1) {
                                if (snapGrid[j] > -newPosition) {
                                    nextSlide = j;
                                    break;
                                }
                            }
                            if (
                                Math.abs(snapGrid[nextSlide] - newPosition) <
                                Math.abs(snapGrid[nextSlide - 1] - newPosition) ||
                                swiper.swipeDirection === "next"
                            ) {
                                newPosition = snapGrid[nextSlide];
                            } else {
                                newPosition = snapGrid[nextSlide - 1];
                            }
                            newPosition = -newPosition;
                        }
                        if (needsLoopFix) {
                            once("transitionEnd", () => {
                                swiper.loopFix();
                            });
                        }
                        // Fix duration
                        if (swiper.velocity !== 0) {
                            if (rtl) {
                                momentumDuration = Math.abs(
                                    (-newPosition - swiper.translate) / swiper.velocity
                                );
                            } else {
                                momentumDuration = Math.abs(
                                    (newPosition - swiper.translate) / swiper.velocity
                                );
                            }
                            if (params.freeMode.sticky) {
                                // If freeMode.sticky is active and the user ends a swipe with a slow-velocity
                                // event, then durations can be 20+ seconds to slide one (or zero!) slides.
                                // It's easy to see this when simulating touch with mouse events. To fix this,
                                // limit single-slide swipes to the default slide duration. This also has the
                                // nice side effect of matching slide speed if the user stopped moving before
                                // lifting finger or mouse vs. moving slowly before lifting the finger/mouse.
                                // For faster swipes, also apply limits (albeit higher ones).
                                const moveDistance = Math.abs(
                                    (rtl ? -newPosition : newPosition) - swiper.translate
                                );
                                const currentSlideSize =
                                    swiper.slidesSizesGrid[swiper.activeIndex];
                                if (moveDistance < currentSlideSize) {
                                    momentumDuration = params.speed;
                                } else if (moveDistance < 2 * currentSlideSize) {
                                    momentumDuration = params.speed * 1.5;
                                } else {
                                    momentumDuration = params.speed * 2.5;
                                }
                            }
                        } else if (params.freeMode.sticky) {
                            swiper.slideToClosest();
                            return;
                        }
                        if (params.freeMode.momentumBounce && doBounce) {
                            swiper.updateProgress(afterBouncePosition);
                            swiper.setTransition(momentumDuration);
                            swiper.setTranslate(newPosition);
                            swiper.transitionStart(true, swiper.swipeDirection);
                            swiper.animating = true;
                            elementTransitionEnd(wrapperEl, () => {
                                if (!swiper || swiper.destroyed || !data.allowMomentumBounce)
                                    return;
                                emit("momentumBounce");
                                swiper.setTransition(params.speed);
                                setTimeout(() => {
                                    swiper.setTranslate(afterBouncePosition);
                                    elementTransitionEnd(wrapperEl, () => {
                                        if (!swiper || swiper.destroyed) return;
                                        swiper.transitionEnd();
                                    });
                                }, 0);
                            });
                        } else if (swiper.velocity) {
                            emit("_freeModeNoMomentumRelease");
                            swiper.updateProgress(newPosition);
                            swiper.setTransition(momentumDuration);
                            swiper.setTranslate(newPosition);
                            swiper.transitionStart(true, swiper.swipeDirection);
                            if (!swiper.animating) {
                                swiper.animating = true;
                                elementTransitionEnd(wrapperEl, () => {
                                    if (!swiper || swiper.destroyed) return;
                                    swiper.transitionEnd();
                                });
                            }
                        } else {
                            swiper.updateProgress(newPosition);
                        }
                        swiper.updateActiveIndex();
                        swiper.updateSlidesClasses();
                    } else if (params.freeMode.sticky) {
                        swiper.slideToClosest();
                        return;
                    } else if (params.freeMode) {
                        emit("_freeModeNoMomentumRelease");
                    }
                    if (!params.freeMode.momentum || timeDiff >= params.longSwipesMs) {
                        swiper.updateProgress();
                        swiper.updateActiveIndex();
                        swiper.updateSlidesClasses();
                    }
                }
                Object.assign(swiper, {
                    freeMode: {
                        onTouchStart,
                        onTouchMove,
                        onTouchEnd,
                    },
                });
            }

            function Grid(_ref) {
                let { swiper, extendParams } = _ref;
                extendParams({
                    grid: {
                        rows: 1,
                        fill: "column",
                    },
                });
                let slidesNumberEvenToRows;
                let slidesPerRow;
                let numFullColumns;
                const getSpaceBetween = () => {
                    let spaceBetween = swiper.params.spaceBetween;
                    if (
                        typeof spaceBetween === "string" &&
                        spaceBetween.indexOf("%") >= 0
                    ) {
                        spaceBetween =
                            (parseFloat(spaceBetween.replace("%", "")) / 100) * swiper.size;
                    } else if (typeof spaceBetween === "string") {
                        spaceBetween = parseFloat(spaceBetween);
                    }
                    return spaceBetween;
                };
                const initSlides = (slidesLength) => {
                    const { slidesPerView } = swiper.params;
                    const { rows, fill } = swiper.params.grid;
                    numFullColumns = Math.floor(slidesLength / rows);
                    if (Math.floor(slidesLength / rows) === slidesLength / rows) {
                        slidesNumberEvenToRows = slidesLength;
                    } else {
                        slidesNumberEvenToRows = Math.ceil(slidesLength / rows) * rows;
                    }
                    if (slidesPerView !== "auto" && fill === "row") {
                        slidesNumberEvenToRows = Math.max(
                            slidesNumberEvenToRows,
                            slidesPerView * rows
                        );
                    }
                    slidesPerRow = slidesNumberEvenToRows / rows;
                };
                const updateSlide = (i, slide, slidesLength, getDirectionLabel) => {
                    const { slidesPerGroup } = swiper.params;
                    const spaceBetween = getSpaceBetween();
                    const { rows, fill } = swiper.params.grid;
                    // Set slides order
                    let newSlideOrderIndex;
                    let column;
                    let row;
                    if (fill === "row" && slidesPerGroup > 1) {
                        const groupIndex = Math.floor(i / (slidesPerGroup * rows));
                        const slideIndexInGroup = i - rows * slidesPerGroup * groupIndex;
                        const columnsInGroup =
                            groupIndex === 0
                                ? slidesPerGroup
                                : Math.min(
                                    Math.ceil(
                                        (slidesLength - groupIndex * rows * slidesPerGroup) /
                                        rows
                                    ),
                                    slidesPerGroup
                                );
                        row = Math.floor(slideIndexInGroup / columnsInGroup);
                        column =
                            slideIndexInGroup -
                            row * columnsInGroup +
                            groupIndex * slidesPerGroup;
                        newSlideOrderIndex =
                            column + (row * slidesNumberEvenToRows) / rows;
                        slide.style.order = newSlideOrderIndex;
                    } else if (fill === "column") {
                        column = Math.floor(i / rows);
                        row = i - column * rows;
                        if (
                            column > numFullColumns ||
                            (column === numFullColumns && row === rows - 1)
                        ) {
                            row += 1;
                            if (row >= rows) {
                                row = 0;
                                column += 1;
                            }
                        }
                    } else {
                        row = Math.floor(i / slidesPerRow);
                        column = i - row * slidesPerRow;
                    }
                    slide.row = row;
                    slide.column = column;
                    slide.style[getDirectionLabel("margin-top")] =
                        row !== 0 ? spaceBetween && `${spaceBetween}px` : "";
                };
                const updateWrapperSize = (
                    slideSize,
                    snapGrid,
                    getDirectionLabel
                ) => {
                    const { centeredSlides, roundLengths } = swiper.params;
                    const spaceBetween = getSpaceBetween();
                    const { rows } = swiper.params.grid;
                    swiper.virtualSize =
                        (slideSize + spaceBetween) * slidesNumberEvenToRows;
                    swiper.virtualSize =
                        Math.ceil(swiper.virtualSize / rows) - spaceBetween;
                    swiper.wrapperEl.style[getDirectionLabel("width")] = `${swiper.virtualSize + spaceBetween
                        }px`;
                    if (centeredSlides) {
                        const newSlidesGrid = [];
                        for (let i = 0; i < snapGrid.length; i += 1) {
                            let slidesGridItem = snapGrid[i];
                            if (roundLengths) slidesGridItem = Math.floor(slidesGridItem);
                            if (snapGrid[i] < swiper.virtualSize + snapGrid[0])
                                newSlidesGrid.push(slidesGridItem);
                        }
                        snapGrid.splice(0, snapGrid.length);
                        snapGrid.push(...newSlidesGrid);
                    }
                };
                swiper.grid = {
                    initSlides,
                    updateSlide,
                    updateWrapperSize,
                };
            }

            function appendSlide(slides) {
                const swiper = this;
                const { params, slidesEl } = swiper;
                if (params.loop) {
                    swiper.loopDestroy();
                }
                const appendElement = (slideEl) => {
                    if (typeof slideEl === "string") {
                        const tempDOM = document.createElement("div");
                        tempDOM.innerHTML = slideEl;
                        slidesEl.append(tempDOM.children[0]);
                        tempDOM.innerHTML = "";
                    } else {
                        slidesEl.append(slideEl);
                    }
                };
                if (typeof slides === "object" && "length" in slides) {
                    for (let i = 0; i < slides.length; i += 1) {
                        if (slides[i]) appendElement(slides[i]);
                    }
                } else {
                    appendElement(slides);
                }
                swiper.recalcSlides();
                if (params.loop) {
                    swiper.loopCreate();
                }
                if (!params.observer || swiper.isElement) {
                    swiper.update();
                }
            }

            function prependSlide(slides) {
                const swiper = this;
                const { params, activeIndex, slidesEl } = swiper;
                if (params.loop) {
                    swiper.loopDestroy();
                }
                let newActiveIndex = activeIndex + 1;
                const prependElement = (slideEl) => {
                    if (typeof slideEl === "string") {
                        const tempDOM = document.createElement("div");
                        tempDOM.innerHTML = slideEl;
                        slidesEl.prepend(tempDOM.children[0]);
                        tempDOM.innerHTML = "";
                    } else {
                        slidesEl.prepend(slideEl);
                    }
                };
                if (typeof slides === "object" && "length" in slides) {
                    for (let i = 0; i < slides.length; i += 1) {
                        if (slides[i]) prependElement(slides[i]);
                    }
                    newActiveIndex = activeIndex + slides.length;
                } else {
                    prependElement(slides);
                }
                swiper.recalcSlides();
                if (params.loop) {
                    swiper.loopCreate();
                }
                if (!params.observer || swiper.isElement) {
                    swiper.update();
                }
                swiper.slideTo(newActiveIndex, 0, false);
            }

            function addSlide(index, slides) {
                const swiper = this;
                const { params, activeIndex, slidesEl } = swiper;
                let activeIndexBuffer = activeIndex;
                if (params.loop) {
                    activeIndexBuffer -= swiper.loopedSlides;
                    swiper.loopDestroy();
                    swiper.recalcSlides();
                }
                const baseLength = swiper.slides.length;
                if (index <= 0) {
                    swiper.prependSlide(slides);
                    return;
                }
                if (index >= baseLength) {
                    swiper.appendSlide(slides);
                    return;
                }
                let newActiveIndex =
                    activeIndexBuffer > index
                        ? activeIndexBuffer + 1
                        : activeIndexBuffer;
                const slidesBuffer = [];
                for (let i = baseLength - 1; i >= index; i -= 1) {
                    const currentSlide = swiper.slides[i];
                    currentSlide.remove();
                    slidesBuffer.unshift(currentSlide);
                }
                if (typeof slides === "object" && "length" in slides) {
                    for (let i = 0; i < slides.length; i += 1) {
                        if (slides[i]) slidesEl.append(slides[i]);
                    }
                    newActiveIndex =
                        activeIndexBuffer > index
                            ? activeIndexBuffer + slides.length
                            : activeIndexBuffer;
                } else {
                    slidesEl.append(slides);
                }
                for (let i = 0; i < slidesBuffer.length; i += 1) {
                    slidesEl.append(slidesBuffer[i]);
                }
                swiper.recalcSlides();
                if (params.loop) {
                    swiper.loopCreate();
                }
                if (!params.observer || swiper.isElement) {
                    swiper.update();
                }
                if (params.loop) {
                    swiper.slideTo(newActiveIndex + swiper.loopedSlides, 0, false);
                } else {
                    swiper.slideTo(newActiveIndex, 0, false);
                }
            }

            function removeSlide(slidesIndexes) {
                const swiper = this;
                const { params, activeIndex } = swiper;
                let activeIndexBuffer = activeIndex;
                if (params.loop) {
                    activeIndexBuffer -= swiper.loopedSlides;
                    swiper.loopDestroy();
                }
                let newActiveIndex = activeIndexBuffer;
                let indexToRemove;
                if (typeof slidesIndexes === "object" && "length" in slidesIndexes) {
                    for (let i = 0; i < slidesIndexes.length; i += 1) {
                        indexToRemove = slidesIndexes[i];
                        if (swiper.slides[indexToRemove])
                            swiper.slides[indexToRemove].remove();
                        if (indexToRemove < newActiveIndex) newActiveIndex -= 1;
                    }
                    newActiveIndex = Math.max(newActiveIndex, 0);
                } else {
                    indexToRemove = slidesIndexes;
                    if (swiper.slides[indexToRemove])
                        swiper.slides[indexToRemove].remove();
                    if (indexToRemove < newActiveIndex) newActiveIndex -= 1;
                    newActiveIndex = Math.max(newActiveIndex, 0);
                }
                swiper.recalcSlides();
                if (params.loop) {
                    swiper.loopCreate();
                }
                if (!params.observer || swiper.isElement) {
                    swiper.update();
                }
                if (params.loop) {
                    swiper.slideTo(newActiveIndex + swiper.loopedSlides, 0, false);
                } else {
                    swiper.slideTo(newActiveIndex, 0, false);
                }
            }

            function removeAllSlides() {
                const swiper = this;
                const slidesIndexes = [];
                for (let i = 0; i < swiper.slides.length; i += 1) {
                    slidesIndexes.push(i);
                }
                swiper.removeSlide(slidesIndexes);
            }

            function Manipulation(_ref) {
                let { swiper } = _ref;
                Object.assign(swiper, {
                    appendSlide: appendSlide.bind(swiper),
                    prependSlide: prependSlide.bind(swiper),
                    addSlide: addSlide.bind(swiper),
                    removeSlide: removeSlide.bind(swiper),
                    removeAllSlides: removeAllSlides.bind(swiper),
                });
            }

            function effectInit(params) {
                const {
                    effect,
                    swiper,
                    on,
                    setTranslate,
                    setTransition,
                    overwriteParams,
                    perspective,
                    recreateShadows,
                    getEffectParams,
                } = params;
                on("beforeInit", () => {
                    if (swiper.params.effect !== effect) return;
                    swiper.classNames.push(
                        `${swiper.params.containerModifierClass}${effect}`
                    );
                    if (perspective && perspective()) {
                        swiper.classNames.push(
                            `${swiper.params.containerModifierClass}3d`
                        );
                    }
                    const overwriteParamsResult = overwriteParams
                        ? overwriteParams()
                        : {};
                    Object.assign(swiper.params, overwriteParamsResult);
                    Object.assign(swiper.originalParams, overwriteParamsResult);
                });
                on("setTranslate", () => {
                    if (swiper.params.effect !== effect) return;
                    setTranslate();
                });
                on("setTransition", (_s, duration) => {
                    if (swiper.params.effect !== effect) return;
                    setTransition(duration);
                });
                on("transitionEnd", () => {
                    if (swiper.params.effect !== effect) return;
                    if (recreateShadows) {
                        if (!getEffectParams || !getEffectParams().slideShadows) return;
                        // remove shadows
                        swiper.slides.forEach((slideEl) => {
                            slideEl
                                .querySelectorAll(
                                    ".swiper-slide-shadow-top, .swiper-slide-shadow-right, .swiper-slide-shadow-bottom, .swiper-slide-shadow-left"
                                )
                                .forEach((shadowEl) => shadowEl.remove());
                        });
                        // create new one
                        recreateShadows();
                    }
                });
                let requireUpdateOnVirtual;
                on("virtualUpdate", () => {
                    if (swiper.params.effect !== effect) return;
                    if (!swiper.slides.length) {
                        requireUpdateOnVirtual = true;
                    }
                    requestAnimationFrame(() => {
                        if (
                            requireUpdateOnVirtual &&
                            swiper.slides &&
                            swiper.slides.length
                        ) {
                            setTranslate();
                            requireUpdateOnVirtual = false;
                        }
                    });
                });
            }

            function effectTarget(effectParams, slideEl) {
                const transformEl = getSlideTransformEl(slideEl);
                if (transformEl !== slideEl) {
                    transformEl.style.backfaceVisibility = "hidden";
                    transformEl.style["-webkit-backface-visibility"] = "hidden";
                }
                return transformEl;
            }

            function effectVirtualTransitionEnd(_ref) {
                let { swiper, duration, transformElements, allSlides } = _ref;
                const { activeIndex } = swiper;
                const getSlide = (el) => {
                    if (!el.parentElement) {
                        // assume shadow root
                        const slide = swiper.slides.filter(
                            (slideEl) =>
                                slideEl.shadowRoot && slideEl.shadowRoot === el.parentNode
                        )[0];
                        return slide;
                    }
                    return el.parentElement;
                };
                if (swiper.params.virtualTranslate && duration !== 0) {
                    let eventTriggered = false;
                    let transitionEndTarget;
                    if (allSlides) {
                        transitionEndTarget = transformElements;
                    } else {
                        transitionEndTarget = transformElements.filter((transformEl) => {
                            const el = transformEl.classList.contains(
                                "swiper-slide-transform"
                            )
                                ? getSlide(transformEl)
                                : transformEl;
                            return swiper.getSlideIndex(el) === activeIndex;
                        });
                    }
                    transitionEndTarget.forEach((el) => {
                        elementTransitionEnd(el, () => {
                            if (eventTriggered) return;
                            if (!swiper || swiper.destroyed) return;
                            eventTriggered = true;
                            swiper.animating = false;
                            const evt = new window.CustomEvent("transitionend", {
                                bubbles: true,
                                cancelable: true,
                            });
                            swiper.wrapperEl.dispatchEvent(evt);
                        });
                    });
                }
            }

            function EffectFade(_ref) {
                let { swiper, extendParams, on } = _ref;
                extendParams({
                    fadeEffect: {
                        crossFade: false,
                    },
                });
                const setTranslate = () => {
                    const { slides } = swiper;
                    const params = swiper.params.fadeEffect;
                    for (let i = 0; i < slides.length; i += 1) {
                        const slideEl = swiper.slides[i];
                        const offset = slideEl.swiperSlideOffset;
                        let tx = -offset;
                        if (!swiper.params.virtualTranslate) tx -= swiper.translate;
                        let ty = 0;
                        if (!swiper.isHorizontal()) {
                            ty = tx;
                            tx = 0;
                        }
                        const slideOpacity = swiper.params.fadeEffect.crossFade
                            ? Math.max(1 - Math.abs(slideEl.progress), 0)
                            : 1 + Math.min(Math.max(slideEl.progress, -1), 0);
                        const targetEl = effectTarget(params, slideEl);
                        targetEl.style.opacity = slideOpacity;
                        targetEl.style.transform = `translate3d(${tx}px, ${ty}px, 0px)`;
                    }
                };
                const setTransition = (duration) => {
                    const transformElements = swiper.slides.map((slideEl) =>
                        getSlideTransformEl(slideEl)
                    );
                    transformElements.forEach((el) => {
                        el.style.transitionDuration = `${duration}ms`;
                    });
                    effectVirtualTransitionEnd({
                        swiper,
                        duration,
                        transformElements,
                        allSlides: true,
                    });
                };
                effectInit({
                    effect: "fade",
                    swiper,
                    on,
                    setTranslate,
                    setTransition,
                    overwriteParams: () => ({
                        slidesPerView: 1,
                        slidesPerGroup: 1,
                        watchSlidesProgress: true,
                        spaceBetween: 0,
                        virtualTranslate: !swiper.params.cssMode,
                    }),
                });
            }

            function EffectCube(_ref) {
                let { swiper, extendParams, on } = _ref;
                extendParams({
                    cubeEffect: {
                        slideShadows: true,
                        shadow: true,
                        shadowOffset: 20,
                        shadowScale: 0.94,
                    },
                });
                const createSlideShadows = (slideEl, progress, isHorizontal) => {
                    let shadowBefore = isHorizontal
                        ? slideEl.querySelector(".swiper-slide-shadow-left")
                        : slideEl.querySelector(".swiper-slide-shadow-top");
                    let shadowAfter = isHorizontal
                        ? slideEl.querySelector(".swiper-slide-shadow-right")
                        : slideEl.querySelector(".swiper-slide-shadow-bottom");
                    if (!shadowBefore) {
                        shadowBefore = createElement(
                            "div",
                            `swiper-slide-shadow-cube swiper-slide-shadow-${isHorizontal ? "left" : "top"
                                }`.split(" ")
                        );
                        slideEl.append(shadowBefore);
                    }
                    if (!shadowAfter) {
                        shadowAfter = createElement(
                            "div",
                            `swiper-slide-shadow-cube swiper-slide-shadow-${isHorizontal ? "right" : "bottom"
                                }`.split(" ")
                        );
                        slideEl.append(shadowAfter);
                    }
                    if (shadowBefore)
                        shadowBefore.style.opacity = Math.max(-progress, 0);
                    if (shadowAfter) shadowAfter.style.opacity = Math.max(progress, 0);
                };
                const recreateShadows = () => {
                    // create new ones
                    const isHorizontal = swiper.isHorizontal();
                    swiper.slides.forEach((slideEl) => {
                        const progress = Math.max(Math.min(slideEl.progress, 1), -1);
                        createSlideShadows(slideEl, progress, isHorizontal);
                    });
                };
                const setTranslate = () => {
                    const {
                        el,
                        wrapperEl,
                        slides,
                        width: swiperWidth,
                        height: swiperHeight,
                        rtlTranslate: rtl,
                        size: swiperSize,
                        browser,
                    } = swiper;
                    const params = swiper.params.cubeEffect;
                    const isHorizontal = swiper.isHorizontal();
                    const isVirtual = swiper.virtual && swiper.params.virtual.enabled;
                    let wrapperRotate = 0;
                    let cubeShadowEl;
                    if (params.shadow) {
                        if (isHorizontal) {
                            cubeShadowEl = swiper.wrapperEl.querySelector(
                                ".swiper-cube-shadow"
                            );
                            if (!cubeShadowEl) {
                                cubeShadowEl = createElement("div", "swiper-cube-shadow");
                                swiper.wrapperEl.append(cubeShadowEl);
                            }
                            cubeShadowEl.style.height = `${swiperWidth}px`;
                        } else {
                            cubeShadowEl = el.querySelector(".swiper-cube-shadow");
                            if (!cubeShadowEl) {
                                cubeShadowEl = createElement("div", "swiper-cube-shadow");
                                el.append(cubeShadowEl);
                            }
                        }
                    }
                    for (let i = 0; i < slides.length; i += 1) {
                        const slideEl = slides[i];
                        let slideIndex = i;
                        if (isVirtual) {
                            slideIndex = parseInt(
                                slideEl.getAttribute("data-swiper-slide-index"),
                                10
                            );
                        }
                        let slideAngle = slideIndex * 90;
                        let round = Math.floor(slideAngle / 360);
                        if (rtl) {
                            slideAngle = -slideAngle;
                            round = Math.floor(-slideAngle / 360);
                        }
                        const progress = Math.max(Math.min(slideEl.progress, 1), -1);
                        let tx = 0;
                        let ty = 0;
                        let tz = 0;
                        if (slideIndex % 4 === 0) {
                            tx = -round * 4 * swiperSize;
                            tz = 0;
                        } else if ((slideIndex - 1) % 4 === 0) {
                            tx = 0;
                            tz = -round * 4 * swiperSize;
                        } else if ((slideIndex - 2) % 4 === 0) {
                            tx = swiperSize + round * 4 * swiperSize;
                            tz = swiperSize;
                        } else if ((slideIndex - 3) % 4 === 0) {
                            tx = -swiperSize;
                            tz = 3 * swiperSize + swiperSize * 4 * round;
                        }
                        if (rtl) {
                            tx = -tx;
                        }
                        if (!isHorizontal) {
                            ty = tx;
                            tx = 0;
                        }
                        const transform = `rotateX(${isHorizontal ? 0 : -slideAngle
                            }deg) rotateY(${isHorizontal ? slideAngle : 0
                            }deg) translate3d(${tx}px, ${ty}px, ${tz}px)`;
                        if (progress <= 1 && progress > -1) {
                            wrapperRotate = slideIndex * 90 + progress * 90;
                            if (rtl) wrapperRotate = -slideIndex * 90 - progress * 90;
                        }
                        slideEl.style.transform = transform;
                        if (params.slideShadows) {
                            createSlideShadows(slideEl, progress, isHorizontal);
                        }
                    }
                    wrapperEl.style.transformOrigin = `50% 50% -${swiperSize / 2}px`;
                    wrapperEl.style["-webkit-transform-origin"] = `50% 50% -${swiperSize / 2
                        }px`;
                    if (params.shadow) {
                        if (isHorizontal) {
                            cubeShadowEl.style.transform = `translate3d(0px, ${swiperWidth / 2 + params.shadowOffset
                                }px, ${-swiperWidth / 2
                                }px) rotateX(90deg) rotateZ(0deg) scale(${params.shadowScale})`;
                        } else {
                            const shadowAngle =
                                Math.abs(wrapperRotate) -
                                Math.floor(Math.abs(wrapperRotate) / 90) * 90;
                            const multiplier =
                                1.5 -
                                (Math.sin((shadowAngle * 2 * Math.PI) / 360) / 2 +
                                    Math.cos((shadowAngle * 2 * Math.PI) / 360) / 2);
                            const scale1 = params.shadowScale;
                            const scale2 = params.shadowScale / multiplier;
                            const offset = params.shadowOffset;
                            cubeShadowEl.style.transform = `scale3d(${scale1}, 1, ${scale2}) translate3d(0px, ${swiperHeight / 2 + offset
                                }px, ${-swiperHeight / 2 / scale2}px) rotateX(-90deg)`;
                        }
                    }
                    const zFactor =
                        (browser.isSafari || browser.isWebView) &&
                            browser.needPerspectiveFix
                            ? -swiperSize / 2
                            : 0;
                    wrapperEl.style.transform = `translate3d(0px,0,${zFactor}px) rotateX(${swiper.isHorizontal() ? 0 : wrapperRotate
                        }deg) rotateY(${swiper.isHorizontal() ? -wrapperRotate : 0}deg)`;
                    wrapperEl.style.setProperty(
                        "--swiper-cube-translate-z",
                        `${zFactor}px`
                    );
                };
                const setTransition = (duration) => {
                    const { el, slides } = swiper;
                    slides.forEach((slideEl) => {
                        slideEl.style.transitionDuration = `${duration}ms`;
                        slideEl
                            .querySelectorAll(
                                ".swiper-slide-shadow-top, .swiper-slide-shadow-right, .swiper-slide-shadow-bottom, .swiper-slide-shadow-left"
                            )
                            .forEach((subEl) => {
                                subEl.style.transitionDuration = `${duration}ms`;
                            });
                    });
                    if (swiper.params.cubeEffect.shadow && !swiper.isHorizontal()) {
                        const shadowEl = el.querySelector(".swiper-cube-shadow");
                        if (shadowEl) shadowEl.style.transitionDuration = `${duration}ms`;
                    }
                };
                effectInit({
                    effect: "cube",
                    swiper,
                    on,
                    setTranslate,
                    setTransition,
                    recreateShadows,
                    getEffectParams: () => swiper.params.cubeEffect,
                    perspective: () => true,
                    overwriteParams: () => ({
                        slidesPerView: 1,
                        slidesPerGroup: 1,
                        watchSlidesProgress: true,
                        resistanceRatio: 0,
                        spaceBetween: 0,
                        centeredSlides: false,
                        virtualTranslate: true,
                    }),
                });
            }

            function createShadow(suffix, slideEl, side) {
                const shadowClass = `swiper-slide-shadow${side ? `-${side}` : ""}${suffix ? ` swiper-slide-shadow-${suffix}` : ""
                    }`;
                const shadowContainer = getSlideTransformEl(slideEl);
                let shadowEl = shadowContainer.querySelector(
                    `.${shadowClass.split(" ").join(".")}`
                );
                if (!shadowEl) {
                    shadowEl = createElement("div", shadowClass.split(" "));
                    shadowContainer.append(shadowEl);
                }
                return shadowEl;
            }

            function EffectFlip(_ref) {
                let { swiper, extendParams, on } = _ref;
                extendParams({
                    flipEffect: {
                        slideShadows: true,
                        limitRotation: true,
                    },
                });
                const createSlideShadows = (slideEl, progress) => {
                    let shadowBefore = swiper.isHorizontal()
                        ? slideEl.querySelector(".swiper-slide-shadow-left")
                        : slideEl.querySelector(".swiper-slide-shadow-top");
                    let shadowAfter = swiper.isHorizontal()
                        ? slideEl.querySelector(".swiper-slide-shadow-right")
                        : slideEl.querySelector(".swiper-slide-shadow-bottom");
                    if (!shadowBefore) {
                        shadowBefore = createShadow(
                            "flip",
                            slideEl,
                            swiper.isHorizontal() ? "left" : "top"
                        );
                    }
                    if (!shadowAfter) {
                        shadowAfter = createShadow(
                            "flip",
                            slideEl,
                            swiper.isHorizontal() ? "right" : "bottom"
                        );
                    }
                    if (shadowBefore)
                        shadowBefore.style.opacity = Math.max(-progress, 0);
                    if (shadowAfter) shadowAfter.style.opacity = Math.max(progress, 0);
                };
                const recreateShadows = () => {
                    // Set shadows
                    swiper.params.flipEffect;
                    swiper.slides.forEach((slideEl) => {
                        let progress = slideEl.progress;
                        if (swiper.params.flipEffect.limitRotation) {
                            progress = Math.max(Math.min(slideEl.progress, 1), -1);
                        }
                        createSlideShadows(slideEl, progress);
                    });
                };
                const setTranslate = () => {
                    const { slides, rtlTranslate: rtl } = swiper;
                    const params = swiper.params.flipEffect;
                    for (let i = 0; i < slides.length; i += 1) {
                        const slideEl = slides[i];
                        let progress = slideEl.progress;
                        if (swiper.params.flipEffect.limitRotation) {
                            progress = Math.max(Math.min(slideEl.progress, 1), -1);
                        }
                        const offset = slideEl.swiperSlideOffset;
                        const rotate = -180 * progress;
                        let rotateY = rotate;
                        let rotateX = 0;
                        let tx = swiper.params.cssMode
                            ? -offset - swiper.translate
                            : -offset;
                        let ty = 0;
                        if (!swiper.isHorizontal()) {
                            ty = tx;
                            tx = 0;
                            rotateX = -rotateY;
                            rotateY = 0;
                        } else if (rtl) {
                            rotateY = -rotateY;
                        }
                        slideEl.style.zIndex =
                            -Math.abs(Math.round(progress)) + slides.length;
                        if (params.slideShadows) {
                            createSlideShadows(slideEl, progress);
                        }
                        const transform = `translate3d(${tx}px, ${ty}px, 0px) rotateX(${rotateX}deg) rotateY(${rotateY}deg)`;
                        const targetEl = effectTarget(params, slideEl);
                        targetEl.style.transform = transform;
                    }
                };
                const setTransition = (duration) => {
                    const transformElements = swiper.slides.map((slideEl) =>
                        getSlideTransformEl(slideEl)
                    );
                    transformElements.forEach((el) => {
                        el.style.transitionDuration = `${duration}ms`;
                        el.querySelectorAll(
                            ".swiper-slide-shadow-top, .swiper-slide-shadow-right, .swiper-slide-shadow-bottom, .swiper-slide-shadow-left"
                        ).forEach((shadowEl) => {
                            shadowEl.style.transitionDuration = `${duration}ms`;
                        });
                    });
                    effectVirtualTransitionEnd({
                        swiper,
                        duration,
                        transformElements,
                    });
                };
                effectInit({
                    effect: "flip",
                    swiper,
                    on,
                    setTranslate,
                    setTransition,
                    recreateShadows,
                    getEffectParams: () => swiper.params.flipEffect,
                    perspective: () => true,
                    overwriteParams: () => ({
                        slidesPerView: 1,
                        slidesPerGroup: 1,
                        watchSlidesProgress: true,
                        spaceBetween: 0,
                        virtualTranslate: !swiper.params.cssMode,
                    }),
                });
            }

            function EffectCoverflow(_ref) {
                let { swiper, extendParams, on } = _ref;
                extendParams({
                    coverflowEffect: {
                        rotate: 50,
                        stretch: 0,
                        depth: 100,
                        scale: 1,
                        modifier: 1,
                        slideShadows: true,
                    },
                });
                const setTranslate = () => {
                    const {
                        width: swiperWidth,
                        height: swiperHeight,
                        slides,
                        slidesSizesGrid,
                    } = swiper;
                    const params = swiper.params.coverflowEffect;
                    const isHorizontal = swiper.isHorizontal();
                    const transform = swiper.translate;
                    const center = isHorizontal
                        ? -transform + swiperWidth / 2
                        : -transform + swiperHeight / 2;
                    const rotate = isHorizontal ? params.rotate : -params.rotate;
                    const translate = params.depth;
                    // Each slide offset from center
                    for (let i = 0, length = slides.length; i < length; i += 1) {
                        const slideEl = slides[i];
                        const slideSize = slidesSizesGrid[i];
                        const slideOffset = slideEl.swiperSlideOffset;
                        const centerOffset =
                            (center - slideOffset - slideSize / 2) / slideSize;
                        const offsetMultiplier =
                            typeof params.modifier === "function"
                                ? params.modifier(centerOffset)
                                : centerOffset * params.modifier;
                        let rotateY = isHorizontal ? rotate * offsetMultiplier : 0;
                        let rotateX = isHorizontal ? 0 : rotate * offsetMultiplier;
                        // var rotateZ = 0
                        let translateZ = -translate * Math.abs(offsetMultiplier);
                        let stretch = params.stretch;
                        // Allow percentage to make a relative stretch for responsive sliders
                        if (typeof stretch === "string" && stretch.indexOf("%") !== -1) {
                            stretch = (parseFloat(params.stretch) / 100) * slideSize;
                        }
                        let translateY = isHorizontal ? 0 : stretch * offsetMultiplier;
                        let translateX = isHorizontal ? stretch * offsetMultiplier : 0;
                        let scale = 1 - (1 - params.scale) * Math.abs(offsetMultiplier);

                        // Fix for ultra small values
                        if (Math.abs(translateX) < 0.001) translateX = 0;
                        if (Math.abs(translateY) < 0.001) translateY = 0;
                        if (Math.abs(translateZ) < 0.001) translateZ = 0;
                        if (Math.abs(rotateY) < 0.001) rotateY = 0;
                        if (Math.abs(rotateX) < 0.001) rotateX = 0;
                        if (Math.abs(scale) < 0.001) scale = 0;
                        const slideTransform = `translate3d(${translateX}px,${translateY}px,${translateZ}px)  rotateX(${rotateX}deg) rotateY(${rotateY}deg) scale(${scale})`;
                        const targetEl = effectTarget(params, slideEl);
                        targetEl.style.transform = slideTransform;
                        slideEl.style.zIndex =
                            -Math.abs(Math.round(offsetMultiplier)) + 1;
                        if (params.slideShadows) {
                            // Set shadows
                            let shadowBeforeEl = isHorizontal
                                ? slideEl.querySelector(".swiper-slide-shadow-left")
                                : slideEl.querySelector(".swiper-slide-shadow-top");
                            let shadowAfterEl = isHorizontal
                                ? slideEl.querySelector(".swiper-slide-shadow-right")
                                : slideEl.querySelector(".swiper-slide-shadow-bottom");
                            if (!shadowBeforeEl) {
                                shadowBeforeEl = createShadow(
                                    "coverflow",
                                    slideEl,
                                    isHorizontal ? "left" : "top"
                                );
                            }
                            if (!shadowAfterEl) {
                                shadowAfterEl = createShadow(
                                    "coverflow",
                                    slideEl,
                                    isHorizontal ? "right" : "bottom"
                                );
                            }
                            if (shadowBeforeEl)
                                shadowBeforeEl.style.opacity =
                                    offsetMultiplier > 0 ? offsetMultiplier : 0;
                            if (shadowAfterEl)
                                shadowAfterEl.style.opacity =
                                    -offsetMultiplier > 0 ? -offsetMultiplier : 0;
                        }
                    }
                };
                const setTransition = (duration) => {
                    const transformElements = swiper.slides.map((slideEl) =>
                        getSlideTransformEl(slideEl)
                    );
                    transformElements.forEach((el) => {
                        el.style.transitionDuration = `${duration}ms`;
                        el.querySelectorAll(
                            ".swiper-slide-shadow-top, .swiper-slide-shadow-right, .swiper-slide-shadow-bottom, .swiper-slide-shadow-left"
                        ).forEach((shadowEl) => {
                            shadowEl.style.transitionDuration = `${duration}ms`;
                        });
                    });
                };
                effectInit({
                    effect: "coverflow",
                    swiper,
                    on,
                    setTranslate,
                    setTransition,
                    perspective: () => true,
                    overwriteParams: () => ({
                        watchSlidesProgress: true,
                    }),
                });
            }

            function EffectCreative(_ref) {
                let { swiper, extendParams, on } = _ref;
                extendParams({
                    creativeEffect: {
                        limitProgress: 1,
                        shadowPerProgress: false,
                        progressMultiplier: 1,
                        perspective: true,
                        prev: {
                            translate: [0, 0, 0],
                            rotate: [0, 0, 0],
                            opacity: 1,
                            scale: 1,
                        },
                        next: {
                            translate: [0, 0, 0],
                            rotate: [0, 0, 0],
                            opacity: 1,
                            scale: 1,
                        },
                    },
                });
                const getTranslateValue = (value) => {
                    if (typeof value === "string") return value;
                    return `${value}px`;
                };
                const setTranslate = () => {
                    const { slides, wrapperEl, slidesSizesGrid } = swiper;
                    const params = swiper.params.creativeEffect;
                    const { progressMultiplier: multiplier } = params;
                    const isCenteredSlides = swiper.params.centeredSlides;
                    if (isCenteredSlides) {
                        const margin =
                            slidesSizesGrid[0] / 2 - swiper.params.slidesOffsetBefore || 0;
                        wrapperEl.style.transform = `translateX(calc(50% - ${margin}px))`;
                    }
                    for (let i = 0; i < slides.length; i += 1) {
                        const slideEl = slides[i];
                        const slideProgress = slideEl.progress;
                        const progress = Math.min(
                            Math.max(slideEl.progress, -params.limitProgress),
                            params.limitProgress
                        );
                        let originalProgress = progress;
                        if (!isCenteredSlides) {
                            originalProgress = Math.min(
                                Math.max(slideEl.originalProgress, -params.limitProgress),
                                params.limitProgress
                            );
                        }
                        const offset = slideEl.swiperSlideOffset;
                        const t = [
                            swiper.params.cssMode ? -offset - swiper.translate : -offset,
                            0,
                            0,
                        ];
                        const r = [0, 0, 0];
                        let custom = false;
                        if (!swiper.isHorizontal()) {
                            t[1] = t[0];
                            t[0] = 0;
                        }
                        let data = {
                            translate: [0, 0, 0],
                            rotate: [0, 0, 0],
                            scale: 1,
                            opacity: 1,
                        };
                        if (progress < 0) {
                            data = params.next;
                            custom = true;
                        } else if (progress > 0) {
                            data = params.prev;
                            custom = true;
                        }
                        // set translate
                        t.forEach((value, index) => {
                            t[index] = `calc(${value}px + (${getTranslateValue(
                                data.translate[index]
                            )} * ${Math.abs(progress * multiplier)}))`;
                        });
                        // set rotates
                        r.forEach((value, index) => {
                            r[index] = data.rotate[index] * Math.abs(progress * multiplier);
                        });
                        slideEl.style.zIndex =
                            -Math.abs(Math.round(slideProgress)) + slides.length;
                        const translateString = t.join(", ");
                        const rotateString = `rotateX(${r[0]}deg) rotateY(${r[1]}deg) rotateZ(${r[2]}deg)`;
                        const scaleString =
                            originalProgress < 0
                                ? `scale(${1 + (1 - data.scale) * originalProgress * multiplier
                                })`
                                : `scale(${1 - (1 - data.scale) * originalProgress * multiplier
                                })`;
                        const opacityString =
                            originalProgress < 0
                                ? 1 + (1 - data.opacity) * originalProgress * multiplier
                                : 1 - (1 - data.opacity) * originalProgress * multiplier;
                        const transform = `translate3d(${translateString}) ${rotateString} ${scaleString}`;

                        // Set shadows
                        if ((custom && data.shadow) || !custom) {
                            let shadowEl = slideEl.querySelector(".swiper-slide-shadow");
                            if (!shadowEl && data.shadow) {
                                shadowEl = createShadow("creative", slideEl);
                            }
                            if (shadowEl) {
                                const shadowOpacity = params.shadowPerProgress
                                    ? progress * (1 / params.limitProgress)
                                    : progress;
                                shadowEl.style.opacity = Math.min(
                                    Math.max(Math.abs(shadowOpacity), 0),
                                    1
                                );
                            }
                        }
                        const targetEl = effectTarget(params, slideEl);
                        targetEl.style.transform = transform;
                        targetEl.style.opacity = opacityString;
                        if (data.origin) {
                            targetEl.style.transformOrigin = data.origin;
                        }
                    }
                };
                const setTransition = (duration) => {
                    const transformElements = swiper.slides.map((slideEl) =>
                        getSlideTransformEl(slideEl)
                    );
                    transformElements.forEach((el) => {
                        el.style.transitionDuration = `${duration}ms`;
                        el.querySelectorAll(".swiper-slide-shadow").forEach(
                            (shadowEl) => {
                                shadowEl.style.transitionDuration = `${duration}ms`;
                            }
                        );
                    });
                    effectVirtualTransitionEnd({
                        swiper,
                        duration,
                        transformElements,
                        allSlides: true,
                    });
                };
                effectInit({
                    effect: "creative",
                    swiper,
                    on,
                    setTranslate,
                    setTransition,
                    perspective: () => swiper.params.creativeEffect.perspective,
                    overwriteParams: () => ({
                        watchSlidesProgress: true,
                        virtualTranslate: !swiper.params.cssMode,
                    }),
                });
            }

            function EffectCards(_ref) {
                let { swiper, extendParams, on } = _ref;
                extendParams({
                    cardsEffect: {
                        slideShadows: true,
                        rotate: true,
                        perSlideRotate: 2,
                        perSlideOffset: 8,
                    },
                });
                const setTranslate = () => {
                    const { slides, activeIndex, rtlTranslate: rtl } = swiper;
                    const params = swiper.params.cardsEffect;
                    const { startTranslate, isTouched } = swiper.touchEventsData;
                    const currentTranslate = rtl ? -swiper.translate : swiper.translate;
                    for (let i = 0; i < slides.length; i += 1) {
                        const slideEl = slides[i];
                        const slideProgress = slideEl.progress;
                        const progress = Math.min(Math.max(slideProgress, -4), 4);
                        let offset = slideEl.swiperSlideOffset;
                        if (swiper.params.centeredSlides && !swiper.params.cssMode) {
                            swiper.wrapperEl.style.transform = `translateX(${swiper.minTranslate()}px)`;
                        }
                        if (swiper.params.centeredSlides && swiper.params.cssMode) {
                            offset -= slides[0].swiperSlideOffset;
                        }
                        let tX = swiper.params.cssMode
                            ? -offset - swiper.translate
                            : -offset;
                        let tY = 0;
                        const tZ = -100 * Math.abs(progress);
                        let scale = 1;
                        let rotate = -params.perSlideRotate * progress;
                        let tXAdd = params.perSlideOffset - Math.abs(progress) * 0.75;
                        const slideIndex =
                            swiper.virtual && swiper.params.virtual.enabled
                                ? swiper.virtual.from + i
                                : i;
                        const isSwipeToNext =
                            (slideIndex === activeIndex ||
                                slideIndex === activeIndex - 1) &&
                            progress > 0 &&
                            progress < 1 &&
                            (isTouched || swiper.params.cssMode) &&
                            currentTranslate < startTranslate;
                        const isSwipeToPrev =
                            (slideIndex === activeIndex ||
                                slideIndex === activeIndex + 1) &&
                            progress < 0 &&
                            progress > -1 &&
                            (isTouched || swiper.params.cssMode) &&
                            currentTranslate > startTranslate;
                        if (isSwipeToNext || isSwipeToPrev) {
                            const subProgress =
                                (1 - Math.abs((Math.abs(progress) - 0.5) / 0.5)) ** 0.5;
                            rotate += -28 * progress * subProgress;
                            scale += -0.5 * subProgress;
                            tXAdd += 96 * subProgress;
                            tY = `${-25 * subProgress * Math.abs(progress)}%`;
                        }
                        if (progress < 0) {
                            // next
                            tX = `calc(${tX}px ${rtl ? "-" : "+"} (${tXAdd * Math.abs(progress)
                                }%))`;
                        } else if (progress > 0) {
                            // prev
                            tX = `calc(${tX}px ${rtl ? "-" : "+"} (-${tXAdd * Math.abs(progress)
                                }%))`;
                        } else {
                            tX = `${tX}px`;
                        }
                        if (!swiper.isHorizontal()) {
                            const prevY = tY;
                            tY = tX;
                            tX = prevY;
                        }
                        const scaleString =
                            progress < 0
                                ? `${1 + (1 - scale) * progress}`
                                : `${1 - (1 - scale) * progress}`;

                        /* eslint-disable */
                        const transform = `
        translate3d(${tX}, ${tY}, ${tZ}px)
        rotateZ(${params.rotate ? (rtl ? -rotate : rotate) : 0}deg)
        scale(${scaleString})
      `;
                        /* eslint-enable */

                        if (params.slideShadows) {
                            // Set shadows
                            let shadowEl = slideEl.querySelector(".swiper-slide-shadow");
                            if (!shadowEl) {
                                shadowEl = createShadow("cards", slideEl);
                            }
                            if (shadowEl)
                                shadowEl.style.opacity = Math.min(
                                    Math.max((Math.abs(progress) - 0.5) / 0.5, 0),
                                    1
                                );
                        }
                        slideEl.style.zIndex =
                            -Math.abs(Math.round(slideProgress)) + slides.length;
                        const targetEl = effectTarget(params, slideEl);
                        targetEl.style.transform = transform;
                    }
                };
                const setTransition = (duration) => {
                    const transformElements = swiper.slides.map((slideEl) =>
                        getSlideTransformEl(slideEl)
                    );
                    transformElements.forEach((el) => {
                        el.style.transitionDuration = `${duration}ms`;
                        el.querySelectorAll(".swiper-slide-shadow").forEach(
                            (shadowEl) => {
                                shadowEl.style.transitionDuration = `${duration}ms`;
                            }
                        );
                    });
                    effectVirtualTransitionEnd({
                        swiper,
                        duration,
                        transformElements,
                    });
                };
                effectInit({
                    effect: "cards",
                    swiper,
                    on,
                    setTranslate,
                    setTransition,
                    perspective: () => true,
                    overwriteParams: () => ({
                        watchSlidesProgress: true,
                        virtualTranslate: !swiper.params.cssMode,
                    }),
                });
            }

            /**
             * Swiper 10.0.4
             * Most modern mobile touch slider and framework with hardware accelerated transitions
             * https://swiperjs.com
             *
             * Copyright 2014-2023 Vladimir Kharlampidi
             *
             * Released under the MIT License
             *
             * Released on: July 8, 2023
             */

            // Swiper Class
            const modules = [
                Virtual,
                Keyboard,
                Mousewheel,
                Navigation,
                Pagination,
                Scrollbar,
                Parallax,
                Zoom,
                Controller,
                A11y,
                History,
                HashNavigation,
                Autoplay,
                Thumb,
                freeMode,
                Grid,
                Manipulation,
                EffectFade,
                EffectCube,
                EffectFlip,
                EffectCoverflow,
                EffectCreative,
                EffectCards,
            ];
            Swiper.use(modules);

            return Swiper;
        })();
    </script>
    <!-- Initialize Swiper -->
    <script>
        var swiper = new Swiper("#mySwiper1", {
            slidesPerView: 1,
            spaceBetween: 30,
            slidesPerGroup: 1,
            loop: false,
            loopFillGroupWithBlank: true,
            pagination: {
                el: "#swiper-pagination-1",
                clickable: true,
            },
            navigation: {
                nextEl: "#swiper-button-next-1",
                prevEl: "#swiper-button-prev-1",
            },
        });

        var swiper = new Swiper("#mySwiper2", {
            slidesPerView: 1,
            spaceBetween: 30,
            slidesPerGroup: 1,
            loop: false,
            loopFillGroupWithBlank: true,
            pagination: {
                el: "#swiper-pagination-2",
                clickable: true,
            },
            navigation: {
                nextEl: "#swiper-button-next-2",
                prevEl: "#swiper-button-prev-2",
            },
        });

        var swiper = new Swiper("#mySwiper3", {
            slidesPerView: 1,
            spaceBetween: 30,
            slidesPerGroup: 1,
            loop: false,
            loopFillGroupWithBlank: true,
            pagination: {
                el: "#swiper-pagination-3",
                clickable: true,
            },
            navigation: {
                nextEl: "#swiper-button-next-3",
                prevEl: "#swiper-button-prev-3",
            },
        });

        var swiper = new Swiper("#mySwiper4", {
            slidesPerView: 1,
            spaceBetween: 30,
            slidesPerGroup: 1,
            loop: false,
            loopFillGroupWithBlank: true,
            pagination: {
                el: "#swiper-pagination-4",
                clickable: true,
            },
            navigation: {
                nextEl: "#swiper-button-next-4",
                prevEl: "#swiper-button-prev-4",
            },
        });
    </script>
</body>

</html>